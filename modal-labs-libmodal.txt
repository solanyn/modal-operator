Directory structure:
└── modal-labs-libmodal/
    ├── README.md
    ├── CHANGELOG.md
    ├── DEVELOPING.md
    ├── LICENSE
    ├── ruff.toml
    ├── .editorconfig
    ├── ci/
    │   └── release.py
    ├── modal-go/
    │   ├── README.md
    │   ├── app.go
    │   ├── app_test.go
    │   ├── client.go
    │   ├── client_testhooks.go
    │   ├── cloud_bucket_mount.go
    │   ├── cloud_bucket_mount_test.go
    │   ├── cls.go
    │   ├── cls_test.go
    │   ├── config.go
    │   ├── doc.go
    │   ├── ephemeral.go
    │   ├── errors.go
    │   ├── function.go
    │   ├── function_call.go
    │   ├── go.mod
    │   ├── go.sum
    │   ├── image.go
    │   ├── invocation.go
    │   ├── proxy.go
    │   ├── queue.go
    │   ├── retries.go
    │   ├── sandbox.go
    │   ├── sandbox_filesystem.go
    │   ├── sandbox_test.go
    │   ├── secret.go
    │   ├── serialization_test.go
    │   ├── volume.go
    │   ├── .golangci.toml
    │   ├── examples/
    │   │   ├── cls-call/
    │   │   │   └── main.go
    │   │   ├── cls-call-with-options/
    │   │   │   └── main.go
    │   │   ├── function-call/
    │   │   │   └── main.go
    │   │   ├── function-current-stats/
    │   │   │   └── main.go
    │   │   ├── function-spawn/
    │   │   │   └── main.go
    │   │   ├── image-building/
    │   │   │   └── main.go
    │   │   ├── init-client/
    │   │   │   └── main.go
    │   │   ├── sandbox/
    │   │   │   └── main.go
    │   │   ├── sandbox-agent/
    │   │   │   └── main.go
    │   │   ├── sandbox-cloud-bucket/
    │   │   │   └── main.go
    │   │   ├── sandbox-exec/
    │   │   │   └── main.go
    │   │   ├── sandbox-filesystem/
    │   │   │   └── main.go
    │   │   ├── sandbox-filesystem-snapshot/
    │   │   │   └── main.go
    │   │   ├── sandbox-gpu/
    │   │   │   └── main.go
    │   │   ├── sandbox-named/
    │   │   │   └── main.go
    │   │   ├── sandbox-poll/
    │   │   │   └── main.go
    │   │   ├── sandbox-prewarm/
    │   │   │   └── main.go
    │   │   ├── sandbox-private-image/
    │   │   │   └── main.go
    │   │   ├── sandbox-proxy/
    │   │   │   └── main.go
    │   │   ├── sandbox-secrets/
    │   │   │   └── main.go
    │   │   ├── sandbox-tunnels/
    │   │   │   └── main.go
    │   │   ├── sandbox-volume/
    │   │   │   └── main.go
    │   │   └── sandbox-volume-ephemeral/
    │   │       └── main.go
    │   ├── proto/
    │   │   └── modal_proto/
    │   │       └── options.pb.go
    │   ├── scripts/
    │   │   └── gen-proto.sh
    │   ├── test/
    │   │   ├── cls_test.go
    │   │   ├── cls_with_options_test.go
    │   │   ├── function_call_test.go
    │   │   ├── function_test.go
    │   │   ├── image_test.go
    │   │   ├── proxy_test.go
    │   │   ├── queue_test.go
    │   │   ├── retries_test.go
    │   │   ├── sandbox_filesystem_snapshot_test.go
    │   │   ├── sandbox_filesystem_test.go
    │   │   ├── sandbox_test.go
    │   │   ├── secret_test.go
    │   │   └── volume_test.go
    │   └── testsupport/
    │       └── grpcmock/
    │           └── mock.go
    ├── modal-js/
    │   ├── README.md
    │   ├── eslint.config.js
    │   ├── package.json
    │   ├── tsconfig.json
    │   ├── tsup.config.ts
    │   ├── vitest.config.ts
    │   ├── examples/
    │   │   ├── cls-call-with-options.ts
    │   │   ├── cls-call.ts
    │   │   ├── function-call.ts
    │   │   ├── function-current-stats.ts
    │   │   ├── function-spawn.ts
    │   │   ├── image-building.ts
    │   │   ├── init-client.ts
    │   │   ├── reliability.ts
    │   │   ├── reliability2.ts
    │   │   ├── sandbox-agent.ts
    │   │   ├── sandbox-cloud-bucket.ts
    │   │   ├── sandbox-exec.ts
    │   │   ├── sandbox-filesystem-snapshot.ts
    │   │   ├── sandbox-filesystem.ts
    │   │   ├── sandbox-gpu.ts
    │   │   ├── sandbox-named.ts
    │   │   ├── sandbox-poll.ts
    │   │   ├── sandbox-prewarm.ts
    │   │   ├── sandbox-private-image.ts
    │   │   ├── sandbox-proxy.ts
    │   │   ├── sandbox-secrets.ts
    │   │   ├── sandbox-tunnels.ts
    │   │   ├── sandbox-volume-ephemeral.ts
    │   │   ├── sandbox-volume.ts
    │   │   └── sandbox.ts
    │   ├── scripts/
    │   │   └── gen-proto.sh
    │   ├── src/
    │   │   ├── app.ts
    │   │   ├── client.ts
    │   │   ├── cloud_bucket_mount.ts
    │   │   ├── cls.ts
    │   │   ├── config.ts
    │   │   ├── ephemeral.ts
    │   │   ├── errors.ts
    │   │   ├── function.ts
    │   │   ├── function_call.ts
    │   │   ├── image.ts
    │   │   ├── index.ts
    │   │   ├── invocation.ts
    │   │   ├── pickle.test.ts
    │   │   ├── pickle.ts
    │   │   ├── proxy.ts
    │   │   ├── queue.ts
    │   │   ├── retries.ts
    │   │   ├── sandbox.ts
    │   │   ├── sandbox_filesystem.ts
    │   │   ├── secret.ts
    │   │   ├── serialization.test.ts
    │   │   ├── streams.ts
    │   │   └── volume.ts
    │   ├── test/
    │   │   ├── app.test.ts
    │   │   ├── cloud_bucket_mount.test.ts
    │   │   ├── cls.test.ts
    │   │   ├── cls_with_options.test.ts
    │   │   ├── function.test.ts
    │   │   ├── function_call.test.ts
    │   │   ├── image.test.ts
    │   │   ├── proxy.test.ts
    │   │   ├── queue.test.ts
    │   │   ├── retries.test.ts
    │   │   ├── sandbox.test.ts
    │   │   ├── sandbox_filesystem.test.ts
    │   │   ├── sandbox_filesystem_snapshot.test.ts
    │   │   ├── secret.test.ts
    │   │   └── volume.test.ts
    │   └── test-support/
    │       └── grpc_mock.ts
    ├── test-support/
    │   ├── README.md
    │   ├── libmodal_test_support.py
    │   └── setup.sh
    └── .github/
        └── workflows/
            ├── ci.yaml
            ├── docs.yaml
            ├── publish.yaml
            └── release.yaml

================================================
FILE: README.md
================================================
# libmodal: [Modal](https://modal.com) SDK Lite

Modal client libraries for JavaScript and Go. **(Alpha)**

This repository provides lightweight alternatives to the [Modal Python Library](https://github.com/modal-labs/modal-client). They let you start Sandboxes (secure VMs), call Modal Functions, and manage containers. However, they don't support deploying Modal Functions — those still need to be written in Python!

Each language in this repository has a library with similar features and API, so you can use Modal from any project.

## Setup

Make sure you've authenticated with Modal. You can either sign in with the Modal CLI `pip install modal && modal setup`, or in machine environments, set the following environment variables on your app:

```bash
# Replace these with your actual token!
export MODAL_TOKEN_ID=ak-NOTAREALTOKENSTRINGXYZ
export MODAL_TOKEN_SECRET=as-FAKESECRETSTRINGABCDEF
```

Then you're ready to add the Modal SDK to your project.

### JavaScript (`modal-js/`)

Install this in any server-side Node.js / Deno / Bun project.

```bash
npm install modal
```

Examples:

- [Call a deployed Function](./modal-js/examples/function-call.ts)
- [Spawn a deployed Function](./modal-js/examples/function-spawn.ts)
- [Call a deployed Cls](./modal-js/examples/cls-call.ts)
- [Call a deployed Cls, and override its options](./modal-js/examples/cls-call-with-options.ts)
- [Create a Sandbox](./modal-js/examples/sandbox.ts)
- [Create a named Sandbox](./modal-js/examples/sandbox-named.ts)
- [Create a Sandbox with GPU](./modal-js/examples/sandbox-gpu.ts)
- [Create a Sandbox using a private image from AWS ECR](./modal-js/examples/sandbox-private-image.ts)
- [Take a snapshot of the filesystem of a Sandbox](./modal-js/examples/sandbox-filesystem-snapshot.ts)
- [Execute Sandbox commands](./modal-js/examples/sandbox-exec.ts)
- [Running a coding agent in a Sandbox](./modal-js/examples/sandbox-agent.ts)
- [Check the status and exit code of a Sandbox](./modal-js/examples/sandbox-poll.ts)
- [Access Sandbox filesystem](./modal-js/examples/sandbox-filesystem.ts)
- [Expose ports on a Sandbox using Tunnels](./modal-js/examples/sandbox-tunnels.ts)
- [Include Secrets in Sandbox](./modal-js/examples/sandbox-secrets.ts)
- [Mount a Volume to a Sandbox](./modal-js/examples/sandbox-volume.ts), and same but with an [ephemeral Volume](./modal-js/examples/sandbox-volume-ephemeral.ts)
- [Mount a cloud bucket to a Sandbox](./modal-js/examples/sandbox-cloud-bucket.ts)
- [Eagarly build an Image for a Sandbox](./modal-js/examples/sandbox-prewarm.ts)
- [Building custom Images](./modal-js/examples/image-building.ts)

### Go (`modal-go/`)

First, use `go get` to install the latest version of the library.

```bash
go get -u github.com/modal-labs/libmodal/modal-go
```

Next, include Modal in your application:

```go
import "github.com/modal-labs/libmodal/modal-go"
```

Examples:

- [Call a deployed Function](./modal-go/examples/function-call/main.go)
- [Spawn a deployed Function](./modal-go/examples/function-spawn/main.go)
- [Call a deployed Cls](./modal-go/examples/cls-call/main.go)
- [Call a deployed Cls, and override its options](./modal-go/examples/cls-call-with-options/main.go)
- [Create a Sandbox](./modal-go/examples/sandbox/main.go)
- [Create a named Sandbox](./modal-go/examples/sandbox-named/main.go)
- [Create a Sandbox with GPU](./modal-go/examples/sandbox-gpu/main.go)
- [Create a Sandbox using a private image from AWS ECR](./modal-go/examples/sandbox-private-image/main.go)
- [Take a snapshot of the filesystem of a Sandbox](./modal-go/examples/sandbox-filesystem-snapshot/main.go)
- [Execute Sandbox commands](./modal-go/examples/sandbox-exec/main.go)
- [Running a coding agent in a Sandbox](./modal-go/examples/sandbox-agent/main.go)
- [Check the status and exit code of a Sandbox](./modal-go/examples/sandbox-poll/main.go)
- [Access Sandbox filesystem](./modal-go/examples/sandbox-filesystem/main.go)
- [Expose ports on a Sandbox using Tunnels](./modal-go/examples/sandbox-tunnels/main.go)
- [Include Secrets in Sandbox](./modal-go/examples/sandbox-secrets/main.go)
- [Mount a Volume to a Sandbox](./modal-go/examples/sandbox-volume/main.go), and same but with an [ephemeral Volume](./modal-go/examples/sandbox-volume-ephemeral/main.go)
- [Mount a cloud bucket to a Sandbox](./modal-go/examples/sandbox-cloud-bucket/main.go)
- [Eagarly build an Image for a Sandbox](./modal-go/examples/sandbox-prewarm/main.go)
- [Building custom Images](./modal-go/examples/image-building/main.go)

### Python

If you're using Python, please use the [Modal Python Library](https://github.com/modal-labs/modal-client), which is the main SDK and a separate project.

## Technical details

`libmodal` is a cross-language client SDK for Modal. However, it does not have all the features of the [Modal Python Library](https://github.com/modal-labs/modal-client). We hope to add more features over time, although defining Modal Functions will still be exclusively in Python.

### Tests

Tests are run against production, and you need to be authenticated with Modal to run them. See the [`test-support/`](./test-support) folder for details.

### Development principles

To keep complexity manageable, we try to maintain identical behavior across languages. This means:

- When merging a feature or change into `main`, update it for all languages simultaneously, with tests.
- Code structure should be similar between folders.
- Use a common set of gRPC primitives (retries, deadlines) and exceptions.
- Complex types like streams must behave as close as possible.
- Timeouts should use milliseconds in TypeScript, and `time.Duration` in Go.

## License

Code is released under [a permissive license](./LICENSE).


## Community SDKs

There are also open-source Modal libraries built and maintained by our community. These projects are not officially supported by Modal and we thus can't vouch for them, but feel free to explore and contribute.

- Ruby: [anthonycorletti/modal-rb](https://github.com/anthonycorletti/modal-rb)



================================================
FILE: CHANGELOG.md
================================================
# Changelog

Both client libraries are pre-1.0, and they have separate versioning.

## Unreleased

No unreleased changes.

## modal-js/v0.3.24, modal-go/v0.0.24

- Added `env` parameters to several methods, as a convenience for passing environment variables into Sandboxes, etc.
- Added `Sandbox.getTags()` (JS) and `Sandbox.GetTags()` (Go).

## modal-js/v0.3.23, modal-go/v0.0.23

- Added support for PTYs in Sandboxes.

## modal-js/v0.3.22, modal-go/v0.0.22

- Added `Image.dockerfileCommands()` (JS) and `ImageDockerfileCommands()` (Go).

## modal-js/v0.3.21, modal-go/v0.0.21

- Added support for setting idle timeout when creating Sandboxes.

## modal-js/v0.3.20, modal-go/v0.0.20

- Added `Image.delete()` (JS) and `ImageDelete()` (Go).
- Changed `Image.fromId()` (JS) and `NewImageFromId()` (Go) to throw a `NotFoundError` if the Image does not exist. Note that the signature of `NewImageFromId()` has changed.

## modal-js/v0.3.19, modal-go/v0.0.19

- `Sandbox.exec` in JS now correctly accepts a list of Secrets.

## modal-js/v0.3.18, modal-go/v0.0.18

- Added `Image.build` (JS) and `Image.Build` (Go).
- Added `Image.fromId` (JS) / `NewImageFromId` (Go).
- Operations on an ehpemeral Queue after having called `CloseEhpemeral()` will now explicitly fail in Go.
- Added support for instantiating a Cls with custom options, using `Cls.withOptions()`/`.withConcurrency()`/`.withBatching()` (JS) / `Cls.WithOptions()`/`.WithConcurrency()`/`.WithBatching()` (Go).
- Added support for [Named Sandboxes](https://modal.com/docs/guide/sandbox#named-sandboxes) (examples in [JS](./modal-js/examples/sandbox-named.ts) and [Go](./modal-go/examples/sandbox-named/main.go)).
- Added support for `Volume.ephemeral()` (JS) / `VolumeEphemeral()` (Go).

## modal-js/v0.3.17, modal-go/v0.0.17

- Added support for more parameters to `Sandbox.create()`:
  - `blockNetwork`: Whether to block all network access from the Sandbox.
  - `cidrAllowlist`: List of CIDRs the Sandbox is allowed to access.
  - `gpu`: GPU reservation for the Sandbox (e.g. "A100", "T4:2", "A100-80GB:4").
  - `cloud`: Cloud provider to run the Sandbox on.
  - `regions`: Region(s) to run the Sandbox on.
  - `verbose`: Enable verbose logging.
  - `proxy`: Connect a Modal Proxy to a Sandbox.
  - `workdir`: Set the working directory.
- Added support for mounting `CloudBucketMount`s to Sandboxes.
- Added top level for Image objects that are lazy. The Images are built when creating a Sandbox.
  - `Image.fromRegistry` in typescript and `NewImageFromRegistry` in golang.
  - `Image.fromAwsEcr` in typescript and `NewImageFromAwsEcr` in golang.
  - `Image.fromGcpArtifactRegistry` in typescript and `NewImageFromGcpArtifactRegistry` in golang.
- Added `Secret.fromObject()` (JS) / `SecretFromMap()` (Go) to create a Secret from key-value pairs (like `from_dict()` in Python).
- Added `name` field to `App`s, `Sandbox`es, `Secret`s, `Volume`s, and `Queue`s.
- Added support for `Function.getCurrentStats()` (JS) / `Function.GetCurrentStats()` (Go).
- Added support for `Function.updateAutoscaler()` (JS) / `Function.UpdateAutoscaler()` (Go).
- Added support for `Function.getWebURL()` (JS) / `Function.GetWebURL()` (Go).
- Added support for `Volume.readOnly()` (JS) / `Volume.ReadOnly()` (Go).
- Added support for setting tags on Sandboxes, and for listing Sandboxes (by tag).

## modal-js/v0.3.16, modal-go/v0.0.16

- Added support for getting Sandboxes from an ID.

## modal-js/v0.3.15, modal-go/v0.0.15

- Added support for snapshotting the filesystem of a Sandbox.
- Added support for polling Sandboxes to check if they are still running, or get the exit code.
- Added support to execute commands in Sandboxes with Secrets.
- Added support for creating Sandboxes with Secrets.

## modal-js/v0.3.14, modal-go/v0.0.14

- Added support for setting up Tunnels to expose live TCP ports for Sandboxes.

## modal-js/v0.3.13, modal-go/v0.0.13

- Fixed calls of Cls with experimental `input_plane_region` option.
- (Go) Removed `Function.InputPlaneURL` from being exposed as public API.

## modal-js/v0.3.12, modal-go/v0.0.12

- Added support for passing a Secret to `imageFromRegistry()` (JS) / `ImageFromRegistry()` (Go) to pull images from private registries.
- Added support for creating Images from Google Artifact Registry with `imageFromGcpArtifactRegistry()` (JS) / `ImageFromGcpArtifactRegistry()` (Go).
- Added experimental support for calling remote Functions deployed with the `input_plane_region` option in Python.

## modal-js/v0.3.11, modal-go/v0.0.11

- Added `InitializeClient()` (Go) / `initializeClient()` (JS) to initialize the client at runtime with credentials.
- Client libraries no longer panic at startup if no token ID / Secret is provided. Instead, they will throw an error when trying to use the client.

## modal-js/v0.3.10, modal-go/v0.0.10

- Added `workdir` and `timeout` options to `ExecOptions` for Sandbox processes.

## modal-js/v0.3.9, modal-go/v0.0.9

- Added support for Sandbox filesystem.

## modal-js/v0.3.8

- Added support for CommonJS format / `require()`. Previously, modal-js only supported ESM `import`.

## modal-js/v0.3.7, modal-go/v0.0.8

- Added support for creating Images from AWS ECR with `App.imageFromAwsEcr()` (JS) / `App.ImageFromAwsEcr()` (Go).
- Added support for accessing Modal Secrets with `Secret.fromName()` (JS) / `modal.SecretFromName()` (Go).
- Fixed serialization of some pickled objects (negative ints, dicts) in modal-js.

## modal-js/v0.3.6, modal-go/v0.0.7

- Added support for the `Queue` object to manage distributed FIFO queues.
  - Queues have a similar interface as Python, with `put()` and `get()` being the primary methods.
  - You can put structured objects onto Queues, with limited support for the pickle format.
- Added `InvalidError`, `QueueEmptyError`, and `QueueFullError` to support Queues.
- Fixed a bug in `modal-js` that produced incorrect bytecode for bytes objects.
- Options in the Go SDK now take pointer types, and can be `nil` for default values.

## modal-js/v0.3.5, modal-go/v0.0.6

- Added support for spawning Functions with `Function_.spawn()` (JS) / `Function.Spawn()` (Go).

## modal-js/v0.3.4, modal-go/v0.0.5

- Added feature for looking up and calling remote classes via the `Cls` object.
- (Go) Removed the initial `ctx context.Context` argument from `Function.Remote()`.

## modal-js/v0.3.3, modal-go/v0.0.4

- Support calling remote Functions with arguments greater than 2 MiB in byte payload size.

## modal-js/v0.3.2, modal-go/v0.0.3

- First public release
- Basic `Function`, `Sandbox`, `Image`, and `ContainerProcess` support



================================================
FILE: DEVELOPING.md
================================================
# Developing `libmodal`

## modal-go development

Clone this repository. You should be all set to run an example.

```bash
go run ./examples/sandbox
```

Whenever you need a new version of the protobufs, you can regenerate them:

```bash
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
scripts/gen-proto.sh
```

We check the generated into Git so that the package can be installed with `go get`.

## modal-js development

Setup after cloning the repo with submodules:

```bash
npm install
```

Then run a script with:

```bash
node --import tsx path/to/script.ts
```

### gRPC support

We're using `nice-grpc` because the `@grpc/grpc-js` library doesn't support promises and is difficult to customize with types.

This gRPC library depends on the `protobuf-ts` package, which is not compatible with tree shaking because `ModalClientDefinition` transitively references every type. However, since `modal-js` is a server-side package, having a larger bundled library is not a huge issue.

## How to publish

1. Update `CHANGELOG.md`. Make sure that you're on a clean commit, then run the following update the `modal-js` version and update the changelog:

```bash
git switch -c release_branch_for_pr origin/main
python ci/release.py version patch  # or 'minor'
```

2. Open a PR with changes.

3. When PR is merged, pull changes locally and switch to main branch.

```bash
git switch -C main origin/main
```

4. Publish both `modal-js` and `modal-go`:

```bash
python ci/release.py publish
```



================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS



================================================
FILE: ruff.toml
================================================
exclude = [
    '.venv',
    '.git',
    '__pycache__',
]
line-length = 120
lint.ignore = ['E741']
lint.select = ['E', 'F', 'W', 'I']

[lint.isort]
combine-as-imports = true
known-first-party = [
    "modal",
]
extra-standard-library = ["pytest"]



================================================
FILE: .editorconfig
================================================
[*]
insert_final_newline = true
trim_trailing_whitespace = true
end_of_line = lf

[*.{md,js,jsx,ts,tsx,html,css,yml,yaml,json,svelte,sh}]
tab_width = 2
indent_size = 2
indent_style = space



================================================
FILE: ci/release.py
================================================
"""CLI to help prepare and publish release.

To prepare release for

```bash
python ci/release.py version patch  # or 'minor'
```

To publish run:

```bash
python ci/release.py publish
```

"""

import json
import re
from argparse import ArgumentParser
from pathlib import Path
from subprocess import run
from textwrap import dedent


def run_cli(cmd, *args, **kwargs):
    cmd_joined = " ".join(cmd)
    print(f"> {cmd_joined}")
    return run(cmd, *args, **kwargs, check=True)


def check_unreleased_has_items(changelog_content: str):
    """Check that there are items in the Unreleased section."""

    items_in_unreleased = []
    lines = changelog_content.splitlines()
    idx = 0
    while idx < len(lines):
        if lines[idx] != "## Unreleased":
            idx += 1
            continue
        # Find lines under unreleased
        idx += 1
        while idx < len(lines):
            if lines[idx].startswith("##"):
                break
            if lines[idx] and lines[idx].startswith("-"):
                items_in_unreleased.append(lines[idx])
            idx += 1

    for item in items_in_unreleased:
        if "No unreleased changes" in item:
            raise RuntimeError("Please update 'No unreleated changes' with changelog items.")

    if not items_in_unreleased:
        raise RuntimeError("Please add changelog items under the 'Unreleased' header.")


def check_git_clean():
    """Check that git status is clean."""
    git_status = run_cli(["git", "status", "--porcelain"], text=True, capture_output=True)
    if git_status.stdout != "":
        raise RuntimeError(f"git status is not clean:\n{git_status.stdout}")


def get_current_go_version_from_changelog(changelog_content: str):
    match = re.search(r"modal-go/v(?P<major>[\d]+)\.(?P<minor>[\d]+)\.(?P<patch>[\d]+)", changelog_content)
    if not match:
        raise RuntimeError("Unable to parse modal-go version")
    current_go_verison = {key: int(match.group(key)) for key in ["major", "minor", "patch"]}
    return current_go_verison


def update_version(args):
    """Updates version and changelog to prepare for release.."""
    if args.update not in ["major", "minor", "patch"]:
        raise RuntimeError("update parameter must be 'major', 'minor', or 'patch'")

    # Make sure changelog has new items in "Unreleased"
    changelog_path = Path("CHANGELOG.md")
    changelog_content = changelog_path.read_text()
    check_unreleased_has_items(changelog_content)

    check_git_clean()

    # Get updated go version
    go_version = get_current_go_version_from_changelog(changelog_content)
    go_version[args.update] += 1
    new_go_version = f"v{go_version['major']}.{go_version['minor']}.{go_version['patch']}"

    # Update and get new js version
    run_cli(["npm", "version", args.update], text=True, cwd="modal-js")
    package_path = Path("modal-js") / "package.json"
    with package_path.open("r") as f:
        json_package = json.load(f)
        new_js_version = json_package["version"]

    # Update changelog with versions
    version_header = f"modal-js/v{new_js_version}, modal-go/{new_go_version}"

    new_header = dedent(f"""\
    ## Unreleased

    No unreleased changes.

    ## {version_header}""")

    new_changelog_content = changelog_content.replace("## Unreleased", new_header)
    changelog_path.write_text(new_changelog_content)

    run_cli(["git", "diff"])
    run_cli(["git", "add", str(changelog_path)])
    run_cli(["git", "commit", "-m", f"[RELEASE] Prepare release for {version_header}"])


def publish(args):
    """Publish both modal-js and modal-go"""
    check_git_clean()
    run_cli(["npm", "publish"], cwd="modal-js")

    go_version = get_current_go_version_from_changelog(Path("CHANGELOG.md").read_text())
    go_version_str = f"v{go_version['major']}.{go_version['minor']}.{go_version['patch']}"

    run_cli(["git", "tag", f"modal-go/{go_version_str}"])
    run_cli(["git", "push", "--tags"])

    run_cli(["curl", f"https://proxy.golang.org/github.com/modal-labs/libmodal/modal-go/@v/{go_version_str}.info"])


def main():
    """Entrypoint for preparing and publishing release."""
    parser = ArgumentParser()
    subparsers = parser.add_subparsers(required=True)
    version_parser = subparsers.add_parser("version")
    version_parser.add_argument("update")
    version_parser.set_defaults(func=update_version)

    publish_parser = subparsers.add_parser("publish")
    publish_parser.set_defaults(func=publish)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()



================================================
FILE: modal-go/README.md
================================================
# Modal Go Library

[![Go Reference](https://pkg.go.dev/badge/github.com/modal-labs/libmodal/modal-go)](https://pkg.go.dev/github.com/modal-labs/libmodal/modal-go)
[![Build Status](https://github.com/modal-labs/libmodal/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/modal-labs/libmodal/actions?query=branch%3Amain)

The [Modal](https://modal.com/) Go SDK allows you to run Modal Functions and Sandboxes from Go applications.

## Documentation

See the [documentation and examples](https://github.com/modal-labs/libmodal?tab=readme-ov-file#go-modal-go) on GitHub.

## Requirements

Go 1.23 or higher.

## Installation

In a project using Go modules, just run:

```bash
go get -u github.com/modal-labs/libmodal/modal-go
```

Then, reference modal-go in a Go program with `import`:

```go
import (
	"github.com/modal-labs/libmodal/modal-go"
)
```



================================================
FILE: modal-go/app.go
================================================
package modal

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// App references a deployed Modal App.
type App struct {
	AppId string
	Name  string
	ctx   context.Context
}

// LookupOptions are options for finding deployed Modal objects.
type LookupOptions struct {
	Environment     string
	CreateIfMissing bool
}

// DeleteOptions are options for deleting a named object.
type DeleteOptions struct {
	Environment string // Environment to delete the object from.
}

// EphemeralOptions are options for creating a temporary, nameless object.
type EphemeralOptions struct {
	Environment string // Environment to create the object in.
}

// SandboxOptions are options for creating a Modal Sandbox.
type SandboxOptions struct {
	CPU               float64                      // CPU request in physical cores.
	Memory            int                          // Memory request in MiB.
	GPU               string                       // GPU reservation for the Sandbox (e.g. "A100", "T4:2", "A100-80GB:4").
	Timeout           time.Duration                // Maximum lifetime for the Sandbox.
	IdleTimeout       time.Duration                // The amount of time that a Sandbox can be idle before being terminated.
	Workdir           string                       // Working directory of the Sandbox.
	Command           []string                     // Command to run in the Sandbox on startup.
	Env               map[string]string            // Environment variables to set in the Sandbox.
	Secrets           []*Secret                    // Secrets to inject into the Sandbox as environment variables.
	Volumes           map[string]*Volume           // Mount points for Volumes.
	CloudBucketMounts map[string]*CloudBucketMount // Mount points for cloud buckets.
	PTY               bool                         // Enable a PTY for the Sandbox.
	EncryptedPorts    []int                        // List of encrypted ports to tunnel into the Sandbox, with TLS encryption.
	H2Ports           []int                        // List of encrypted ports to tunnel into the Sandbox, using HTTP/2.
	UnencryptedPorts  []int                        // List of ports to tunnel into the Sandbox without encryption.
	BlockNetwork      bool                         // Whether to block all network access from the Sandbox.
	CIDRAllowlist     []string                     // List of CIDRs the Sandbox is allowed to access. Cannot be used with BlockNetwork.
	Cloud             string                       // Cloud provider to run the Sandbox on.
	Regions           []string                     // Region(s) to run the Sandbox on.
	Verbose           bool                         // Enable verbose logging.
	Proxy             *Proxy                       // Reference to a Modal Proxy to use in front of this Sandbox.
	Name              string                       // Optional name for the Sandbox. Unique within an App.
}

// ImageFromRegistryOptions are options for creating an Image from a registry.
type ImageFromRegistryOptions struct {
	Secret *Secret // Secret for private registry authentication.
}

// parseGPUConfig parses a GPU configuration string into a GPUConfig object.
// The GPU string format is "type" or "type:count" (e.g. "T4", "A100:2").
// Returns nil if gpu is empty, or an error if the format is invalid.
func parseGPUConfig(gpu string) (*pb.GPUConfig, error) {
	if gpu == "" {
		return nil, nil
	}

	gpuType := gpu
	count := uint32(1)

	if strings.Contains(gpu, ":") {
		parts := strings.SplitN(gpu, ":", 2)
		gpuType = parts[0]
		parsedCount, err := strconv.ParseUint(parts[1], 10, 32)
		if err != nil || parsedCount < 1 {
			return nil, fmt.Errorf("invalid GPU count: %s, value must be a positive integer", parts[1])
		}
		count = uint32(parsedCount)
	}

	return pb.GPUConfig_builder{
		Type:    0, // Deprecated field, but required by proto
		Count:   count,
		GpuType: strings.ToUpper(gpuType),
	}.Build(), nil
}

// AppLookup looks up an existing App, or creates an empty one.
func AppLookup(ctx context.Context, name string, options *LookupOptions) (*App, error) {
	if options == nil {
		options = &LookupOptions{}
	}

	creationType := pb.ObjectCreationType_OBJECT_CREATION_TYPE_UNSPECIFIED
	if options.CreateIfMissing {
		creationType = pb.ObjectCreationType_OBJECT_CREATION_TYPE_CREATE_IF_MISSING
	}

	resp, err := client.AppGetOrCreate(ctx, pb.AppGetOrCreateRequest_builder{
		AppName:            name,
		EnvironmentName:    environmentName(options.Environment),
		ObjectCreationType: creationType,
	}.Build())

	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("App '%s' not found", name)}
	}
	if err != nil {
		return nil, err
	}

	return &App{AppId: resp.GetAppId(), Name: name, ctx: ctx}, nil
}

// buildSandboxCreateRequestProto builds a SandboxCreateRequest proto from options.
func buildSandboxCreateRequestProto(appId, imageId string, options SandboxOptions, envSecret *Secret) (*pb.SandboxCreateRequest, error) {
	gpuConfig, err := parseGPUConfig(options.GPU)
	if err != nil {
		return nil, err
	}

	if options.Workdir != "" && !strings.HasPrefix(options.Workdir, "/") {
		return nil, fmt.Errorf("the Workdir value must be an absolute path, got: %s", options.Workdir)
	}

	var volumeMounts []*pb.VolumeMount
	if options.Volumes != nil {
		volumeMounts = make([]*pb.VolumeMount, 0, len(options.Volumes))
		for mountPath, volume := range options.Volumes {
			volumeMounts = append(volumeMounts, pb.VolumeMount_builder{
				VolumeId:               volume.VolumeId,
				MountPath:              mountPath,
				AllowBackgroundCommits: true,
				ReadOnly:               volume.IsReadOnly(),
			}.Build())
		}
	}

	var cloudBucketMounts []*pb.CloudBucketMount
	if options.CloudBucketMounts != nil {
		cloudBucketMounts = make([]*pb.CloudBucketMount, 0, len(options.CloudBucketMounts))
		for mountPath, mount := range options.CloudBucketMounts {
			proto, err := mount.toProto(mountPath)
			if err != nil {
				return nil, err
			}
			cloudBucketMounts = append(cloudBucketMounts, proto)
		}
	}

	var ptyInfo *pb.PTYInfo
	if options.PTY {
		ptyInfo = defaultSandboxPTYInfo()
	}

	var openPorts []*pb.PortSpec
	for _, port := range options.EncryptedPorts {
		openPorts = append(openPorts, pb.PortSpec_builder{
			Port:        uint32(port),
			Unencrypted: false,
		}.Build())
	}
	for _, port := range options.H2Ports {
		openPorts = append(openPorts, pb.PortSpec_builder{
			Port:        uint32(port),
			Unencrypted: false,
			TunnelType:  pb.TunnelType_TUNNEL_TYPE_H2.Enum(),
		}.Build())
	}
	for _, port := range options.UnencryptedPorts {
		openPorts = append(openPorts, pb.PortSpec_builder{
			Port:        uint32(port),
			Unencrypted: true,
		}.Build())
	}

	var portSpecs *pb.PortSpecs
	if len(openPorts) > 0 {
		portSpecs = pb.PortSpecs_builder{
			Ports: openPorts,
		}.Build()
	}

	secretIds := []string{}
	for _, secret := range options.Secrets {
		if secret != nil {
			secretIds = append(secretIds, secret.SecretId)
		}
	}
	if (len(options.Env) > 0) != (envSecret != nil) {
		return nil, fmt.Errorf("internal error: Env and envSecret must both be provided or neither be provided")
	}
	if envSecret != nil {
		secretIds = append(secretIds, envSecret.SecretId)
	}

	var networkAccess *pb.NetworkAccess
	if options.BlockNetwork {
		if len(options.CIDRAllowlist) > 0 {
			return nil, fmt.Errorf("CIDRAllowlist cannot be used when BlockNetwork is enabled")
		}
		networkAccess = pb.NetworkAccess_builder{
			NetworkAccessType: pb.NetworkAccess_BLOCKED,
			AllowedCidrs:      []string{},
		}.Build()
	} else if len(options.CIDRAllowlist) > 0 {
		networkAccess = pb.NetworkAccess_builder{
			NetworkAccessType: pb.NetworkAccess_ALLOWLIST,
			AllowedCidrs:      options.CIDRAllowlist,
		}.Build()
	} else {
		networkAccess = pb.NetworkAccess_builder{
			NetworkAccessType: pb.NetworkAccess_OPEN,
			AllowedCidrs:      []string{},
		}.Build()
	}

	schedulerPlacement := pb.SchedulerPlacement_builder{Regions: options.Regions}.Build()

	var proxyId *string
	if options.Proxy != nil {
		proxyId = &options.Proxy.ProxyId
	}

	var workdir *string
	if options.Workdir != "" {
		workdir = &options.Workdir
	}

	var idleTimeoutSecs *uint32
	if options.IdleTimeout != 0 {
		v := uint32(options.IdleTimeout.Seconds())
		idleTimeoutSecs = &v
	}

	return pb.SandboxCreateRequest_builder{
		AppId: appId,
		Definition: pb.Sandbox_builder{
			EntrypointArgs:  options.Command,
			ImageId:         imageId,
			SecretIds:       secretIds,
			TimeoutSecs:     uint32(options.Timeout.Seconds()),
			IdleTimeoutSecs: idleTimeoutSecs,
			Workdir:         workdir,
			NetworkAccess:   networkAccess,
			Resources: pb.Resources_builder{
				MilliCpu:  uint32(1000 * options.CPU),
				MemoryMb:  uint32(options.Memory),
				GpuConfig: gpuConfig,
			}.Build(),
			VolumeMounts:       volumeMounts,
			CloudBucketMounts:  cloudBucketMounts,
			PtyInfo:            ptyInfo,
			OpenPorts:          portSpecs,
			CloudProviderStr:   options.Cloud,
			SchedulerPlacement: schedulerPlacement,
			Verbose:            options.Verbose,
			ProxyId:            proxyId,
			Name:               &options.Name,
		}.Build(),
	}.Build(), nil
}

// CreateSandbox creates a new Sandbox in the App with the specified Image and options.
func (app *App) CreateSandbox(image *Image, options *SandboxOptions) (*Sandbox, error) {
	if options == nil {
		options = &SandboxOptions{}
	}

	image, err := image.Build(app)
	if err != nil {
		return nil, err
	}

	var envSecret *Secret
	if len(options.Env) > 0 {
		envSecret, err = SecretFromMap(app.ctx, options.Env, nil)
		if err != nil {
			return nil, err
		}
	}

	req, err := buildSandboxCreateRequestProto(app.AppId, image.ImageId, *options, envSecret)
	if err != nil {
		return nil, err
	}

	createResp, err := client.SandboxCreate(app.ctx, req)
	if err != nil {
		if status, ok := status.FromError(err); ok && status.Code() == codes.AlreadyExists {
			return nil, AlreadyExistsError{Exception: status.Message()}
		}
		return nil, err
	}

	return newSandbox(app.ctx, createResp.GetSandboxId()), nil
}

// ImageFromRegistry creates an Image from a registry tag.
//
// Deprecated: ImageFromRegistry is deprecated, use modal.NewImageFromRegistry instead
func (app *App) ImageFromRegistry(tag string, options *ImageFromRegistryOptions) (*Image, error) {
	return NewImageFromRegistry(tag, options).Build(app)
}

// ImageFromAwsEcr creates an Image from an AWS ECR tag.
//
// Deprecated: ImageFromAwsEcr is deprecated, use modal.NewImageFromAwsEcr instead
func (app *App) ImageFromAwsEcr(tag string, secret *Secret) (*Image, error) {
	return NewImageFromAwsEcr(tag, secret).Build(app)
}

// ImageFromGcpArtifactRegistry creates an Image from a GCP Artifact Registry tag.
//
// Deprecated: ImageFromGcpArtifactRegistry is deprecated, use modal.NewImageFromGcpArtifactRegistry instead
func (app *App) ImageFromGcpArtifactRegistry(tag string, secret *Secret) (*Image, error) {
	return NewImageFromGcpArtifactRegistry(tag, secret).Build(app)
}



================================================
FILE: modal-go/app_test.go
================================================
package modal

import (
	"context"
	"testing"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/onsi/gomega"
)

func TestParseGPUConfig(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	// Test empty string returns nil
	config, err := parseGPUConfig("")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config).Should(gomega.BeNil())

	// Test single GPU type
	config, err = parseGPUConfig("T4")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(1)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("T4"))

	config, err = parseGPUConfig("A10G")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(1)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("A10G"))

	config, err = parseGPUConfig("A100-80GB")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(1)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("A100-80GB"))

	// Test GPU type with count
	config, err = parseGPUConfig("A100-80GB:3")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(3)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("A100-80GB"))

	config, err = parseGPUConfig("T4:2")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(2)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("T4"))

	// Test lowercase conversion
	config, err = parseGPUConfig("a100:4")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(config.GetCount()).To(gomega.Equal(uint32(4)))
	g.Expect(config.GetGpuType()).To(gomega.Equal("A100"))

	// Test invalid count formats
	_, err = parseGPUConfig("T4:invalid")
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("invalid GPU count: invalid"))

	_, err = parseGPUConfig("T4:")
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("invalid GPU count: "))

	_, err = parseGPUConfig("T4:0")
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("invalid GPU count: 0"))

	_, err = parseGPUConfig("T4:-1")
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("invalid GPU count: -1"))
}

func TestSandboxCreateRequestProto_WithoutPTY(t *testing.T) {
	g := gomega.NewWithT(t)

	req, err := buildSandboxCreateRequestProto("app-123", "img-456", SandboxOptions{}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	definition := req.GetDefinition()
	ptyInfo := definition.GetPtyInfo()
	g.Expect(ptyInfo).Should(gomega.BeNil())
}

func TestSandboxCreateRequestProto_WithPTY(t *testing.T) {
	g := gomega.NewWithT(t)

	req, err := buildSandboxCreateRequestProto("app-123", "img-456", SandboxOptions{
		PTY: true,
	}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	definition := req.GetDefinition()
	ptyInfo := definition.GetPtyInfo()
	g.Expect(ptyInfo.GetEnabled()).To(gomega.BeTrue())
	g.Expect(ptyInfo.GetWinszRows()).To(gomega.Equal(uint32(24)))
	g.Expect(ptyInfo.GetWinszCols()).To(gomega.Equal(uint32(80)))
	g.Expect(ptyInfo.GetEnvTerm()).To(gomega.Equal("xterm-256color"))
	g.Expect(ptyInfo.GetEnvColorterm()).To(gomega.Equal("truecolor"))
	g.Expect(ptyInfo.GetPtyType()).To(gomega.Equal(pb.PTYInfo_PTY_TYPE_SHELL))
}

func TestSandboxCreateRequestProto_MergesEnvAndSecrets(t *testing.T) {
	g := gomega.NewWithT(t)

	secretEnvVars := map[string]string{"A": "1"}
	secret, err := SecretFromMap(context.Background(), secretEnvVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	envVars := map[string]string{"B": "2"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = buildSandboxCreateRequestProto("ap", "im", SandboxOptions{
		Env: envVars,
	}, nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: Env and envSecret must both be provided or neither be provided"))

	_, err = buildSandboxCreateRequestProto("ap", "im", SandboxOptions{}, envSecret)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: Env and envSecret must both be provided or neither be provided"))

	req, err := buildSandboxCreateRequestProto("ap", "im", SandboxOptions{
		Env:     envVars,
		Secrets: []*Secret{secret},
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	definition := req.GetDefinition()
	g.Expect(definition.GetSecretIds()).To(gomega.HaveLen(2))
	g.Expect(definition.GetSecretIds()).To(gomega.ContainElement(secret.SecretId))
	g.Expect(definition.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
}

func TestSandboxCreateRequestProto_WithOnlyEnvParameter(t *testing.T) {
	g := gomega.NewWithT(t)

	envVars := map[string]string{"B": "2", "C": "3"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	req, err := buildSandboxCreateRequestProto("ap", "im", SandboxOptions{
		Env: envVars,
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	definition := req.GetDefinition()
	g.Expect(definition.GetSecretIds()).To(gomega.HaveLen(1))
	g.Expect(definition.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
}



================================================
FILE: modal-go/client.go
================================================
package modal

// Client construction, auth, timeout, and retry logic for Modal.

import (
	"context"
	"crypto/tls"
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// timeoutCallOption carries a per-RPC absolute timeout.
type timeoutCallOption struct {
	grpc.EmptyCallOption
	timeout time.Duration
}

// retryCallOption carries per-RPC retry overrides.
type retryCallOption struct {
	grpc.EmptyCallOption
	retries         *int
	baseDelay       *time.Duration
	maxDelay        *time.Duration
	delayFactor     *float64
	additionalCodes []codes.Code
}

const (
	apiEndpoint            = "api.modal.com:443"
	maxMessageSize         = 100 * 1024 * 1024 // 100 MB
	defaultRetryAttempts   = 3
	defaultRetryBaseDelay  = 100 * time.Millisecond
	defaultRetryMaxDelay   = 1 * time.Second
	defaultRetryBackoffMul = 2.0
)

var retryableGrpcStatusCodes = map[codes.Code]struct{}{
	codes.DeadlineExceeded: {},
	codes.Unavailable:      {},
	codes.Canceled:         {},
	codes.Internal:         {},
	codes.Unknown:          {},
}

func isRetryableGrpc(err error) bool {
	if st, ok := status.FromError(err); ok {
		if _, ok := retryableGrpcStatusCodes[st.Code()]; ok {
			return true
		}
	}
	return false
}

// defaultConfig caches the parsed ~/.modal.toml contents (may be empty).
var defaultConfig config

// defaultProfile is resolved at package init from MODAL_PROFILE, ~/.modal.toml, etc.
var defaultProfile Profile

// clientProfile is the actual profile, from defaultProfile + InitializeClient().
var clientProfile Profile

// client is the default Modal client that talks to the control plane.
var client pb.ModalClientClient

// inputPlaneClients is a map of server URL to input-plane client.
var inputPlaneClients = map[string]pb.ModalClientClient{}

// authToken is the auth token received from the control plane on the first request, and sent with all
// subsequent requests to both the control plane and the input plane.
var authToken string

func init() {
	defaultConfig, _ = readConfigFile()
	defaultProfile = getProfile(os.Getenv("MODAL_PROFILE"))
	clientProfile = defaultProfile
	var err error
	_, client, err = clientFactory(clientProfile)
	if err != nil {
		panic(fmt.Sprintf("failed to initialize Modal client at startup: %v", err))
	}
}

// ClientOptions defines credentials and options for initializing the Modal client at runtime.
type ClientOptions struct {
	TokenId     string
	TokenSecret string
	Environment string // optional, defaults to the profile's environment
}

// InitializeClient updates the global Modal client configuration with the provided options.
//
// This function is useful when you want to set the client options programmatically. It
// should be called once at the start of your application.
func InitializeClient(options ClientOptions) error {
	mergedProfile := defaultProfile
	mergedProfile.TokenId = options.TokenId
	mergedProfile.TokenSecret = options.TokenSecret
	mergedProfile.Environment = firstNonEmpty(options.Environment, mergedProfile.Environment)
	clientProfile = mergedProfile
	var err error
	_, client, err = clientFactory(mergedProfile)
	return err
}

// getOrCreateInputPlaneClient returns a client for the given server URL, creating it if it doesn't exist.
func getOrCreateInputPlaneClient(serverURL string) (pb.ModalClientClient, error) {
	if client, ok := inputPlaneClients[serverURL]; ok {
		return client, nil
	}

	profile := clientProfile
	profile.ServerURL = serverURL
	_, client, err := clientFactory(profile)
	if err != nil {
		return nil, err
	}
	inputPlaneClients[serverURL] = client
	return client, nil
}

// clientFactory is the factory used to construct gRPC connections and stubs.
// Tests may override this variable to install a mock.
var clientFactory func(Profile) (grpc.ClientConnInterface, pb.ModalClientClient, error) = func(profile Profile) (grpc.ClientConnInterface, pb.ModalClientClient, error) {
	return newClient(profile)
}

// newClient dials the given server URL with auth/timeout/retry interceptors installed.
// It returns (conn, stub). Close the conn when done.
func newClient(profile Profile) (*grpc.ClientConn, pb.ModalClientClient, error) {
	var target string
	var creds credentials.TransportCredentials
	if after, ok := strings.CutPrefix(profile.ServerURL, "https://"); ok {
		target = after
		creds = credentials.NewTLS(&tls.Config{})
	} else if after, ok := strings.CutPrefix(profile.ServerURL, "http://"); ok {
		target = after
		creds = insecure.NewCredentials()
	} else {
		return nil, nil, status.Errorf(codes.InvalidArgument, "invalid server URL: %s", profile.ServerURL)
	}

	conn, err := grpc.NewClient(
		target,
		grpc.WithTransportCredentials(creds),
		grpc.WithDefaultCallOptions(
			grpc.MaxCallRecvMsgSize(maxMessageSize),
			grpc.MaxCallSendMsgSize(maxMessageSize),
		),
		grpc.WithChainUnaryInterceptor(
			headerInjectorUnaryInterceptor(),
			authTokenInterceptor(),
			retryInterceptor(),
			timeoutInterceptor(),
		),
		grpc.WithChainStreamInterceptor(
			headerInjectorStreamInterceptor(),
		),
	)
	if err != nil {
		return nil, nil, err
	}
	return conn, pb.NewModalClientClient(conn), nil
}

// injectRequiredHeaders adds required headers to the context.
func injectRequiredHeaders(ctx context.Context) (context.Context, error) {
	if clientProfile.TokenId == "" || clientProfile.TokenSecret == "" {
		return nil, fmt.Errorf("missing token_id or token_secret, please set in .modal.toml, environment variables, or via InitializeClient()")
	}

	clientType := strconv.Itoa(int(pb.ClientType_CLIENT_TYPE_LIBMODAL_GO))
	return metadata.AppendToOutgoingContext(
		ctx,
		"x-modal-client-type", clientType,
		"x-modal-client-version", "1.0.0", // CLIENT VERSION: Behaves like this Python SDK version
		"x-modal-token-id", clientProfile.TokenId,
		"x-modal-token-secret", clientProfile.TokenSecret,
	), nil
}

// headerInjectorUnaryInterceptor adds required headers to outgoing unary RPCs.
func headerInjectorUnaryInterceptor() grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		invoker grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		var err error
		ctx, err = injectRequiredHeaders(ctx)
		if err != nil {
			return err
		}
		return invoker(ctx, method, req, reply, cc, opts...)
	}
}

// headerInjectorStreamInterceptor adds required headers to outgoing streaming RPCs.
func headerInjectorStreamInterceptor() grpc.StreamClientInterceptor {
	return func(
		ctx context.Context,
		desc *grpc.StreamDesc,
		cc *grpc.ClientConn,
		method string,
		streamer grpc.Streamer,
		opts ...grpc.CallOption,
	) (grpc.ClientStream, error) {
		var err error
		ctx, err = injectRequiredHeaders(ctx)
		if err != nil {
			return nil, err
		}
		return streamer(ctx, desc, cc, method, opts...)
	}
}

// authTokenInterceptor handles sending and receiving the "x-modal-auth-token" header.
// We receive an auth token from the control plane on our first request. We then include that auth token in every
// subsequent request to both the control plane and the input plane.
func authTokenInterceptor() grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		inv grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		var headers, trailers metadata.MD
		// Add authToken to outgoing context if it's set
		if authToken != "" {
			ctx = metadata.AppendToOutgoingContext(ctx, "x-modal-auth-token", authToken)
		}
		opts = append(opts, grpc.Header(&headers), grpc.Trailer(&trailers))
		err := inv(ctx, method, req, reply, cc, opts...)
		// If we're talking to the control plane, and no auth token was sent, it will return one.
		// The python server returns it in the trailers, the worker returns it in the headers.
		if val, ok := headers["x-modal-auth-token"]; ok {
			authToken = val[0]
		} else if val, ok := trailers["x-modal-auth-token"]; ok {
			authToken = val[0]
		}

		return err
	}
}

func timeoutInterceptor() grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		inv grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		// pick the first TimeoutCallOption, if any
		for _, o := range opts {
			if to, ok := o.(timeoutCallOption); ok && to.timeout > 0 {
				// honour an existing, *earlier* deadline if present
				if deadline, ok := ctx.Deadline(); ok && time.Until(deadline) <= to.timeout {
					break
				}
				var cancel context.CancelFunc
				ctx, cancel = context.WithTimeout(ctx, to.timeout)
				defer cancel()
				break
			}
		}
		return inv(ctx, method, req, reply, cc, opts...)
	}
}

func retryInterceptor() grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		inv grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		// start with package defaults
		retries := defaultRetryAttempts
		baseDelay := defaultRetryBaseDelay
		maxDelay := defaultRetryMaxDelay
		factor := defaultRetryBackoffMul
		retryable := retryableGrpcStatusCodes

		// override from call-options (first one wins)
		for _, o := range opts {
			if rc, ok := o.(retryCallOption); ok {
				if rc.retries != nil {
					retries = *rc.retries
				}
				if rc.baseDelay != nil {
					baseDelay = *rc.baseDelay
				}
				if rc.maxDelay != nil {
					maxDelay = *rc.maxDelay
				}
				if rc.delayFactor != nil {
					factor = *rc.delayFactor
				}
				if len(rc.additionalCodes) > 0 {
					retryable = map[codes.Code]struct{}{}
					for k := range retryableGrpcStatusCodes {
						retryable[k] = struct{}{}
					}
					for _, c := range rc.additionalCodes {
						retryable[c] = struct{}{}
					}
				}
				break
			}
		}

		idempotency := uuid.NewString()
		start := time.Now()
		delay := baseDelay

		for attempt := 0; attempt <= retries; attempt++ {
			aCtx := metadata.AppendToOutgoingContext(
				ctx,
				"x-idempotency-key", idempotency,
				"x-retry-attempt", strconv.Itoa(attempt),
				"x-retry-delay", strconv.FormatFloat(time.Since(start).Seconds(), 'f', 3, 64),
			)

			err := inv(aCtx, method, req, reply, cc, opts...)
			if err == nil {
				return nil
			}

			if st, ok := status.FromError(err); ok { // gRPC error
				if _, ok := retryable[st.Code()]; !ok || attempt == retries {
					return err
				}
			} else { // Unexpected, non-gRPC error
				return err
			}

			if sleepCtx(ctx, delay) != nil {
				return err // ctx cancelled or deadline exceeded
			}

			// exponential back-off
			delay = min(delay*time.Duration(factor), maxDelay)
		}
		return nil // unreachable
	}
}

func sleepCtx(ctx context.Context, d time.Duration) error {
	t := time.NewTimer(d)
	defer t.Stop()
	select {
	case <-t.C:
		return nil
	case <-ctx.Done():
		return ctx.Err()
	}
}



================================================
FILE: modal-go/client_testhooks.go
================================================
package modal

import (
	"sync"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc"
)

// SetClientFactoryForTesting overrides the gRPC client factory for tests.
// It resets global client state and returns a restore function to undo changes.
func SetClientFactoryForTesting(testClientFactory func(Profile) (grpc.ClientConnInterface, pb.ModalClientClient, error)) (restore func()) {
	origClientFactory := clientFactory
	clientFactory = testClientFactory

	// Recreate client using the overridden clientFactory, and reset the rest
	_, client, _ = clientFactory(clientProfile)
	inputPlaneClients = make(map[string]pb.ModalClientClient)
	authToken = ""

	var once sync.Once
	return func() {
		once.Do(func() {
			clientFactory = origClientFactory
			_, client, _ = clientFactory(clientProfile)
			inputPlaneClients = map[string]pb.ModalClientClient{}
			authToken = ""
		})
	}
}



================================================
FILE: modal-go/cloud_bucket_mount.go
================================================
package modal

import (
	"fmt"
	"net/url"
	"strings"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// CloudBucketMount provides access to cloud storage buckets within Modal Functions.
type CloudBucketMount struct {
	BucketName        string
	Secret            *Secret
	ReadOnly          bool
	RequesterPays     bool
	BucketEndpointUrl *string
	KeyPrefix         *string
	OidcAuthRoleArn   *string
}

// CloudBucketMountOptions are options for creating a CloudBucketMount.
type CloudBucketMountOptions struct {
	Secret            *Secret
	ReadOnly          bool
	RequesterPays     bool
	BucketEndpointUrl *string
	KeyPrefix         *string
	OidcAuthRoleArn   *string
}

// NewCloudBucketMount creates a new CloudBucketMount.
func NewCloudBucketMount(bucketName string, options *CloudBucketMountOptions) (*CloudBucketMount, error) {
	if options == nil {
		options = &CloudBucketMountOptions{}
	}

	mount := &CloudBucketMount{
		BucketName:        bucketName,
		Secret:            options.Secret,
		ReadOnly:          options.ReadOnly,
		RequesterPays:     options.RequesterPays,
		BucketEndpointUrl: options.BucketEndpointUrl,
		KeyPrefix:         options.KeyPrefix,
		OidcAuthRoleArn:   options.OidcAuthRoleArn,
	}

	if mount.BucketEndpointUrl != nil {
		_, err := url.Parse(*mount.BucketEndpointUrl)
		if err != nil {
			return nil, fmt.Errorf("invalid bucket endpoint URL: %w", err)
		}
	}

	if mount.RequesterPays && mount.Secret == nil {
		return nil, fmt.Errorf("credentials required in order to use Requester Pays")
	}

	if mount.KeyPrefix != nil && !strings.HasSuffix(*mount.KeyPrefix, "/") {
		return nil, fmt.Errorf("keyPrefix will be prefixed to all object paths, so it must end in a '/'")
	}

	return mount, nil
}

func getBucketTypeFromEndpointURL(bucketEndpointURL *string) (pb.CloudBucketMount_BucketType, error) {
	if bucketEndpointURL == nil {
		return pb.CloudBucketMount_S3, nil
	}

	parsedURL, err := url.Parse(*bucketEndpointURL)
	if err != nil {
		return pb.CloudBucketMount_S3, fmt.Errorf("failed to parse bucketEndpointURL '%s': %w", *bucketEndpointURL, err)
	}

	hostname := parsedURL.Hostname()
	if strings.HasSuffix(hostname, "r2.cloudflarestorage.com") {
		return pb.CloudBucketMount_R2, nil
	} else if strings.HasSuffix(hostname, "storage.googleapis.com") {
		return pb.CloudBucketMount_GCP, nil
	}
	return pb.CloudBucketMount_S3, nil
}

func (c *CloudBucketMount) toProto(mountPath string) (*pb.CloudBucketMount, error) {
	credentialsSecretId := ""
	if c.Secret != nil {
		credentialsSecretId = c.Secret.SecretId
	}

	bucketType, err := getBucketTypeFromEndpointURL(c.BucketEndpointUrl)
	if err != nil {
		return nil, err
	}

	return pb.CloudBucketMount_builder{
		BucketName:          c.BucketName,
		MountPath:           mountPath,
		CredentialsSecretId: credentialsSecretId,
		ReadOnly:            c.ReadOnly,
		BucketType:          bucketType,
		RequesterPays:       c.RequesterPays,
		BucketEndpointUrl:   c.BucketEndpointUrl,
		KeyPrefix:           c.KeyPrefix,
		OidcAuthRoleArn:     c.OidcAuthRoleArn,
	}.Build(), nil
}



================================================
FILE: modal-go/cloud_bucket_mount_test.go
================================================
package modal

import (
	"testing"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/onsi/gomega"
)

func TestNewCloudBucketMount_MinimalOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	mount, err := NewCloudBucketMount("my-bucket", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(mount.BucketName).Should(gomega.Equal("my-bucket"))
	g.Expect(mount.ReadOnly).Should(gomega.BeFalse())
	g.Expect(mount.RequesterPays).Should(gomega.BeFalse())
	g.Expect(mount.Secret).Should(gomega.BeNil())
	g.Expect(mount.BucketEndpointUrl).Should(gomega.BeNil())
	g.Expect(mount.KeyPrefix).Should(gomega.BeNil())
	g.Expect(mount.OidcAuthRoleArn).Should(gomega.BeNil())

	bucketType, err := getBucketTypeFromEndpointURL(mount.BucketEndpointUrl)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(bucketType).Should(gomega.Equal(pb.CloudBucketMount_S3))
}

func TestNewCloudBucketMount_AllOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	mockSecret := &Secret{SecretId: "sec-123"}
	endpointURL := "https://my-bucket.r2.cloudflarestorage.com"
	keyPrefix := "prefix/"
	oidcRole := "arn:aws:iam::123456789:role/MyRole"

	mount, err := NewCloudBucketMount("my-bucket", &CloudBucketMountOptions{
		Secret:            mockSecret,
		ReadOnly:          true,
		RequesterPays:     true,
		BucketEndpointUrl: &endpointURL,
		KeyPrefix:         &keyPrefix,
		OidcAuthRoleArn:   &oidcRole,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(mount.BucketName).Should(gomega.Equal("my-bucket"))
	g.Expect(mount.ReadOnly).Should(gomega.BeTrue())
	g.Expect(mount.RequesterPays).Should(gomega.BeTrue())
	g.Expect(mount.Secret).Should(gomega.Equal(mockSecret))
	g.Expect(mount.BucketEndpointUrl).ShouldNot(gomega.BeNil())
	g.Expect(*mount.BucketEndpointUrl).Should(gomega.Equal(endpointURL))
	g.Expect(mount.KeyPrefix).ShouldNot(gomega.BeNil())
	g.Expect(*mount.KeyPrefix).Should(gomega.Equal(keyPrefix))
	g.Expect(mount.OidcAuthRoleArn).ShouldNot(gomega.BeNil())
	g.Expect(*mount.OidcAuthRoleArn).Should(gomega.Equal(oidcRole))

	bucketType, err := getBucketTypeFromEndpointURL(mount.BucketEndpointUrl)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(bucketType).Should(gomega.Equal(pb.CloudBucketMount_R2))
}

func TestGetBucketTypeFromEndpointURL(t *testing.T) {
	t.Parallel()
	test_cases := []struct {
		name         string
		endpointURL  string
		expectedType pb.CloudBucketMount_BucketType
	}{
		{
			name:         "Empty defaults to S3",
			endpointURL:  "",
			expectedType: pb.CloudBucketMount_S3,
		},
		{
			name:         "R2",
			endpointURL:  "https://my-bucket.r2.cloudflarestorage.com",
			expectedType: pb.CloudBucketMount_R2,
		},
		{
			name:         "GCP",
			endpointURL:  "https://storage.googleapis.com/my-bucket",
			expectedType: pb.CloudBucketMount_GCP,
		},
		{
			name:         "Unknown defaults to S3",
			endpointURL:  "https://unknown-endpoint.com/my-bucket",
			expectedType: pb.CloudBucketMount_S3,
		},
	}

	for _, tc := range test_cases {
		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()
			g := gomega.NewWithT(t)

			options := &CloudBucketMountOptions{}
			if tc.endpointURL != "" {
				options.BucketEndpointUrl = &tc.endpointURL
			}

			mount, err := NewCloudBucketMount("my-bucket", options)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())

			bucketType, err := getBucketTypeFromEndpointURL(mount.BucketEndpointUrl)
			g.Expect(err).ShouldNot(gomega.HaveOccurred())
			g.Expect(bucketType).Should(gomega.Equal(tc.expectedType))
		})
	}
}

func TestGetBucketTypeFromEndpointURL_InvalidURL(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	invalidURL := "://invalid-url"
	_, err := getBucketTypeFromEndpointURL(&invalidURL)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("failed to parse bucketEndpointURL"))
	g.Expect(err.Error()).Should(gomega.ContainSubstring(invalidURL))
}

func TestNewCloudBucketMount_ValidationRequesterPaysWithoutSecret(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	_, err := NewCloudBucketMount("my-bucket", &CloudBucketMountOptions{
		RequesterPays: true,
	})

	g.Expect(err).Should(gomega.MatchError("credentials required in order to use Requester Pays"))
}

func TestNewCloudBucketMount_ValidationKeyPrefixWithoutTrailingSlash(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	keyPrefix := "prefix"
	_, err := NewCloudBucketMount("my-bucket", &CloudBucketMountOptions{
		KeyPrefix: &keyPrefix,
	})

	g.Expect(err).Should(gomega.MatchError("keyPrefix will be prefixed to all object paths, so it must end in a '/'"))
}

func TestCloudBucketMount_ToProtoMinimalOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	mount, err := NewCloudBucketMount("my-bucket", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	proto, err := mount.toProto("/mnt/bucket")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(proto.GetBucketName()).Should(gomega.Equal("my-bucket"))
	g.Expect(proto.GetMountPath()).Should(gomega.Equal("/mnt/bucket"))
	g.Expect(proto.GetCredentialsSecretId()).Should(gomega.BeEmpty())
	g.Expect(proto.GetReadOnly()).Should(gomega.BeFalse())
	g.Expect(proto.GetBucketType()).Should(gomega.Equal(pb.CloudBucketMount_S3))
	g.Expect(proto.GetRequesterPays()).Should(gomega.BeFalse())
	g.Expect(proto.GetBucketEndpointUrl()).Should(gomega.BeEmpty())
	g.Expect(proto.GetKeyPrefix()).Should(gomega.BeEmpty())
	g.Expect(proto.GetOidcAuthRoleArn()).Should(gomega.BeEmpty())
}

func TestCloudBucketMount_ToProtoAllOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	mockSecret := &Secret{SecretId: "sec-123"}
	endpointURL := "https://my-bucket.r2.cloudflarestorage.com"
	keyPrefix := "prefix/"
	oidcRole := "arn:aws:iam::123456789:role/MyRole"

	mount, err := NewCloudBucketMount("my-bucket", &CloudBucketMountOptions{
		Secret:            mockSecret,
		ReadOnly:          true,
		RequesterPays:     true,
		BucketEndpointUrl: &endpointURL,
		KeyPrefix:         &keyPrefix,
		OidcAuthRoleArn:   &oidcRole,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	proto, err := mount.toProto("/mnt/bucket")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(proto.GetBucketName()).Should(gomega.Equal("my-bucket"))
	g.Expect(proto.GetMountPath()).Should(gomega.Equal("/mnt/bucket"))
	g.Expect(proto.GetCredentialsSecretId()).Should(gomega.Equal("sec-123"))
	g.Expect(proto.GetReadOnly()).Should(gomega.BeTrue())
	g.Expect(proto.GetBucketType()).Should(gomega.Equal(pb.CloudBucketMount_R2))
	g.Expect(proto.GetRequesterPays()).Should(gomega.BeTrue())
	g.Expect(proto.GetBucketEndpointUrl()).Should(gomega.Equal(endpointURL))
	g.Expect(proto.GetKeyPrefix()).Should(gomega.Equal(keyPrefix))
	g.Expect(proto.GetOidcAuthRoleArn()).Should(gomega.Equal(oidcRole))
}



================================================
FILE: modal-go/cls.go
================================================
package modal

// Cls lookups and Function binding.

import (
	"context"
	"fmt"
	"sort"
	"time"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
)

// ClsOptions represents runtime options for a Modal Cls.
type ClsOptions struct {
	CPU              *float64
	Memory           *int
	GPU              *string
	Env              map[string]string
	Secrets          []*Secret
	Volumes          map[string]*Volume
	Retries          *Retries
	MaxContainers    *int
	BufferContainers *int
	ScaledownWindow  *time.Duration
	Timeout          *time.Duration
}

// ClsConcurrencyOptions represents concurrency configuration for a Modal Cls.
type ClsConcurrencyOptions struct {
	MaxInputs    int
	TargetInputs *int
}

// ClsBatchingOptions represents batching configuration for a Modal Cls.
type ClsBatchingOptions struct {
	MaxBatchSize int
	Wait         time.Duration
}

type serviceOptions struct {
	cpu                    *float64
	memory                 *int
	gpu                    *string
	env                    *map[string]string
	secrets                *[]*Secret
	volumes                *map[string]*Volume
	retries                *Retries
	maxContainers          *int
	bufferContainers       *int
	scaledownWindow        *time.Duration
	timeout                *time.Duration
	maxConcurrentInputs    *int
	targetConcurrentInputs *int
	batchMaxSize           *int
	batchWait              *time.Duration
}

// Cls represents a Modal class definition that can be instantiated with parameters.
// It contains metadata about the class and its methods.
type Cls struct {
	ctx               context.Context
	serviceFunctionId string
	schema            []*pb.ClassParameterSpec
	methodNames       []string
	inputPlaneUrl     string // if empty, use control plane
	options           *serviceOptions
}

// ClsLookup looks up an existing Cls on a deployed App.
func ClsLookup(ctx context.Context, appName string, name string, options *LookupOptions) (*Cls, error) {
	if options == nil {
		options = &LookupOptions{}
	}

	cls := Cls{
		methodNames: []string{},
		ctx:         ctx,
	}

	// Find class service function metadata. Service functions are used to implement class methods,
	// which are invoked using a combination of service function ID and the method name.
	serviceFunctionName := fmt.Sprintf("%s.*", name)
	serviceFunction, err := client.FunctionGet(ctx, pb.FunctionGetRequest_builder{
		AppName:         appName,
		ObjectTag:       serviceFunctionName,
		EnvironmentName: environmentName(options.Environment),
	}.Build())

	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("class '%s/%s' not found", appName, name)}
	}
	if err != nil {
		return nil, fmt.Errorf("failed to look up class service function: %w", err)
	}

	// Validate that we only support parameter serialization format PROTO.
	parameterInfo := serviceFunction.GetHandleMetadata().GetClassParameterInfo()
	schema := parameterInfo.GetSchema()
	if len(schema) > 0 && parameterInfo.GetFormat() != pb.ClassParameterInfo_PARAM_SERIALIZATION_FORMAT_PROTO {
		return nil, fmt.Errorf("unsupported parameter format: %v", parameterInfo.GetFormat())
	} else {
		cls.schema = schema
	}

	cls.serviceFunctionId = serviceFunction.GetFunctionId()

	// Check if we have method metadata on the class service function (v0.67+)
	if serviceFunction.GetHandleMetadata().GetMethodHandleMetadata() != nil {
		for methodName := range serviceFunction.GetHandleMetadata().GetMethodHandleMetadata() {
			cls.methodNames = append(cls.methodNames, methodName)
		}
	} else {
		// Legacy approach not supported
		return nil, fmt.Errorf("Cls requires Modal deployments using client v0.67 or later")
	}

	if inputPlaneUrl := serviceFunction.GetHandleMetadata().GetInputPlaneUrl(); inputPlaneUrl != "" {
		cls.inputPlaneUrl = inputPlaneUrl
	}

	return &cls, nil
}

// Instance creates a new instance of the class with the provided parameters.
func (c *Cls) Instance(params map[string]any) (*ClsInstance, error) {
	var functionId string
	if len(c.schema) == 0 && !hasOptions(c.options) {
		functionId = c.serviceFunctionId
	} else {
		boundFunctionId, err := c.bindParameters(params)
		if err != nil {
			return nil, err
		}
		functionId = boundFunctionId
	}

	methods := make(map[string]*Function)
	for _, name := range c.methodNames {
		methods[name] = &Function{
			FunctionId:    functionId,
			MethodName:    &name,
			inputPlaneUrl: c.inputPlaneUrl,
			ctx:           c.ctx,
		}
	}
	return &ClsInstance{methods: methods}, nil
}

// WithOptions overrides the static Function configuration at runtime.
func (c *Cls) WithOptions(opts ClsOptions) *Cls {
	var secretsPtr *[]*Secret
	if opts.Secrets != nil {
		s := opts.Secrets
		secretsPtr = &s
	}
	var volumesPtr *map[string]*Volume
	if opts.Volumes != nil {
		v := opts.Volumes
		volumesPtr = &v
	}
	var envPtr *map[string]string
	if opts.Env != nil {
		e := opts.Env
		envPtr = &e
	}

	merged := mergeServiceOptions(c.options, &serviceOptions{
		cpu:              opts.CPU,
		memory:           opts.Memory,
		gpu:              opts.GPU,
		env:              envPtr,
		secrets:          secretsPtr,
		volumes:          volumesPtr,
		retries:          opts.Retries,
		maxContainers:    opts.MaxContainers,
		bufferContainers: opts.BufferContainers,
		scaledownWindow:  opts.ScaledownWindow,
		timeout:          opts.Timeout,
	})

	return &Cls{
		ctx:               c.ctx,
		serviceFunctionId: c.serviceFunctionId,
		schema:            c.schema,
		methodNames:       c.methodNames,
		inputPlaneUrl:     c.inputPlaneUrl,
		options:           merged,
	}
}

// WithConcurrency creates an instance of the Cls with input concurrency enabled or overridden with new values.
func (c *Cls) WithConcurrency(opts ClsConcurrencyOptions) *Cls {
	merged := mergeServiceOptions(c.options, &serviceOptions{
		maxConcurrentInputs:    &opts.MaxInputs,
		targetConcurrentInputs: opts.TargetInputs,
	})

	return &Cls{
		ctx:               c.ctx,
		serviceFunctionId: c.serviceFunctionId,
		schema:            c.schema,
		methodNames:       c.methodNames,
		inputPlaneUrl:     c.inputPlaneUrl,
		options:           merged,
	}
}

// WithBatching creates an instance of the Cls with dynamic batching enabled or overridden with new values.
func (c *Cls) WithBatching(opts ClsBatchingOptions) *Cls {
	merged := mergeServiceOptions(c.options, &serviceOptions{
		batchMaxSize: &opts.MaxBatchSize,
		batchWait:    &opts.Wait,
	})

	return &Cls{
		ctx:               c.ctx,
		serviceFunctionId: c.serviceFunctionId,
		schema:            c.schema,
		methodNames:       c.methodNames,
		inputPlaneUrl:     c.inputPlaneUrl,
		options:           merged,
	}
}

// bindParameters processes the parameters and binds them to the class function.
func (c *Cls) bindParameters(params map[string]any) (string, error) {
	serializedParams, err := encodeParameterSet(c.schema, params)
	if err != nil {
		return "", fmt.Errorf("failed to serialize parameters: %w", err)
	}

	var envSecret *Secret
	if c.options != nil && c.options.env != nil && len(*c.options.env) > 0 {
		envSecret, err = SecretFromMap(c.ctx, *c.options.env, nil)
		if err != nil {
			return "", err
		}
	}

	functionOptions, err := buildFunctionOptionsProto(c.options, envSecret)
	if err != nil {
		return "", fmt.Errorf("failed to build function options: %w", err)
	}

	// Bind parameters to create a parameterized function
	bindResp, err := client.FunctionBindParams(c.ctx, pb.FunctionBindParamsRequest_builder{
		FunctionId:       c.serviceFunctionId,
		SerializedParams: serializedParams,
		FunctionOptions:  functionOptions,
	}.Build())
	if err != nil {
		return "", fmt.Errorf("failed to bind parameters: %w", err)
	}

	return bindResp.GetBoundFunctionId(), nil
}

// encodeParameterSet encodes the parameter values into a binary format.
func encodeParameterSet(schema []*pb.ClassParameterSpec, params map[string]any) ([]byte, error) {
	var encoded []*pb.ClassParameterValue

	for _, paramSpec := range schema {
		paramValue, err := encodeParameter(paramSpec, params[paramSpec.GetName()])
		if err != nil {
			return nil, err
		}
		encoded = append(encoded, paramValue)
	}

	// Sort keys, identical to Python `SerializeToString(deterministic=True)`.
	sort.Slice(encoded, func(i, j int) bool {
		return encoded[i].GetName() < encoded[j].GetName()
	})
	return proto.Marshal(pb.ClassParameterSet_builder{Parameters: encoded}.Build())
}

// encodeParameter converts a Go value to a ParameterValue proto message
func encodeParameter(paramSpec *pb.ClassParameterSpec, value any) (*pb.ClassParameterValue, error) {
	name := paramSpec.GetName()
	paramType := paramSpec.GetType()
	paramValue := pb.ClassParameterValue_builder{
		Name: name,
		Type: paramType,
	}.Build()

	switch paramType {
	case pb.ParameterType_PARAM_TYPE_STRING:
		if value == nil && paramSpec.GetHasDefault() {
			value = paramSpec.GetStringDefault()
		}
		strValue, ok := value.(string)
		if !ok {
			return nil, fmt.Errorf("parameter '%s' must be a string", name)
		}
		paramValue.SetStringValue(strValue)

	case pb.ParameterType_PARAM_TYPE_INT:
		if value == nil && paramSpec.GetHasDefault() {
			value = paramSpec.GetIntDefault()
		}
		var intValue int64
		switch v := value.(type) {
		case int:
			intValue = int64(v)
		case int64:
			intValue = v
		case int32:
			intValue = int64(v)
		default:
			return nil, fmt.Errorf("parameter '%s' must be an integer", name)
		}
		paramValue.SetIntValue(intValue)

	case pb.ParameterType_PARAM_TYPE_BOOL:
		if value == nil && paramSpec.GetHasDefault() {
			value = paramSpec.GetBoolDefault()
		}
		boolValue, ok := value.(bool)
		if !ok {
			return nil, fmt.Errorf("parameter '%s' must be a boolean", name)
		}
		paramValue.SetBoolValue(boolValue)

	case pb.ParameterType_PARAM_TYPE_BYTES:
		if value == nil && paramSpec.GetHasDefault() {
			value = paramSpec.GetBytesDefault()
		}
		bytesValue, ok := value.([]byte)
		if !ok {
			return nil, fmt.Errorf("parameter '%s' must be a byte slice", name)
		}
		paramValue.SetBytesValue(bytesValue)

	default:
		return nil, fmt.Errorf("unsupported parameter type: %v", paramType)
	}

	return paramValue, nil
}

// ClsInstance represents an instantiated Modal class with bound parameters.
// It provides access to the class methods with the bound parameters.
type ClsInstance struct {
	methods map[string]*Function
}

// Method returns the Function with the given name from a ClsInstance.
func (c *ClsInstance) Method(name string) (*Function, error) {
	method, ok := c.methods[name]
	if !ok {
		return nil, NotFoundError{fmt.Sprintf("method '%s' not found on class", name)}
	}
	return method, nil
}

func hasOptions(o *serviceOptions) bool {
	return o != nil && *o != (serviceOptions{})
}

func mergeServiceOptions(base, new *serviceOptions) *serviceOptions {
	if base == nil {
		return new
	}
	if new == nil {
		return base
	}

	merged := &serviceOptions{
		cpu:                    base.cpu,
		memory:                 base.memory,
		gpu:                    base.gpu,
		env:                    base.env,
		secrets:                base.secrets,
		volumes:                base.volumes,
		retries:                base.retries,
		maxContainers:          base.maxContainers,
		bufferContainers:       base.bufferContainers,
		scaledownWindow:        base.scaledownWindow,
		timeout:                base.timeout,
		maxConcurrentInputs:    base.maxConcurrentInputs,
		targetConcurrentInputs: base.targetConcurrentInputs,
		batchMaxSize:           base.batchMaxSize,
		batchWait:              base.batchWait,
	}

	if new.cpu != nil {
		merged.cpu = new.cpu
	}
	if new.memory != nil {
		merged.memory = new.memory
	}
	if new.gpu != nil {
		merged.gpu = new.gpu
	}
	if new.env != nil {
		merged.env = new.env
	}
	if new.secrets != nil {
		merged.secrets = new.secrets
	}
	if new.volumes != nil {
		merged.volumes = new.volumes
	}
	if new.retries != nil {
		merged.retries = new.retries
	}
	if new.maxContainers != nil {
		merged.maxContainers = new.maxContainers
	}
	if new.bufferContainers != nil {
		merged.bufferContainers = new.bufferContainers
	}
	if new.scaledownWindow != nil {
		merged.scaledownWindow = new.scaledownWindow
	}
	if new.timeout != nil {
		merged.timeout = new.timeout
	}
	if new.maxConcurrentInputs != nil {
		merged.maxConcurrentInputs = new.maxConcurrentInputs
	}
	if new.targetConcurrentInputs != nil {
		merged.targetConcurrentInputs = new.targetConcurrentInputs
	}
	if new.batchMaxSize != nil {
		merged.batchMaxSize = new.batchMaxSize
	}
	if new.batchWait != nil {
		merged.batchWait = new.batchWait
	}

	return merged
}

func buildFunctionOptionsProto(opts *serviceOptions, envSecret *Secret) (*pb.FunctionOptions, error) {
	if !hasOptions(opts) {
		return nil, nil
	}

	builder := pb.FunctionOptions_builder{}

	if opts.cpu != nil || opts.memory != nil || opts.gpu != nil {
		resBuilder := pb.Resources_builder{}
		if opts.cpu != nil {
			resBuilder.MilliCpu = uint32(*opts.cpu * 1000)
		}
		if opts.memory != nil {
			resBuilder.MemoryMb = uint32(*opts.memory)
		}
		if opts.gpu != nil {
			gpuConfig, err := parseGPUConfig(*opts.gpu)
			if err != nil {
				return nil, err
			}
			resBuilder.GpuConfig = gpuConfig
		}
		builder.Resources = resBuilder.Build()
	}

	secretIds := []string{}
	if opts.secrets != nil {
		for _, secret := range *opts.secrets {
			if secret != nil {
				secretIds = append(secretIds, secret.SecretId)
			}
		}
	}
	if (opts.env != nil && len(*opts.env) > 0) != (envSecret != nil) {
		return nil, fmt.Errorf("internal error: env and envSecret must both be provided or neither be provided")
	}
	if envSecret != nil {
		secretIds = append(secretIds, envSecret.SecretId)
	}

	builder.SecretIds = secretIds
	if len(secretIds) > 0 {
		builder.ReplaceSecretIds = true
	}

	if opts.volumes != nil {
		volumeMounts := []*pb.VolumeMount{}
		for mountPath, volume := range *opts.volumes {
			if volume != nil {
				volumeMounts = append(volumeMounts, pb.VolumeMount_builder{
					VolumeId:               volume.VolumeId,
					MountPath:              mountPath,
					AllowBackgroundCommits: true,
					ReadOnly:               volume.IsReadOnly(),
				}.Build())
			}
		}
		builder.VolumeMounts = volumeMounts
		if len(volumeMounts) > 0 {
			builder.ReplaceVolumeMounts = true
		}
	}

	if opts.retries != nil {
		builder.RetryPolicy = pb.FunctionRetryPolicy_builder{
			Retries:            uint32(opts.retries.MaxRetries),
			BackoffCoefficient: opts.retries.BackoffCoefficient,
			InitialDelayMs:     uint32(opts.retries.InitialDelay / time.Millisecond),
			MaxDelayMs:         uint32(opts.retries.MaxDelay / time.Millisecond),
		}.Build()
	}

	if opts.maxContainers != nil {
		v := uint32(*opts.maxContainers)
		builder.ConcurrencyLimit = &v
	}
	if opts.bufferContainers != nil {
		v := uint32(*opts.bufferContainers)
		builder.BufferContainers = &v
	}

	if opts.scaledownWindow != nil {
		if *opts.scaledownWindow < time.Second {
			return nil, fmt.Errorf("scaledownWindow must be at least 1 second, got %v", *opts.scaledownWindow)
		}
		if (*opts.scaledownWindow)%time.Second != 0 {
			return nil, fmt.Errorf("scaledownWindow must be a whole number of seconds, got %v", *opts.scaledownWindow)
		}
		v := uint32((*opts.scaledownWindow) / time.Second)
		builder.TaskIdleTimeoutSecs = &v
	}
	if opts.timeout != nil {
		if *opts.timeout < time.Second {
			return nil, fmt.Errorf("timeout must be at least 1 second, got %v", *opts.timeout)
		}
		if (*opts.timeout)%time.Second != 0 {
			return nil, fmt.Errorf("timeout must be a whole number of seconds, got %v", *opts.timeout)
		}
		v := uint32((*opts.timeout) / time.Second)
		builder.TimeoutSecs = &v
	}

	if opts.maxConcurrentInputs != nil {
		v := uint32(*opts.maxConcurrentInputs)
		builder.MaxConcurrentInputs = &v
	}
	if opts.targetConcurrentInputs != nil {
		v := uint32(*opts.targetConcurrentInputs)
		builder.TargetConcurrentInputs = &v
	}

	if opts.batchMaxSize != nil {
		v := uint32(*opts.batchMaxSize)
		builder.BatchMaxSize = &v
	}
	if opts.batchWait != nil {
		v := uint64((*opts.batchWait) / time.Millisecond)
		builder.BatchLingerMs = &v
	}

	return builder.Build(), nil
}



================================================
FILE: modal-go/cls_test.go
================================================
package modal

import (
	"context"
	"testing"

	"github.com/onsi/gomega"
)

func TestBuildFunctionOptionsProto_NilOptions(t *testing.T) {
	g := gomega.NewWithT(t)

	options, err := buildFunctionOptionsProto(nil, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(options).Should(gomega.BeNil())
}

func TestBuildFunctionOptionsProto_MergesEnvAndSecrets(t *testing.T) {
	g := gomega.NewWithT(t)

	secretEnvVars := map[string]string{"A": "1"}
	secret, err := SecretFromMap(context.Background(), secretEnvVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	envVars := map[string]string{"B": "2"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = buildFunctionOptionsProto(&serviceOptions{env: &envVars}, nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: env and envSecret must both be provided or neither be provided"))

	mem := 1 // need to pass a non-empty serviceOptions to pass the !hasOptions(opts) check
	_, err = buildFunctionOptionsProto(&serviceOptions{memory: &mem}, envSecret)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: env and envSecret must both be provided or neither be provided"))

	functionOptions, err := buildFunctionOptionsProto(&serviceOptions{
		env:     &envVars,
		secrets: &[]*Secret{secret},
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(functionOptions.GetSecretIds()).To(gomega.HaveLen(2))
	g.Expect(functionOptions.GetSecretIds()).To(gomega.ContainElement(secret.SecretId))
	g.Expect(functionOptions.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
	g.Expect(functionOptions.GetReplaceSecretIds()).To(gomega.BeTrue())
}

func TestBuildFunctionOptionsProto_WithOnlyEnvParameter(t *testing.T) {
	g := gomega.NewWithT(t)

	envVars := map[string]string{"B": "2"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	functionOptions, err := buildFunctionOptionsProto(&serviceOptions{
		env: &envVars,
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(functionOptions.GetSecretIds()).To(gomega.HaveLen(1))
	g.Expect(functionOptions.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
	g.Expect(functionOptions.GetReplaceSecretIds()).To(gomega.BeTrue())
}

func TestBuildFunctionOptionsProto_EmptyEnv_WithSecrets(t *testing.T) {
	g := gomega.NewWithT(t)

	secret, err := SecretFromMap(context.Background(), map[string]string{"A": "1"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	opts := &serviceOptions{env: &map[string]string{}, secrets: &[]*Secret{secret}}

	functionOptions, err := buildFunctionOptionsProto(opts, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(functionOptions.GetSecretIds()).To(gomega.HaveLen(1))
	g.Expect(functionOptions.GetSecretIds()).To(gomega.ContainElement(secret.SecretId))
	g.Expect(functionOptions.GetReplaceSecretIds()).To(gomega.BeTrue())
}

func TestBuildFunctionOptionsProto_EmptyEnv_NoSecrets(t *testing.T) {
	g := gomega.NewWithT(t)

	functionOptions, err := buildFunctionOptionsProto(&serviceOptions{env: &map[string]string{}}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(functionOptions.GetSecretIds()).To(gomega.HaveLen(0))
	g.Expect(functionOptions.GetReplaceSecretIds()).To(gomega.BeFalse())
}



================================================
FILE: modal-go/config.go
================================================
package modal

// config.go houses the logic for loading and resolving Modal profiles
// from ~/.modal.toml or environment variables.

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

// Profile holds a fully-resolved configuration ready for use by the client.
type Profile struct {
	ServerURL           string // e.g. https://api.modal.com:443
	TokenId             string // optional (if InitializeClient is called)
	TokenSecret         string // optional (if InitializeClient is called)
	Environment         string // optional
	ImageBuilderVersion string // optional
}

// rawProfile mirrors the TOML structure on disk.
type rawProfile struct {
	ServerURL           string `toml:"server_url"`
	TokenId             string `toml:"token_id"`
	TokenSecret         string `toml:"token_secret"`
	Environment         string `toml:"environment"`
	ImageBuilderVersion string `toml:"image_builder_version"`
	Active              bool   `toml:"active"`
}

type config map[string]rawProfile

// readConfigFile loads ~/.modal.toml, returning an empty config if the file
// does not exist.
func readConfigFile() (config, error) {
	home, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("cannot locate homedir: %w", err)
	}
	path := filepath.Join(home, ".modal.toml")
	content, err := os.ReadFile(path)
	if errors.Is(err, os.ErrNotExist) {
		return config{}, nil // silent absence is fine
	} else if err != nil {
		return nil, fmt.Errorf("reading %s: %w", path, err)
	}

	var cfg config
	if err := toml.Unmarshal(content, &cfg); err != nil {
		return nil, fmt.Errorf("parsing %s: %w", path, err)
	}
	return cfg, nil
}

// getProfile resolves a profile by name. Pass an empty string to instead return
// the first profile in the configuration file with `active = true`.
//
// Returned Profile is ready for use; error describes what is missing.
func getProfile(name string) Profile {
	if name == "" {
		for n, p := range defaultConfig {
			if p.Active {
				name = n
				break
			}
		}
	}

	var raw rawProfile
	if name != "" {
		raw = defaultConfig[name]
	}

	// Env-vars override file values.
	serverURL := firstNonEmpty(os.Getenv("MODAL_SERVER_URL"), raw.ServerURL, "https://api.modal.com:443")
	tokenId := firstNonEmpty(os.Getenv("MODAL_TOKEN_ID"), raw.TokenId)
	tokenSecret := firstNonEmpty(os.Getenv("MODAL_TOKEN_SECRET"), raw.TokenSecret)
	environment := firstNonEmpty(os.Getenv("MODAL_ENVIRONMENT"), raw.Environment)
	imageBuilderVersion := firstNonEmpty(os.Getenv("MODAL_IMAGE_BUILDER_VERSION"), raw.ImageBuilderVersion)

	return Profile{
		ServerURL:           serverURL,
		TokenId:             tokenId,
		TokenSecret:         tokenSecret,
		Environment:         environment,
		ImageBuilderVersion: imageBuilderVersion,
	}
}

func firstNonEmpty(values ...string) string {
	for _, v := range values {
		if v != "" {
			return v
		}
	}
	return ""
}

func environmentName(environment string) string {
	return firstNonEmpty(environment, clientProfile.Environment)
}

func imageBuilderVersion(version string) string {
	return firstNonEmpty(version, clientProfile.ImageBuilderVersion, "2024.10")
}



================================================
FILE: modal-go/doc.go
================================================
// Package modal is a lightweight, idiomatic Go client for Modal.com.
//
// The library mirrors the core feature-set of Modal’s Python client while
// feeling natural in Go:
//
//   - Spin up Sandboxes — fast, secure, ephemeral VMs for running code.
//   - Invoke Modal Functions and manage their inputs / outputs.
//   - Read, write, and list files in Modal Volumes.
//   - Create or inspect containers, streams, and logs.
//
// **What it does not do:** deploying Modal Functions. Deployment is still
// handled in Python; this package is for calling and orchestrating them
// from other projects.
//
// # Authentication
//
// At runtime the client resolves credentials in this order:
//
//  1. Environment variables
//     MODAL_TOKEN_ID, MODAL_TOKEN_SECRET, MODAL_ENVIRONMENT (optional)
//  2. A profile explicitly requested via `MODAL_PROFILE`
//  3. A profile marked `active = true` in `~/.modal.toml`
//
// See `config.go` for the resolution logic.
//
// # Stability
//
// `libmodal` is **alpha** software; the API may change without notice until
// a v1.0.0 release. Please pin versions and file issues generously.
//
// For additional examples and language-parity tests, see
// https://github.com/modal-labs/libmodal.

package modal



================================================
FILE: modal-go/ephemeral.go
================================================
package modal

import (
	"context"
	"time"
)

const ephemeralObjectHeartbeatSleep = 300 * time.Second

func startEphemeralHeartbeat(ctx context.Context, heartbeatFn func() error) {
	go func() {
		t := time.NewTicker(ephemeralObjectHeartbeatSleep)
		defer t.Stop()
		for {
			select {
			case <-ctx.Done():
				return
			case <-t.C:
				_ = heartbeatFn() // ignore errors – next call will retry or context will cancel
			}
		}
	}()
}



================================================
FILE: modal-go/errors.go
================================================
package modal

// errors.go defines common error types for the public API.

// FunctionTimeoutError is returned when a Function execution exceeds the allowed time limit.
type FunctionTimeoutError struct {
	Exception string
}

func (e FunctionTimeoutError) Error() string {
	return "FunctionTimeoutError: " + e.Exception
}

// RemoteError represents an error on the Modal server, or a Python exception.
type RemoteError struct {
	Exception string
}

func (e RemoteError) Error() string {
	return "RemoteError: " + e.Exception
}

// InternalFailure is a retryable internal error from Modal.
type InternalFailure struct {
	Exception string
}

func (e InternalFailure) Error() string {
	return "InternalFailure: " + e.Exception
}

// ExecutionError is returned when something unexpected happened during runtime.
type ExecutionError struct {
	Exception string
}

func (e ExecutionError) Error() string {
	return "ExecutionError: " + e.Exception
}

// NotFoundError is returned when a resource is not found.
type NotFoundError struct {
	Exception string
}

func (e NotFoundError) Error() string {
	return "NotFoundError: " + e.Exception
}

// AlreadyExistsError is returned when a resource already exists.
type AlreadyExistsError struct {
	Exception string
}

func (e AlreadyExistsError) Error() string {
	return "AlreadyExistsError: " + e.Exception
}

// InvalidError represents an invalid request or operation.
type InvalidError struct {
	Exception string
}

func (e InvalidError) Error() string {
	return "InvalidError: " + e.Exception
}

// QueueEmptyError is returned when an operation is attempted on an empty Queue.
type QueueEmptyError struct {
	Exception string
}

func (e QueueEmptyError) Error() string {
	return "QueueEmptyError: " + e.Exception
}

// QueueFullError is returned when an operation is attempted on a full Queue.
type QueueFullError struct {
	Exception string
}

func (e QueueFullError) Error() string {
	return "QueueFullError: " + e.Exception
}

// SandboxFilesystemError is returned when an operation is attempted on a full Queue.
type SandboxFilesystemError struct {
	Exception string
}

func (e SandboxFilesystemError) Error() string {
	return "SandboxFilesystemError: " + e.Exception
}

// SandboxTimeoutError is returned when Sandbox operations exceed the allowed time limit.
type SandboxTimeoutError struct {
	Exception string
}

func (e SandboxTimeoutError) Error() string {
	return "SandboxTimeoutError: " + e.Exception
}



================================================
FILE: modal-go/function.go
================================================
package modal

// Function calls and invocations, to be used with Modal Functions.

import (
	"bytes"
	"context"
	"crypto/md5"
	"crypto/sha256"
	"encoding/base64"
	"errors"
	"fmt"
	"net/http"
	"time"

	pickle "github.com/kisielk/og-rek"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// From: modal/_utils/blob_utils.py
const maxObjectSizeBytes int = 2 * 1024 * 1024 // 2 MiB

// From: modal-client/modal/_utils/function_utils.py
const outputsTimeout time.Duration = time.Second * 55

// From: client/modal/_functions.py
const maxSystemRetries = 8

func timeNowSeconds() float64 {
	return float64(time.Now().UnixNano()) / 1e9
}

// FunctionStats represents statistics for a running Function.
type FunctionStats struct {
	Backlog         int
	NumTotalRunners int
}

// UpdateAutoscalerOptions contains options for overriding a Function's autoscaler behavior.
type UpdateAutoscalerOptions struct {
	MinContainers    *uint32
	MaxContainers    *uint32
	BufferContainers *uint32
	ScaledownWindow  *uint32
}

// Function references a deployed Modal Function.
type Function struct {
	FunctionId    string
	MethodName    *string // used for class methods
	inputPlaneUrl string  // if empty, use control plane
	webURL        string  // web URL if this Function is a web endpoint
	ctx           context.Context
}

// FunctionLookup looks up an existing Function.
func FunctionLookup(ctx context.Context, appName string, name string, options *LookupOptions) (*Function, error) {
	if options == nil {
		options = &LookupOptions{}
	}

	resp, err := client.FunctionGet(ctx, pb.FunctionGetRequest_builder{
		AppName:         appName,
		ObjectTag:       name,
		EnvironmentName: environmentName(options.Environment),
	}.Build())

	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("Function '%s/%s' not found", appName, name)}
	}
	if err != nil {
		return nil, err
	}

	var inputPlaneUrl string
	var webURL string
	if meta := resp.GetHandleMetadata(); meta != nil {
		if url := meta.GetInputPlaneUrl(); url != "" {
			inputPlaneUrl = url
		}
		webURL = meta.GetWebUrl()
	}
	return &Function{FunctionId: resp.GetFunctionId(), inputPlaneUrl: inputPlaneUrl, webURL: webURL, ctx: ctx}, nil
}

// pickleSerialize serializes Go data types to the Python pickle format.
func pickleSerialize(v any) (bytes.Buffer, error) {
	var inputBuffer bytes.Buffer

	e := pickle.NewEncoder(&inputBuffer)
	err := e.Encode(v)

	if err != nil {
		return bytes.Buffer{}, fmt.Errorf("error pickling data: %w", err)
	}
	return inputBuffer, nil
}

// pickleDeserialize deserializes from Python pickle into Go basic types.
func pickleDeserialize(buffer []byte) (any, error) {
	decoder := pickle.NewDecoder(bytes.NewReader(buffer))
	result, err := decoder.Decode()
	if err != nil {
		return nil, fmt.Errorf("error unpickling data: %w", err)
	}
	return result, nil
}

// createInput serializes inputs, makes a function call and returns its ID
func (f *Function) createInput(args []any, kwargs map[string]any) (*pb.FunctionInput, error) {
	payload, err := pickleSerialize(pickle.Tuple{args, kwargs})
	if err != nil {
		return nil, err
	}

	argsBytes := payload.Bytes()
	var argsBlobId *string
	if payload.Len() > maxObjectSizeBytes {
		blobId, err := blobUpload(f.ctx, argsBytes)
		if err != nil {
			return nil, err
		}
		argsBytes = nil
		argsBlobId = &blobId
	}

	return pb.FunctionInput_builder{
		Args:       argsBytes,
		ArgsBlobId: argsBlobId,
		DataFormat: pb.DataFormat_DATA_FORMAT_PICKLE,
		MethodName: f.MethodName,
	}.Build(), nil
}

// Remote executes a single input on a remote Function.
func (f *Function) Remote(args []any, kwargs map[string]any) (any, error) {
	input, err := f.createInput(args, kwargs)
	if err != nil {
		return nil, err
	}
	invocation, err := f.createRemoteInvocation(input)
	if err != nil {
		return nil, err
	}
	// TODO(ryan): Add tests for retries.
	retryCount := uint32(0)
	for {
		output, err := invocation.awaitOutput(nil)
		if err == nil {
			return output, nil
		}
		if errors.As(err, &InternalFailure{}) && retryCount <= maxSystemRetries {
			if retryErr := invocation.retry(retryCount); retryErr != nil {
				return nil, retryErr
			}
			retryCount++
			continue
		}
		return nil, err
	}
}

// createRemoteInvocation creates an Invocation using either the input plane or control plane.
func (f *Function) createRemoteInvocation(input *pb.FunctionInput) (invocation, error) {
	if f.inputPlaneUrl != "" {
		return createInputPlaneInvocation(f.ctx, f.inputPlaneUrl, f.FunctionId, input)
	}
	return createControlPlaneInvocation(f.ctx, f.FunctionId, input, pb.FunctionCallInvocationType_FUNCTION_CALL_INVOCATION_TYPE_SYNC)
}

// Spawn starts running a single input on a remote Function.
func (f *Function) Spawn(args []any, kwargs map[string]any) (*FunctionCall, error) {
	input, err := f.createInput(args, kwargs)
	if err != nil {
		return nil, err
	}
	invocation, err := createControlPlaneInvocation(f.ctx, f.FunctionId, input, pb.FunctionCallInvocationType_FUNCTION_CALL_INVOCATION_TYPE_SYNC)
	if err != nil {
		return nil, err
	}
	functionCall := FunctionCall{
		FunctionCallId: invocation.FunctionCallId,
		ctx:            f.ctx,
	}
	return &functionCall, nil
}

// GetCurrentStats returns a FunctionStats object with statistics about the Function.
func (f *Function) GetCurrentStats() (*FunctionStats, error) {
	resp, err := client.FunctionGetCurrentStats(f.ctx, pb.FunctionGetCurrentStatsRequest_builder{
		FunctionId: f.FunctionId,
	}.Build())
	if err != nil {
		return nil, err
	}

	return &FunctionStats{
		Backlog:         int(resp.GetBacklog()),
		NumTotalRunners: int(resp.GetNumTotalTasks()),
	}, nil
}

// UpdateAutoscaler overrides the current autoscaler behavior for this Function.
func (f *Function) UpdateAutoscaler(opts UpdateAutoscalerOptions) error {
	settings := pb.AutoscalerSettings_builder{
		MinContainers:    opts.MinContainers,
		MaxContainers:    opts.MaxContainers,
		BufferContainers: opts.BufferContainers,
		ScaledownWindow:  opts.ScaledownWindow,
	}.Build()

	_, err := client.FunctionUpdateSchedulingParams(f.ctx, pb.FunctionUpdateSchedulingParamsRequest_builder{
		FunctionId:           f.FunctionId,
		WarmPoolSizeOverride: 0, // Deprecated field, always set to 0
		Settings:             settings,
	}.Build())

	return err
}

// GetWebURL returns the URL of a Function running as a web endpoint.
// Returns empty string if this Function is not a web endpoint.
func (f *Function) GetWebURL() string {
	return f.webURL
}

// blobUpload uploads a blob to storage and returns its ID.
func blobUpload(ctx context.Context, data []byte) (string, error) {
	md5sum := md5.Sum(data)
	sha256sum := sha256.Sum256(data)
	contentMd5 := base64.StdEncoding.EncodeToString(md5sum[:])
	contentSha256 := base64.StdEncoding.EncodeToString(sha256sum[:])

	resp, err := client.BlobCreate(ctx, pb.BlobCreateRequest_builder{
		ContentMd5:          contentMd5,
		ContentSha256Base64: contentSha256,
		ContentLength:       int64(len(data)),
	}.Build())
	if err != nil {
		return "", fmt.Errorf("failed to create blob: %w", err)
	}

	switch resp.WhichUploadTypeOneof() {
	case pb.BlobCreateResponse_Multipart_case:
		return "", fmt.Errorf("Function input size exceeds multipart upload threshold, unsupported by this SDK version")

	case pb.BlobCreateResponse_UploadUrl_case:
		req, err := http.NewRequest("PUT", resp.GetUploadUrl(), bytes.NewReader(data))
		if err != nil {
			return "", fmt.Errorf("failed to create upload request: %w", err)
		}
		req.Header.Set("Content-Type", "application/octet-stream")
		req.Header.Set("Content-MD5", contentMd5)
		uploadResp, err := http.DefaultClient.Do(req)
		if err != nil {
			return "", fmt.Errorf("failed to upload blob: %w", err)
		}
		defer uploadResp.Body.Close()
		if uploadResp.StatusCode < 200 || uploadResp.StatusCode >= 300 {
			return "", fmt.Errorf("failed blob upload: %s", uploadResp.Status)
		}
		// Skip client-side ETag header validation for now (MD5 checksum).
		return resp.GetBlobId(), nil

	default:
		return "", fmt.Errorf("missing upload URL in BlobCreate response")
	}
}



================================================
FILE: modal-go/function_call.go
================================================
package modal

import (
	"context"
	"fmt"
	"time"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// FunctionCall references a Modal Function Call. Function Calls are
// Function invocations with a given input. They can be consumed
// asynchronously (see Get()) or cancelled (see Cancel()).
type FunctionCall struct {
	FunctionCallId string
	ctx            context.Context
}

// FunctionCallFromId looks up a FunctionCall by ID.
func FunctionCallFromId(ctx context.Context, functionCallId string) (*FunctionCall, error) {
	functionCall := FunctionCall{
		FunctionCallId: functionCallId,
		ctx:            ctx,
	}
	return &functionCall, nil
}

// FunctionCallGetOptions are options for getting outputs from Function Calls.
type FunctionCallGetOptions struct {
	// Timeout specifies the maximum duration to wait for the output.
	// If nil, no timeout is applied. If set to 0, it will check if the function
	// call is already completed.
	Timeout *time.Duration
}

// Get waits for the output of a FunctionCall.
// If timeout > 0, the operation will be cancelled after the specified duration.
func (fc *FunctionCall) Get(options *FunctionCallGetOptions) (any, error) {
	if options == nil {
		options = &FunctionCallGetOptions{}
	}
	ctx := fc.ctx
	invocation := controlPlaneInvocationFromFunctionCallId(ctx, fc.FunctionCallId)
	return invocation.awaitOutput(options.Timeout)
}

// FunctionCallCancelOptions are options for cancelling Function Calls.
type FunctionCallCancelOptions struct {
	TerminateContainers bool
}

// Cancel cancels a FunctionCall.
func (fc *FunctionCall) Cancel(options *FunctionCallCancelOptions) error {
	if options == nil {
		options = &FunctionCallCancelOptions{}
	}
	_, err := client.FunctionCallCancel(fc.ctx, pb.FunctionCallCancelRequest_builder{
		FunctionCallId:      fc.FunctionCallId,
		TerminateContainers: options.TerminateContainers,
	}.Build())
	if err != nil {
		return fmt.Errorf("FunctionCallCancel failed: %w", err)
	}

	return nil
}



================================================
FILE: modal-go/go.mod
================================================
module github.com/modal-labs/libmodal/modal-go

go 1.23.0

toolchain go1.23.3

require (
	github.com/djherbis/buffer v1.2.0
	github.com/djherbis/nio/v3 v3.0.1
	github.com/google/uuid v1.6.0
	github.com/kisielk/og-rek v1.3.0
	github.com/onsi/gomega v1.37.0
	github.com/pelletier/go-toml/v2 v2.2.4
	google.golang.org/grpc v1.72.0
	google.golang.org/protobuf v1.36.6
)

require (
	github.com/aristanetworks/gomap v0.0.0-20230726210543-f4e41046dced // indirect
	github.com/google/go-cmp v0.7.0 // indirect
	golang.org/x/exp v0.0.0-20230725093048-515e97ebf090 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20250428153025-10db94c68c34 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)



================================================
FILE: modal-go/go.sum
================================================
github.com/aristanetworks/gomap v0.0.0-20230726210543-f4e41046dced h1:HxlRMDx/VeRqzj3nvqX9k4tjeBcEIkoNHDJPsS389hs=
github.com/aristanetworks/gomap v0.0.0-20230726210543-f4e41046dced/go.mod h1:p7lmI+ecoe1RTyD11SPXWsSQ3H+pJ4cp5y7vtKW4QdM=
github.com/djherbis/buffer v1.1.0/go.mod h1:VwN8VdFkMY0DCALdY8o00d3IZ6Amz/UNVMWcSaJT44o=
github.com/djherbis/buffer v1.2.0 h1:PH5Dd2ss0C7CRRhQCZ2u7MssF+No9ide8Ye71nPHcrQ=
github.com/djherbis/buffer v1.2.0/go.mod h1:fjnebbZjCUpPinBRD+TDwXSOeNQ7fPQWLfGQqiAiUyE=
github.com/djherbis/nio/v3 v3.0.1 h1:6wxhnuppteMa6RHA4L81Dq7ThkZH8SwnDzXDYy95vB4=
github.com/djherbis/nio/v3 v3.0.1/go.mod h1:Ng4h80pbZFMla1yKzm61cF0tqqilXZYrogmWgZxOcmg=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=
github.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
github.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad h1:a6HEuzUHeKH6hwfN/ZoQgRgVIWFJljSWa/zetS2WTvg=
github.com/google/pprof v0.0.0-20241210010833-40e02aabc2ad/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/kisielk/og-rek v1.3.0 h1:lTXdQXqFETZKA//FWH4RBNAuiJ/dofxIwHAidoUZoMk=
github.com/kisielk/og-rek v1.3.0/go.mod h1:4at7oxyfBTDilURhNCf7irHWtosJlJl9uyqUqAkrP4w=
github.com/onsi/ginkgo/v2 v2.23.3 h1:edHxnszytJ4lD9D5Jjc4tiDkPBZ3siDeJJkUZJJVkp0=
github.com/onsi/ginkgo/v2 v2.23.3/go.mod h1:zXTP6xIp3U8aVuXN8ENK9IXRaTjFnpVB9mGmaSRvxnM=
github.com/onsi/gomega v1.37.0 h1:CdEG8g0S133B4OswTDC/5XPSzE1OeP29QOioj2PID2Y=
github.com/onsi/gomega v1.37.0/go.mod h1:8D9+Txp43QWKhM24yyOBEdpkzN8FvJyAwecBgsU4KU0=
github.com/pelletier/go-toml/v2 v2.2.4 h1:mye9XuhQ6gvn5h28+VilKrrPoQVanw5PMw/TB0t5Ec4=
github.com/pelletier/go-toml/v2 v2.2.4/go.mod h1:2gIqNv+qfxSVS7cM2xJQKtLSTLUE9V8t9Stt+h56mCY=
go.opentelemetry.io/auto/sdk v1.1.0 h1:cH53jehLUN6UFLY71z+NDOiNJqDdPRaXzTel0sJySYA=
go.opentelemetry.io/auto/sdk v1.1.0/go.mod h1:3wSPjt5PWp2RhlCcmmOial7AvC4DQqZb7a7wCow3W8A=
go.opentelemetry.io/otel v1.34.0 h1:zRLXxLCgL1WyKsPVrgbSdMN4c0FMkDAskSTQP+0hdUY=
go.opentelemetry.io/otel v1.34.0/go.mod h1:OWFPOQ+h4G8xpyjgqo4SxJYdDQ/qmRH+wivy7zzx9oI=
go.opentelemetry.io/otel/metric v1.34.0 h1:+eTR3U0MyfWjRDhmFMxe2SsW64QrZ84AOhvqS7Y+PoQ=
go.opentelemetry.io/otel/metric v1.34.0/go.mod h1:CEDrp0fy2D0MvkXE+dPV7cMi8tWZwX3dmaIhwPOaqHE=
go.opentelemetry.io/otel/sdk v1.34.0 h1:95zS4k/2GOy069d321O8jWgYsW3MzVV+KuSPKp7Wr1A=
go.opentelemetry.io/otel/sdk v1.34.0/go.mod h1:0e/pNiaMAqaykJGKbi+tSjWfNNHMTxoC9qANsCzbyxU=
go.opentelemetry.io/otel/sdk/metric v1.34.0 h1:5CeK9ujjbFVL5c1PhLuStg1wxA7vQv7ce1EK0Gyvahk=
go.opentelemetry.io/otel/sdk/metric v1.34.0/go.mod h1:jQ/r8Ze28zRKoNRdkjCZxfs6YvBTG1+YIqyFVFYec5w=
go.opentelemetry.io/otel/trace v1.34.0 h1:+ouXS2V8Rd4hp4580a8q23bg0azF2nI8cqLYnC8mh/k=
go.opentelemetry.io/otel/trace v1.34.0/go.mod h1:Svm7lSjQD7kG7KJ/MUHPVXSDGz2OX4h0M2jHBhmSfRE=
golang.org/x/exp v0.0.0-20230725093048-515e97ebf090 h1:Di6/M8l0O2lCLc6VVRWhgCiApHV8MnQurBnFSHsQtNY=
golang.org/x/exp v0.0.0-20230725093048-515e97ebf090/go.mod h1:FXUEEKJgO7OQYeo8N01OfiKP8RXMtf6e8aTskBGqWdc=
golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
golang.org/x/sys v0.32.0 h1:s77OFDvIQeibCmezSnk/q6iAfkdiQaJi4VzroCFrN20=
golang.org/x/sys v0.32.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
golang.org/x/tools v0.30.0 h1:BgcpHewrV5AUp2G9MebG4XPFI1E2W41zU1SaqVA9vJY=
golang.org/x/tools v0.30.0/go.mod h1:c347cR/OJfw5TI+GfX7RUPNMdDRRbjvYTS0jPyvsVtY=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250428153025-10db94c68c34 h1:h6p3mQqrmT1XkHVTfzLdNz1u7IhINeZkz67/xTbOuWs=
google.golang.org/genproto/googleapis/rpc v0.0.0-20250428153025-10db94c68c34/go.mod h1:qQ0YXyHHx3XkvlzUtpXDkS29lDSafHMZBAZDc03LQ3A=
google.golang.org/grpc v1.72.0 h1:S7UkcVa60b5AAQTaO6ZKamFp1zMZSU0fGDK2WZLbBnM=
google.golang.org/grpc v1.72.0/go.mod h1:wH5Aktxcg25y1I3w7H69nHfXdOG3UiadoBtjh3izSDM=
google.golang.org/protobuf v1.36.6 h1:z1NpPI8ku2WgiWnf+t9wTPsn6eP1L7ksHUlkfLvd9xY=
google.golang.org/protobuf v1.36.6/go.mod h1:jduwjTPXsFjZGTmRluh+L6NjiWu7pchiJ2/5YcXBHnY=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=



================================================
FILE: modal-go/image.go
================================================
package modal

import (
	"context"
	"fmt"
	"io"
	"strings"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// ImageDockerfileCommandsOptions are options for Image.DockerfileCommands().
type ImageDockerfileCommandsOptions struct {
	// Environment variables to set in the build environment.
	Env map[string]string

	// Secrets that will be made available as environment variables to this layer's build environment.
	Secrets []*Secret

	// GPU reservation for this layer's build environment (e.g. "A100", "T4:2", "A100-80GB:4").
	GPU string

	// Ignore cached builds for this layer, similar to 'docker build --no-cache'.
	ForceBuild bool
}

// layer represents a single image layer with its build configuration.
type layer struct {
	commands   []string
	env        map[string]string
	secrets    []*Secret
	gpu        string
	forceBuild bool
}

// Image represents a Modal Image, which can be used to create Sandboxes.
type Image struct {
	ImageId string

	imageRegistryConfig *pb.ImageRegistryConfig
	tag                 string
	layers              []layer

	//lint:ignore U1000 may be used in future
	ctx context.Context
}

// NewImageFromRegistry builds a Modal Image from a public or private image registry without any changes.
func NewImageFromRegistry(tag string, options *ImageFromRegistryOptions) *Image {
	if options == nil {
		options = &ImageFromRegistryOptions{}
	}
	var imageRegistryConfig *pb.ImageRegistryConfig
	if options.Secret != nil {
		imageRegistryConfig = pb.ImageRegistryConfig_builder{
			RegistryAuthType: pb.RegistryAuthType_REGISTRY_AUTH_TYPE_STATIC_CREDS,
			SecretId:         options.Secret.SecretId,
		}.Build()
	}

	return &Image{
		ImageId:             "",
		imageRegistryConfig: imageRegistryConfig,
		tag:                 tag,
		layers:              []layer{{}},
	}
}

// NewImageFromAwsEcr creates an Image from an AWS ECR tag.
func NewImageFromAwsEcr(tag string, secret *Secret) *Image {
	imageRegistryConfig := pb.ImageRegistryConfig_builder{
		RegistryAuthType: pb.RegistryAuthType_REGISTRY_AUTH_TYPE_AWS,
		SecretId:         secret.SecretId,
	}.Build()

	return &Image{
		ImageId:             "",
		imageRegistryConfig: imageRegistryConfig,
		tag:                 tag,
		layers:              []layer{{}},
	}
}

// NewImageFromGcpArtifactRegistry creates an Image from a GCP Artifact Registry tag.
func NewImageFromGcpArtifactRegistry(tag string, secret *Secret) *Image {
	imageRegistryConfig := pb.ImageRegistryConfig_builder{
		RegistryAuthType: pb.RegistryAuthType_REGISTRY_AUTH_TYPE_GCP,
		SecretId:         secret.SecretId,
	}.Build()
	return &Image{
		ImageId:             "",
		imageRegistryConfig: imageRegistryConfig,
		tag:                 tag,
		layers:              []layer{{}},
	}
}

// NewImageFromId looks up an Image from an ID
func NewImageFromId(ctx context.Context, imageId string) (*Image, error) {
	resp, err := client.ImageFromId(
		ctx,
		pb.ImageFromIdRequest_builder{
			ImageId: imageId,
		}.Build(),
	)
	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("Image '%s' not found", imageId)}
	}
	if err != nil {
		return nil, err
	}

	return &Image{
		ImageId: resp.GetImageId(),
		layers:  []layer{{}},
	}, nil
}

// DockerfileCommands extends an image with arbitrary Dockerfile-like commands.
//
// Each call creates a new Image layer that will be built sequentially.
// The provided options apply only to this layer.
func (image *Image) DockerfileCommands(commands []string, options *ImageDockerfileCommandsOptions) *Image {
	if len(commands) == 0 {
		return image
	}

	if options == nil {
		options = &ImageDockerfileCommandsOptions{}
	}

	newLayer := layer{
		commands:   append([]string{}, commands...),
		env:        options.Env,
		secrets:    options.Secrets,
		gpu:        options.GPU,
		forceBuild: options.ForceBuild,
	}

	newLayers := append([]layer{}, image.layers...)
	newLayers = append(newLayers, newLayer)

	return &Image{
		ImageId:             "",
		tag:                 image.tag,
		imageRegistryConfig: image.imageRegistryConfig,
		layers:              newLayers,
	}
}

func validateDockerfileCommands(commands []string) error {
	for _, command := range commands {
		trimmed := strings.ToUpper(strings.TrimSpace(command))
		if strings.HasPrefix(trimmed, "COPY ") && !strings.HasPrefix(trimmed, "COPY --FROM=") {
			return InvalidError{"COPY commands that copy from local context are not yet supported."}
		}
	}
	return nil
}

// Build eagerly builds an Image on Modal.
func (image *Image) Build(app *App) (*Image, error) {
	if image == nil {
		return nil, InvalidError{"image must be non-nil"}
	}

	// Image is already hyrdated
	if image.ImageId != "" {
		return image, nil
	}

	for _, currentLayer := range image.layers {
		if err := validateDockerfileCommands(currentLayer.commands); err != nil {
			return nil, err
		}
	}

	var currentImageId string

	for i, currentLayer := range image.layers {
		var secretIds []string
		for _, secret := range currentLayer.secrets {
			secretIds = append(secretIds, secret.SecretId)
		}
		if len(currentLayer.env) > 0 {
			envSecret, err := SecretFromMap(app.ctx, currentLayer.env, nil)
			if err != nil {
				return nil, err
			}
			secretIds = append(secretIds, envSecret.SecretId)
		}

		var gpuConfig *pb.GPUConfig
		if currentLayer.gpu != "" {
			var err error
			gpuConfig, err = parseGPUConfig(currentLayer.gpu)
			if err != nil {
				return nil, err
			}
		}

		var dockerfileCommands []string
		var baseImages []*pb.BaseImage

		if i == 0 {
			dockerfileCommands = append([]string{fmt.Sprintf("FROM %s", image.tag)}, currentLayer.commands...)
			baseImages = []*pb.BaseImage{}
		} else {
			dockerfileCommands = append([]string{"FROM base"}, currentLayer.commands...)
			baseImages = []*pb.BaseImage{pb.BaseImage_builder{
				DockerTag: "base",
				ImageId:   currentImageId,
			}.Build()}
		}

		resp, err := client.ImageGetOrCreate(
			app.ctx,
			pb.ImageGetOrCreateRequest_builder{
				AppId: app.AppId,
				Image: pb.Image_builder{
					DockerfileCommands:  dockerfileCommands,
					ImageRegistryConfig: image.imageRegistryConfig,
					SecretIds:           secretIds,
					GpuConfig:           gpuConfig,
					ContextFiles:        []*pb.ImageContextFile{},
					BaseImages:          baseImages,
				}.Build(),
				BuilderVersion: imageBuilderVersion(""),
				ForceBuild:     currentLayer.forceBuild,
			}.Build(),
		)
		if err != nil {
			return nil, err
		}

		result := resp.GetResult()

		if result == nil || result.GetStatus() == pb.GenericResult_GENERIC_STATUS_UNSPECIFIED {
			// Not built or in the process of building - wait for build
			lastEntryId := ""
			for result == nil {
				stream, err := client.ImageJoinStreaming(app.ctx, pb.ImageJoinStreamingRequest_builder{
					ImageId:     resp.GetImageId(),
					Timeout:     55,
					LastEntryId: lastEntryId,
				}.Build())
				if err != nil {
					return nil, err
				}
				for {
					item, err := stream.Recv()
					if err != nil {
						if err == io.EOF {
							break
						}
						return nil, err
					}
					if item.GetEntryId() != "" {
						lastEntryId = item.GetEntryId()
					}
					if item.GetResult() != nil && item.GetResult().GetStatus() != pb.GenericResult_GENERIC_STATUS_UNSPECIFIED {
						result = item.GetResult()
						break
					}
					// Ignore all log lines and progress updates.
				}
			}
		}

		switch result.GetStatus() {
		case pb.GenericResult_GENERIC_STATUS_FAILURE:
			return nil, RemoteError{fmt.Sprintf("Image build for %s failed with the exception:\n%s", resp.GetImageId(), result.GetException())}
		case pb.GenericResult_GENERIC_STATUS_TERMINATED:
			return nil, RemoteError{fmt.Sprintf("Image build for %s terminated due to external shut-down. Please try again.", resp.GetImageId())}
		case pb.GenericResult_GENERIC_STATUS_TIMEOUT:
			return nil, RemoteError{fmt.Sprintf("Image build for %s timed out. Please try again with a larger timeout parameter.", resp.GetImageId())}
		case pb.GenericResult_GENERIC_STATUS_SUCCESS:
			// Success, do nothing
		default:
			return nil, RemoteError{fmt.Sprintf("Image build for %s failed with unknown status: %s", resp.GetImageId(), result.GetStatus())}
		}

		// The new image becomes the base for the next layer
		currentImageId = resp.GetImageId()
	}

	image.ImageId = currentImageId
	image.ctx = app.ctx
	return image, nil
}

// ImageDeleteOptions are options for deleting an Image.
type ImageDeleteOptions struct {
}

// ImageDelete deletes an Image by ID. Warning: This removes an *entire Image*, and cannot be undone.
func ImageDelete(ctx context.Context, imageId string, options *ImageDeleteOptions) error {

	image, err := NewImageFromId(ctx, imageId)
	if err != nil {
		return err
	}

	_, err = client.ImageDelete(ctx, pb.ImageDeleteRequest_builder{ImageId: image.ImageId}.Build())
	return err
}



================================================
FILE: modal-go/invocation.go
================================================
package modal

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"time"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/protobuf/proto"
)

type invocation interface {
	awaitOutput(timeout *time.Duration) (any, error)
	retry(retryCount uint32) error
}

// controlPlaneInvocation implements the invocation interface.
type controlPlaneInvocation struct {
	FunctionCallId  string
	input           *pb.FunctionInput
	functionCallJwt string
	inputJwt        string
	ctx             context.Context
}

// createControlPlaneInvocation executes a function call and returns a new controlPlaneInvocation.
func createControlPlaneInvocation(ctx context.Context, functionId string, input *pb.FunctionInput, invocationType pb.FunctionCallInvocationType) (*controlPlaneInvocation, error) {
	functionPutInputsItem := pb.FunctionPutInputsItem_builder{
		Idx:   0,
		Input: input,
	}.Build()

	functionMapResponse, err := client.FunctionMap(ctx, pb.FunctionMapRequest_builder{
		FunctionId:                 functionId,
		FunctionCallType:           pb.FunctionCallType_FUNCTION_CALL_TYPE_UNARY,
		FunctionCallInvocationType: invocationType,
		PipelinedInputs:            []*pb.FunctionPutInputsItem{functionPutInputsItem},
	}.Build())
	if err != nil {
		return nil, err
	}

	return &controlPlaneInvocation{
		FunctionCallId:  functionMapResponse.GetFunctionCallId(),
		input:           input,
		functionCallJwt: functionMapResponse.GetFunctionCallJwt(),
		inputJwt:        functionMapResponse.GetPipelinedInputs()[0].GetInputJwt(),
		ctx:             ctx,
	}, nil
}

// controlPlaneInvocationFromFunctionCallId creates a controlPlaneInvocation from a function call ID.
func controlPlaneInvocationFromFunctionCallId(ctx context.Context, functionCallId string) *controlPlaneInvocation {
	return &controlPlaneInvocation{FunctionCallId: functionCallId, ctx: ctx}
}

func (c *controlPlaneInvocation) awaitOutput(timeout *time.Duration) (any, error) {
	return pollFunctionOutput(c.ctx, c.getOutput, timeout)
}

func (c *controlPlaneInvocation) retry(retryCount uint32) error {
	if c.input == nil {
		return fmt.Errorf("cannot retry Function invocation - input missing")
	}
	retryItem := pb.FunctionRetryInputsItem_builder{
		InputJwt:   c.inputJwt,
		Input:      c.input,
		RetryCount: retryCount,
	}.Build()
	functionRetryResponse, err := client.FunctionRetryInputs(c.ctx, pb.FunctionRetryInputsRequest_builder{
		FunctionCallJwt: c.functionCallJwt,
		Inputs:          []*pb.FunctionRetryInputsItem{retryItem},
	}.Build())
	if err != nil {
		return err
	}
	c.inputJwt = functionRetryResponse.GetInputJwts()[0]
	return nil
}

// getOutput fetches the output for the current function call with a timeout in milliseconds.
func (c *controlPlaneInvocation) getOutput(timeout time.Duration) (*pb.FunctionGetOutputsItem, error) {
	response, err := client.FunctionGetOutputs(c.ctx, pb.FunctionGetOutputsRequest_builder{
		FunctionCallId: c.FunctionCallId,
		MaxValues:      1,
		Timeout:        float32(timeout.Seconds()),
		LastEntryId:    "0-0",
		ClearOnSuccess: true,
		RequestedAt:    timeNowSeconds(),
	}.Build())
	if err != nil {
		return nil, fmt.Errorf("FunctionGetOutputs failed: %w", err)
	}
	outputs := response.GetOutputs()
	if len(outputs) > 0 {
		return outputs[0], nil
	}
	return nil, nil
}

// inputPlaneInvocation implements the Invocation interface for the input plane.
type inputPlaneInvocation struct {
	client       pb.ModalClientClient
	functionId   string
	input        *pb.FunctionPutInputsItem
	attemptToken string
	ctx          context.Context
}

// createInputPlaneInvocation creates a new InputPlaneInvocation by starting an attempt.
func createInputPlaneInvocation(ctx context.Context, inputPlaneUrl string, functionId string, input *pb.FunctionInput) (*inputPlaneInvocation, error) {
	functionPutInputsItem := pb.FunctionPutInputsItem_builder{
		Idx:   0,
		Input: input,
	}.Build()
	client, err := getOrCreateInputPlaneClient(inputPlaneUrl)
	if err != nil {
		return nil, err
	}
	attemptStartResp, err := client.AttemptStart(ctx, pb.AttemptStartRequest_builder{
		FunctionId: functionId,
		Input:      functionPutInputsItem,
	}.Build())
	if err != nil {
		return nil, err
	}
	return &inputPlaneInvocation{
		client:       client,
		functionId:   functionId,
		input:        functionPutInputsItem,
		attemptToken: attemptStartResp.GetAttemptToken(),
		ctx:          ctx,
	}, nil
}

// awaitOutput waits for the output with an optional timeout.
func (i *inputPlaneInvocation) awaitOutput(timeout *time.Duration) (any, error) {
	return pollFunctionOutput(i.ctx, i.getOutput, timeout)
}

// getOutput fetches the output for the current attempt.
func (i *inputPlaneInvocation) getOutput(timeout time.Duration) (*pb.FunctionGetOutputsItem, error) {
	resp, err := i.client.AttemptAwait(i.ctx, pb.AttemptAwaitRequest_builder{
		AttemptToken: i.attemptToken,
		RequestedAt:  timeNowSeconds(),
		TimeoutSecs:  float32(timeout.Seconds()),
	}.Build())
	if err != nil {
		return nil, fmt.Errorf("AttemptAwait failed: %w", err)
	}
	return resp.GetOutput(), nil
}

// retry retries the invocation.
func (i *inputPlaneInvocation) retry(retryCount uint32) error {
	// We ignore retryCount - it is used only by controlPlaneInvocation.
	resp, err := i.client.AttemptRetry(context.Background(), pb.AttemptRetryRequest_builder{
		FunctionId:   i.functionId,
		Input:        i.input,
		AttemptToken: i.attemptToken,
	}.Build())
	if err != nil {
		return err
	}
	i.attemptToken = resp.GetAttemptToken()
	return nil
}

// getOutput is a function type that takes a timeout and returns a FunctionGetOutputsItem or nil, and an error.
// Used by `pollForOutputs` to fetch from either the control plane or the input plane, depending on the implementation.
type getOutput func(timeout time.Duration) (*pb.FunctionGetOutputsItem, error)

// pollFunctionOutput repeatedly tries to fetch an output using the provided `getOutput` function, and the specified
// timeout value. We use a timeout value of 55 seconds if the caller does not specify a timeout value, or if the
// specified timeout value is greater than 55 seconds.
func pollFunctionOutput(ctx context.Context, getOutput getOutput, timeout *time.Duration) (any, error) {
	startTime := time.Now()
	pollTimeout := outputsTimeout
	if timeout != nil {
		// Refresh backend call once per outputsTimeout.
		pollTimeout = min(*timeout, outputsTimeout)
	}

	for {
		output, err := getOutput(pollTimeout)
		if err != nil {
			return nil, err
		}
		// Output serialization may fail if any of the output items can't be deserialized
		// into a supported Go type. Users are expected to serialize outputs correctly.
		if output != nil {
			return processResult(ctx, output.GetResult(), output.GetDataFormat())
		}

		if timeout != nil {
			remainingTime := *timeout - time.Since(startTime)
			if remainingTime <= 0 {
				message := fmt.Sprintf("Timeout exceeded: %.1fs", timeout.Seconds())
				return nil, FunctionTimeoutError{message}
			}
			pollTimeout = min(outputsTimeout, remainingTime)
		}
	}
}

// processResult processes the result from an invocation.
func processResult(ctx context.Context, result *pb.GenericResult, dataFormat pb.DataFormat) (any, error) {
	if result == nil {
		return nil, RemoteError{"Received null result from invocation"}
	}

	var data []byte
	var err error
	switch result.WhichDataOneof() {
	case pb.GenericResult_Data_case:
		data = result.GetData()
	case pb.GenericResult_DataBlobId_case:
		data, err = blobDownload(ctx, result.GetDataBlobId())
		if err != nil {
			return nil, err
		}
	case pb.GenericResult_DataOneof_not_set_case:
		data = nil
	}

	switch result.GetStatus() {
	case pb.GenericResult_GENERIC_STATUS_TIMEOUT:
		return nil, FunctionTimeoutError{result.GetException()}
	case pb.GenericResult_GENERIC_STATUS_INTERNAL_FAILURE:
		return nil, InternalFailure{result.GetException()}
	case pb.GenericResult_GENERIC_STATUS_SUCCESS:
		// Proceed to the block below this switch statement.
	default:
		// In this case, `result.GetData()` may have a pickled user code exception with traceback
		// from Python. We ignore this and only take the string representation.
		return nil, RemoteError{result.GetException()}
	}

	return deserializeDataFormat(data, dataFormat)
}

// blobDownload downloads a blob by its ID.
func blobDownload(ctx context.Context, blobId string) ([]byte, error) {
	resp, err := client.BlobGet(ctx, pb.BlobGetRequest_builder{
		BlobId: blobId,
	}.Build())
	if err != nil {
		return nil, err
	}
	s3resp, err := http.Get(resp.GetDownloadUrl())
	if err != nil {
		return nil, fmt.Errorf("failed to download blob: %w", err)
	}
	defer s3resp.Body.Close()
	buf, err := io.ReadAll(s3resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read blob data: %w", err)
	}
	return buf, nil
}

func deserializeDataFormat(data []byte, dataFormat pb.DataFormat) (any, error) {
	switch dataFormat {
	case pb.DataFormat_DATA_FORMAT_PICKLE:
		return pickleDeserialize(data)
	case pb.DataFormat_DATA_FORMAT_ASGI:
		return nil, fmt.Errorf("ASGI data format is not supported in Go")
	case pb.DataFormat_DATA_FORMAT_GENERATOR_DONE:
		var done pb.GeneratorDone
		if err := proto.Unmarshal(data, &done); err != nil {
			return nil, fmt.Errorf("failed to unmarshal GeneratorDone: %w", err)
		}
		return &done, nil
	default:
		return nil, fmt.Errorf("unsupported data format: %s", dataFormat.String())
	}
}



================================================
FILE: modal-go/proxy.go
================================================
package modal

import (
	"context"
	"fmt"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Proxy represents a Modal Proxy.
type Proxy struct {
	ProxyId string

	//lint:ignore U1000 may be used in future
	ctx context.Context
}

// ProxyFromNameOptions are options for looking up a Modal Proxy.
type ProxyFromNameOptions struct {
	Environment string
}

// ProxyFromName references a modal.Proxy by its name.
func ProxyFromName(ctx context.Context, name string, options *ProxyFromNameOptions) (*Proxy, error) {
	if options == nil {
		options = &ProxyFromNameOptions{}
	}

	resp, err := client.ProxyGet(ctx, pb.ProxyGetRequest_builder{
		Name:            name,
		EnvironmentName: environmentName(options.Environment),
	}.Build())

	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("Proxy '%s' not found", name)}
	}
	if err != nil {
		return nil, err
	}

	if resp.GetProxy() == nil || resp.GetProxy().GetProxyId() == "" {
		return nil, NotFoundError{fmt.Sprintf("Proxy '%s' not found", name)}
	}

	return &Proxy{ProxyId: resp.GetProxy().GetProxyId(), ctx: ctx}, nil
}



================================================
FILE: modal-go/queue.go
================================================
package modal

// Queue object, to be used with Modal Queues.

import (
	"context"
	"fmt"
	"iter"
	"time"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

const queueInitialPutBackoff = 100 * time.Millisecond
const queueDefaultPartitionTtl = 24 * time.Hour

func validatePartitionKey(partition string) ([]byte, error) {
	if partition == "" {
		return nil, nil // default partition
	}
	b := []byte(partition)
	if len(b) == 0 || len(b) > 64 {
		return nil, InvalidError{"Queue partition key must be 1–64 bytes long"}
	}
	return b, nil
}

type QueueClearOptions struct {
	Partition string // partition to clear (default "")
	All       bool   // clear *all* partitions (mutually exclusive with Partition)
}

type QueueGetOptions struct {
	Timeout   *time.Duration // wait max (nil = indefinitely)
	Partition string
}

type QueuePutOptions struct {
	Timeout      *time.Duration // max wait for space (nil = indefinitely)
	Partition    string
	PartitionTtl time.Duration // ttl for the *partition* (default 24h)
}

type QueueLenOptions struct {
	Partition string
	Total     bool // total across all partitions (mutually exclusive with Partition)
}

type QueueIterateOptions struct {
	ItemPollTimeout time.Duration // exit if no new items within this period
	Partition       string
}

// Queue is a distributed, FIFO queue for data flow in Modal Apps.
type Queue struct {
	QueueId string
	Name    string
	cancel  context.CancelFunc
	ctx     context.Context
}

// QueueEphemeral creates a nameless, temporary Queue, that persists until CloseEphemeral is called, or the process exits.
func QueueEphemeral(ctx context.Context, options *EphemeralOptions) (*Queue, error) {
	if options == nil {
		options = &EphemeralOptions{}
	}

	resp, err := client.QueueGetOrCreate(ctx, pb.QueueGetOrCreateRequest_builder{
		ObjectCreationType: pb.ObjectCreationType_OBJECT_CREATION_TYPE_EPHEMERAL,
		EnvironmentName:    environmentName(options.Environment),
	}.Build())
	if err != nil {
		return nil, err
	}

	ephemeralCtx, cancel := context.WithCancel(ctx)
	startEphemeralHeartbeat(ephemeralCtx, func() error {
		_, err := client.QueueHeartbeat(ephemeralCtx, pb.QueueHeartbeatRequest_builder{
			QueueId: resp.GetQueueId(),
		}.Build())
		return err
	})

	q := &Queue{
		QueueId: resp.GetQueueId(),
		cancel:  cancel,
		ctx:     ephemeralCtx,
	}

	return q, nil
}

// CloseEphemeral deletes an ephemeral Queue, only used with QueueEphemeral.
func (q *Queue) CloseEphemeral() {
	if q.cancel != nil {
		q.cancel()
	} else {
		// We panic in this case because of invalid usage. In general, methods
		// used with `defer` like CloseEphemeral should not return errors.
		panic(fmt.Sprintf("Queue %s is not ephemeral", q.QueueId))
	}
}

// QueueLookup returns a handle to a (possibly new) Queue by name.
func QueueLookup(ctx context.Context, name string, options *LookupOptions) (*Queue, error) {
	if options == nil {
		options = &LookupOptions{}
	}

	creationType := pb.ObjectCreationType_OBJECT_CREATION_TYPE_UNSPECIFIED
	if options.CreateIfMissing {
		creationType = pb.ObjectCreationType_OBJECT_CREATION_TYPE_CREATE_IF_MISSING
	}

	resp, err := client.QueueGetOrCreate(ctx, pb.QueueGetOrCreateRequest_builder{
		DeploymentName:     name,
		EnvironmentName:    environmentName(options.Environment),
		ObjectCreationType: creationType,
	}.Build())
	if err != nil {
		return nil, err
	}
	return &Queue{ctx: ctx, QueueId: resp.GetQueueId(), Name: name, cancel: nil}, nil
}

// QueueDelete removes a Queue by name.
func QueueDelete(ctx context.Context, name string, options *DeleteOptions) error {
	if options == nil {
		options = &DeleteOptions{}
	}

	q, err := QueueLookup(ctx, name, &LookupOptions{Environment: options.Environment})
	if err != nil {
		return err
	}
	_, err = client.QueueDelete(ctx, pb.QueueDeleteRequest_builder{QueueId: q.QueueId}.Build())
	return err
}

// Clear removes all objects from a Queue partition.
func (q *Queue) Clear(options *QueueClearOptions) error {
	if options == nil {
		options = &QueueClearOptions{}
	}
	if options.Partition != "" && options.All {
		return InvalidError{"options.Partition must be \"\" when clearing all partitions"}
	}
	key, err := validatePartitionKey(options.Partition)
	if err != nil {
		return err
	}
	_, err = client.QueueClear(q.ctx, pb.QueueClearRequest_builder{
		QueueId:       q.QueueId,
		PartitionKey:  key,
		AllPartitions: options.All,
	}.Build())
	return err
}

// get is an internal helper for both Get and GetMany.
func (q *Queue) get(n int, options *QueueGetOptions) ([]any, error) {
	if options == nil {
		options = &QueueGetOptions{}
	}
	partitionKey, err := validatePartitionKey(options.Partition)
	if err != nil {
		return nil, err
	}

	startTime := time.Now()
	pollTimeout := 50 * time.Second
	if options.Timeout != nil && pollTimeout > *options.Timeout {
		pollTimeout = *options.Timeout
	}

	for {
		resp, err := client.QueueGet(q.ctx, pb.QueueGetRequest_builder{
			QueueId:      q.QueueId,
			PartitionKey: partitionKey,
			Timeout:      float32(pollTimeout.Seconds()),
			NValues:      int32(n),
		}.Build())
		if err != nil {
			return nil, err
		}
		if len(resp.GetValues()) > 0 {
			out := make([]any, len(resp.GetValues()))
			for i, raw := range resp.GetValues() {
				v, err := pickleDeserialize(raw)
				if err != nil {
					return nil, err
				}
				out[i] = v
			}
			return out, nil
		}
		if options.Timeout != nil {
			remaining := *options.Timeout - time.Since(startTime)
			if remaining <= 0 {
				message := fmt.Sprintf("Queue %s did not return values within %s", q.QueueId, *options.Timeout)
				return nil, QueueEmptyError{message}
			}
			pollTimeout = min(pollTimeout, remaining)
		}
	}
}

// Get removes and returns one item (blocking by default).
//
// By default, this will wait until at least one item is present in the Queue.
// If `timeout` is set, returns `QueueEmptyError` if no items are available
// within that timeout in milliseconds.
func (q *Queue) Get(options *QueueGetOptions) (any, error) {
	vals, err := q.get(1, options)
	if err != nil {
		return nil, err
	}
	return vals[0], nil // guaranteed len>=1
}

// GetMany removes up to n items.
//
// By default, this will wait until at least one item is present in the Queue.
// If `timeout` is set, returns `QueueEmptyError` if no items are available
// within that timeout in milliseconds.
func (q *Queue) GetMany(n int, options *QueueGetOptions) ([]any, error) {
	return q.get(n, options)
}

// put is an internal helper for both Put and PutMany.
func (q *Queue) put(values []any, options *QueuePutOptions) error {
	if options == nil {
		options = &QueuePutOptions{}
	}
	key, err := validatePartitionKey(options.Partition)
	if err != nil {
		return err
	}

	valuesEncoded := make([][]byte, len(values))
	for i, v := range values {
		b, err := pickleSerialize(v)
		if err != nil {
			return err
		}
		valuesEncoded[i] = b.Bytes()
	}

	deadline := time.Time{}
	if options.Timeout != nil {
		deadline = time.Now().Add(*options.Timeout)
	}

	delay := queueInitialPutBackoff
	ttl := options.PartitionTtl
	if ttl == 0 {
		ttl = queueDefaultPartitionTtl
	}

	for {
		_, err := client.QueuePut(q.ctx, pb.QueuePutRequest_builder{
			QueueId:             q.QueueId,
			Values:              valuesEncoded,
			PartitionKey:        key,
			PartitionTtlSeconds: int32(ttl.Seconds()),
		}.Build())
		if err == nil {
			return nil // success
		}

		if status.Code(err) != codes.ResourceExhausted {
			return err
		}

		// Queue is full, retry with exponential backoff up to the deadline.
		delay = min(delay*2, 30*time.Second)
		if !deadline.IsZero() {
			remaining := time.Until(deadline)
			if remaining <= 0 {
				return QueueFullError{fmt.Sprintf("Put failed on %s", q.QueueId)}
			}
			delay = min(delay, remaining)
		}
		select {
		case <-q.ctx.Done():
			return q.ctx.Err()
		case <-time.After(delay):
		}
	}
}

// Put adds a single item to the end of the Queue.
//
// If the Queue is full, this will retry with exponential backoff until the
// provided `timeout` is reached, or indefinitely if `timeout` is not set.
// Raises `QueueFullError` if the Queue is still full after the timeout.
func (q *Queue) Put(v any, options *QueuePutOptions) error {
	return q.put([]any{v}, options)
}

// PutMany adds multiple items to the end of the Queue.
//
// If the Queue is full, this will retry with exponential backoff until the
// provided `timeout` is reached, or indefinitely if `timeout` is not set.
// Raises `QueueFullError` if the Queue is still full after the timeout.
func (q *Queue) PutMany(values []any, options *QueuePutOptions) error {
	return q.put(values, options)
}

// Len returns the number of objects in the Queue.
func (q *Queue) Len(options *QueueLenOptions) (int, error) {
	if options == nil {
		options = &QueueLenOptions{}
	}
	if options.Partition != "" && options.Total {
		return 0, InvalidError{"partition must be empty when requesting total length"}
	}
	key, err := validatePartitionKey(options.Partition)
	if err != nil {
		return 0, err
	}
	resp, err := client.QueueLen(q.ctx, pb.QueueLenRequest_builder{
		QueueId:      q.QueueId,
		PartitionKey: key,
		Total:        options.Total,
	}.Build())
	if err != nil {
		return 0, err
	}
	return int(resp.GetLen()), nil
}

// Iterate yields items from the Queue until it is empty.
func (q *Queue) Iterate(options *QueueIterateOptions) iter.Seq2[any, error] {
	if options == nil {
		options = &QueueIterateOptions{}
	}

	itemPoll := options.ItemPollTimeout
	lastEntryID := ""
	maxPoll := 30 * time.Second

	return func(yield func(any, error) bool) {
		key, err := validatePartitionKey(options.Partition)
		if err != nil {
			yield(nil, err)
			return
		}

		fetchDeadline := time.Now().Add(itemPoll)
		for {
			pollDuration := max(0, min(maxPoll, time.Until(fetchDeadline)))
			resp, err := client.QueueNextItems(q.ctx, pb.QueueNextItemsRequest_builder{
				QueueId:         q.QueueId,
				PartitionKey:    key,
				ItemPollTimeout: float32(pollDuration.Seconds()),
				LastEntryId:     lastEntryID,
			}.Build())
			if err != nil {
				yield(nil, err)
				return
			}
			if len(resp.GetItems()) > 0 {
				for _, item := range resp.GetItems() {
					v, err := pickleDeserialize(item.GetValue())
					if err != nil {
						yield(nil, err)
						return
					}
					if !yield(v, nil) {
						return
					}
					lastEntryID = item.GetEntryId()
				}
				fetchDeadline = time.Now().Add(itemPoll)
			} else if time.Now().After(fetchDeadline) {
				return // exit on idle
			}
		}
	}
}



================================================
FILE: modal-go/retries.go
================================================
package modal

import (
	"fmt"
	"time"
)

// RetriesOptions are options for creating a Retries policy.
type RetriesOptions struct {
	BackoffCoefficient *float32       // Multiplier for exponential backoff. Defaults to 2.0.
	InitialDelay       *time.Duration // Defaults to 1s.
	MaxDelay           *time.Duration // Defaults to 60s.
}

// Retries represents retry policy configuration for a Modal Function/Cls.
type Retries struct {
	MaxRetries         int
	BackoffCoefficient float32
	InitialDelay       time.Duration
	MaxDelay           time.Duration
}

// NewRetries creates a new Retries configuration.
func NewRetries(maxRetries int, options *RetriesOptions) (*Retries, error) {
	backoffCoefficient := float32(2.0)
	initialDelay := 1 * time.Second
	maxDelay := 60 * time.Second

	if options != nil {
		if options.BackoffCoefficient != nil {
			backoffCoefficient = *options.BackoffCoefficient
		}
		if options.InitialDelay != nil {
			initialDelay = *options.InitialDelay
		}
		if options.MaxDelay != nil {
			maxDelay = *options.MaxDelay
		}
	}

	r := &Retries{
		MaxRetries:         maxRetries,
		BackoffCoefficient: backoffCoefficient,
		InitialDelay:       initialDelay,
		MaxDelay:           maxDelay,
	}

	if r.MaxRetries < 0 || r.MaxRetries > 10 {
		return nil, fmt.Errorf("invalid maxRetries: %d. Must be between 0 and 10", r.MaxRetries)
	}

	if r.BackoffCoefficient < 1.0 || r.BackoffCoefficient > 10.0 {
		return nil, fmt.Errorf("invalid backoffCoefficient: %f. Must be between 1.0 and 10.0", r.BackoffCoefficient)
	}

	if r.InitialDelay < 0 || r.InitialDelay > 60*time.Second {
		return nil, fmt.Errorf("invalid initialDelay: %v. Must be between 0 and 60s", r.InitialDelay)
	}

	if r.MaxDelay < 1*time.Second || r.MaxDelay > 60*time.Second {
		return nil, fmt.Errorf("invalid maxDelay: %v. Must be between 1s and 60s", r.MaxDelay)
	}

	return r, nil
}



================================================
FILE: modal-go/sandbox.go
================================================
package modal

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"iter"
	"sync"
	"time"

	"github.com/djherbis/buffer"
	"github.com/djherbis/nio/v3"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// StdioBehavior defines how the standard input/output/error streams should behave.
type StdioBehavior string

const (
	// Pipe allows the Sandbox to pipe the streams.
	Pipe StdioBehavior = "pipe"
	// Ignore ignores the streams, meaning they will not be available.
	Ignore StdioBehavior = "ignore"
)

// ExecOptions defines options for executing commands in a Sandbox.
type ExecOptions struct {
	// Stdout defines whether to pipe or ignore standard output.
	Stdout StdioBehavior
	// Stderr defines whether to pipe or ignore standard error.
	Stderr StdioBehavior
	// Workdir is the working directory to run the command in.
	Workdir string
	// Timeout is the timeout for command execution. Defaults to 0 (no timeout).
	Timeout time.Duration
	// Environment variables to set for the command.
	Env map[string]string
	// Secrets to inject as environment variables for the command.
	Secrets []*Secret
	// PTY defines whether to enable a PTY for the command.
	PTY bool
}

// Tunnel represents a port forwarded from within a running Modal Sandbox.
type Tunnel struct {
	Host            string // The public hostname for the tunnel
	Port            int    // The public port for the tunnel
	UnencryptedHost string // The unencrypted hostname (if applicable)
	UnencryptedPort int    // The unencrypted port (if applicable)
}

// URL gets the public HTTPS URL of the forwarded port.
func (t *Tunnel) URL() string {
	if t.Port == 443 {
		return fmt.Sprintf("https://%s", t.Host)
	}
	return fmt.Sprintf("https://%s:%d", t.Host, t.Port)
}

// TLSSocket gets the public TLS socket as a (host, port) tuple.
func (t *Tunnel) TLSSocket() (string, int) {
	return t.Host, t.Port
}

// TCPSocket gets the public TCP socket as a (host, port) tuple.
func (t *Tunnel) TCPSocket() (string, int, error) {
	if t.UnencryptedHost == "" || t.UnencryptedPort == 0 {
		return "", 0, InvalidError{Exception: "This tunnel is not configured for unencrypted TCP."}
	}
	return t.UnencryptedHost, t.UnencryptedPort, nil
}

// Sandbox represents a Modal Sandbox, which can run commands and manage
// input/output streams for a remote process.
type Sandbox struct {
	SandboxId string
	Stdin     io.WriteCloser
	Stdout    io.ReadCloser
	Stderr    io.ReadCloser

	ctx     context.Context
	taskId  string
	tunnels map[int]*Tunnel
}

func defaultSandboxPTYInfo() *pb.PTYInfo {
	return pb.PTYInfo_builder{
		Enabled:                true,
		WinszRows:              24,
		WinszCols:              80,
		EnvTerm:                "xterm-256color",
		EnvColorterm:           "truecolor",
		PtyType:                pb.PTYInfo_PTY_TYPE_SHELL,
		NoTerminateOnIdleStdin: true,
	}.Build()
}

// newSandbox creates a new Sandbox object from ID.
func newSandbox(ctx context.Context, sandboxId string) *Sandbox {
	sb := &Sandbox{SandboxId: sandboxId, ctx: ctx}
	sb.Stdin = inputStreamSb(ctx, sandboxId)
	sb.Stdout = outputStreamSb(ctx, sandboxId, pb.FileDescriptor_FILE_DESCRIPTOR_STDOUT)
	sb.Stderr = outputStreamSb(ctx, sandboxId, pb.FileDescriptor_FILE_DESCRIPTOR_STDERR)
	return sb
}

// SandboxFromId returns a running Sandbox object from an ID.
func SandboxFromId(ctx context.Context, sandboxId string) (*Sandbox, error) {
	_, err := client.SandboxWait(ctx, pb.SandboxWaitRequest_builder{
		SandboxId: sandboxId,
		Timeout:   0,
	}.Build())
	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("Sandbox with id: '%s' not found", sandboxId)}
	}
	if err != nil {
		return nil, err
	}
	return newSandbox(ctx, sandboxId), nil
}

// SandboxFromNameOptions are options for finding deployed Sandbox objects by name.
type SandboxFromNameOptions struct {
	Environment string
}

// SandboxFromName gets a running Sandbox by name from a deployed App.
//
// Raises a NotFoundError if no running Sandbox is found with the given name.
// A Sandbox's name is the `Name` argument passed to `App.CreateSandbox`.
func SandboxFromName(ctx context.Context, appName, name string, options *SandboxFromNameOptions) (*Sandbox, error) {
	if options == nil {
		options = &SandboxFromNameOptions{}
	}

	resp, err := client.SandboxGetFromName(ctx, pb.SandboxGetFromNameRequest_builder{
		SandboxName:     name,
		AppName:         appName,
		EnvironmentName: environmentName(options.Environment),
	}.Build())
	if err != nil {
		if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
			return nil, NotFoundError{Exception: fmt.Sprintf("Sandbox with name '%s' not found in pp '%s'", name, appName)}
		}
		return nil, err
	}

	return newSandbox(ctx, resp.GetSandboxId()), nil
}

// buildContainerExecRequestProto builds a ContainerExecRequest proto from command and options.
func buildContainerExecRequestProto(taskId string, command []string, opts ExecOptions, envSecret *Secret) (*pb.ContainerExecRequest, error) {
	var workdir *string
	if opts.Workdir != "" {
		workdir = &opts.Workdir
	}
	secretIds := []string{}
	for _, secret := range opts.Secrets {
		if secret != nil {
			secretIds = append(secretIds, secret.SecretId)
		}
	}
	if (len(opts.Env) > 0) != (envSecret != nil) {
		return nil, fmt.Errorf("internal error: Env and envSecret must both be provided or neither be provided")
	}
	if envSecret != nil {
		secretIds = append(secretIds, envSecret.SecretId)
	}

	var ptyInfo *pb.PTYInfo
	if opts.PTY {
		ptyInfo = defaultSandboxPTYInfo()
	}

	return pb.ContainerExecRequest_builder{
		TaskId:      taskId,
		Command:     command,
		Workdir:     workdir,
		TimeoutSecs: uint32(opts.Timeout.Seconds()),
		SecretIds:   secretIds,
		PtyInfo:     ptyInfo,
	}.Build(), nil
}

// Exec runs a command in the Sandbox and returns text streams.
func (sb *Sandbox) Exec(command []string, opts ExecOptions) (*ContainerProcess, error) {
	if err := sb.ensureTaskId(); err != nil {
		return nil, err
	}

	var envSecret *Secret
	if len(opts.Env) > 0 {
		var err error
		envSecret, err = SecretFromMap(sb.ctx, opts.Env, nil)
		if err != nil {
			return nil, err
		}
	}

	req, err := buildContainerExecRequestProto(sb.taskId, command, opts, envSecret)
	if err != nil {
		return nil, err
	}
	resp, err := client.ContainerExec(sb.ctx, req)
	if err != nil {
		return nil, err
	}
	return newContainerProcess(sb.ctx, resp.GetExecId(), opts), nil
}

// Open opens a file in the Sandbox filesystem.
// The mode parameter follows the same conventions as os.OpenFile:
// "r" for read-only, "w" for write-only (truncates), "a" for append, etc.
func (sb *Sandbox) Open(path, mode string) (*SandboxFile, error) {
	if err := sb.ensureTaskId(); err != nil {
		return nil, err
	}

	_, resp, err := runFilesystemExec(sb.ctx, pb.ContainerFilesystemExecRequest_builder{
		FileOpenRequest: pb.ContainerFileOpenRequest_builder{
			Path: path,
			Mode: mode,
		}.Build(),
		TaskId: sb.taskId,
	}.Build(), nil)

	if err != nil {
		return nil, err
	}

	return &SandboxFile{
		fileDescriptor: resp.GetFileDescriptor(),
		taskId:         sb.taskId,
		ctx:            sb.ctx,
	}, nil
}

func (sb *Sandbox) ensureTaskId() error {
	if sb.taskId == "" {
		resp, err := client.SandboxGetTaskId(sb.ctx, pb.SandboxGetTaskIdRequest_builder{
			SandboxId: sb.SandboxId,
		}.Build())
		if err != nil {
			return err
		}
		if resp.GetTaskId() == "" {
			return fmt.Errorf("Sandbox %s does not have a task ID, it may not be running", sb.SandboxId)
		}
		if resp.GetTaskResult() != nil {
			return fmt.Errorf("Sandbox %s has already completed with result: %v", sb.SandboxId, resp.GetTaskResult())
		}
		sb.taskId = resp.GetTaskId()
	}
	return nil
}

// Terminate stops the Sandbox.
func (sb *Sandbox) Terminate() error {
	_, err := client.SandboxTerminate(sb.ctx, pb.SandboxTerminateRequest_builder{
		SandboxId: sb.SandboxId,
	}.Build())
	if err != nil {
		return err
	}
	sb.taskId = ""
	return nil
}

// Wait blocks until the Sandbox exits.
func (sb *Sandbox) Wait() (int, error) {
	for {
		resp, err := client.SandboxWait(sb.ctx, pb.SandboxWaitRequest_builder{
			SandboxId: sb.SandboxId,
			Timeout:   10,
		}.Build())
		if err != nil {
			return 0, err
		}
		if resp.GetResult() != nil {
			returnCode := getReturnCode(resp.GetResult())
			if returnCode != nil {
				return *returnCode, nil
			}
			return 0, nil
		}
	}
}

// Tunnels gets Tunnel metadata for the Sandbox.
// Returns SandboxTimeoutError if the tunnels are not available after the timeout.
// Returns a map of Tunnel objects keyed by the container port.
func (sb *Sandbox) Tunnels(timeout time.Duration) (map[int]*Tunnel, error) {
	if sb.tunnels != nil {
		return sb.tunnels, nil
	}

	resp, err := client.SandboxGetTunnels(sb.ctx, pb.SandboxGetTunnelsRequest_builder{
		SandboxId: sb.SandboxId,
		Timeout:   float32(timeout.Seconds()),
	}.Build())
	if err != nil {
		return nil, err
	}

	if resp.GetResult() != nil && resp.GetResult().GetStatus() == pb.GenericResult_GENERIC_STATUS_TIMEOUT {
		return nil, SandboxTimeoutError{Exception: "Sandbox operation timed out"}
	}

	sb.tunnels = make(map[int]*Tunnel)
	for _, t := range resp.GetTunnels() {
		sb.tunnels[int(t.GetContainerPort())] = &Tunnel{
			Host:            t.GetHost(),
			Port:            int(t.GetPort()),
			UnencryptedHost: t.GetUnencryptedHost(),
			UnencryptedPort: int(t.GetUnencryptedPort()),
		}
	}

	return sb.tunnels, nil
}

// SnapshotFilesystem takes a snapshot of the Sandbox's filesystem.
// Returns an Image object which can be used to spawn a new Sandbox with the same filesystem.
func (sb *Sandbox) SnapshotFilesystem(timeout time.Duration) (*Image, error) {
	resp, err := client.SandboxSnapshotFs(sb.ctx, pb.SandboxSnapshotFsRequest_builder{
		SandboxId: sb.SandboxId,
		Timeout:   float32(timeout.Seconds()),
	}.Build())
	if err != nil {
		return nil, err
	}

	if resp.GetResult() != nil && resp.GetResult().GetStatus() != pb.GenericResult_GENERIC_STATUS_SUCCESS {
		return nil, ExecutionError{Exception: fmt.Sprintf("Sandbox snapshot failed: %s", resp.GetResult().GetException())}
	}

	if resp.GetImageId() == "" {
		return nil, ExecutionError{Exception: "Sandbox snapshot response missing image ID"}
	}

	return &Image{ImageId: resp.GetImageId(), ctx: sb.ctx}, nil
}

// Poll checks if the Sandbox has finished running.
// Returns nil if the Sandbox is still running, else returns the exit code.
func (sb *Sandbox) Poll() (*int, error) {
	resp, err := client.SandboxWait(sb.ctx, pb.SandboxWaitRequest_builder{
		SandboxId: sb.SandboxId,
		Timeout:   0,
	}.Build())
	if err != nil {
		return nil, err
	}

	return getReturnCode(resp.GetResult()), nil
}

// SetTags sets key-value tags on the Sandbox. Tags can be used to filter results in SandboxList.
func (sb *Sandbox) SetTags(tags map[string]string) error {
	tagsList := make([]*pb.SandboxTag, 0, len(tags))
	for k, v := range tags {
		tagsList = append(tagsList, pb.SandboxTag_builder{TagName: k, TagValue: v}.Build())
	}
	_, err := client.SandboxTagsSet(sb.ctx, pb.SandboxTagsSetRequest_builder{
		EnvironmentName: environmentName(""),
		SandboxId:       sb.SandboxId,
		Tags:            tagsList,
	}.Build())
	return err
}

// GetTags fetches any tags (key-value pairs) currently attached to this Sandbox from the server.
func (sb *Sandbox) GetTags() (map[string]string, error) {
	resp, err := client.SandboxTagsGet(sb.ctx, pb.SandboxTagsGetRequest_builder{
		SandboxId: sb.SandboxId,
	}.Build())
	if err != nil {
		if status, ok := status.FromError(err); ok && status.Code() == codes.InvalidArgument {
			return nil, InvalidError{Exception: status.Message()}
		}
		return nil, err
	}

	tags := make(map[string]string, len(resp.GetTags()))
	for _, tag := range resp.GetTags() {
		tags[tag.GetTagName()] = tag.GetTagValue()
	}
	return tags, nil
}

// SandboxListOptions are options for listing Sandboxes.
type SandboxListOptions struct {
	AppId       string            // Filter by App ID
	Tags        map[string]string // Only include Sandboxes that have all these tags
	Environment string            // Override environment for this request
}

// SandboxList lists Sandboxes for the current environment (or provided App ID), optionally filtered by tags.
func SandboxList(ctx context.Context, options *SandboxListOptions) (iter.Seq2[*Sandbox, error], error) {
	if options == nil {
		options = &SandboxListOptions{}
	}

	tagsList := make([]*pb.SandboxTag, 0, len(options.Tags))
	for k, v := range options.Tags {
		tagsList = append(tagsList, pb.SandboxTag_builder{TagName: k, TagValue: v}.Build())
	}

	return func(yield func(*Sandbox, error) bool) {
		var before float64
		for {
			resp, err := client.SandboxList(ctx, pb.SandboxListRequest_builder{
				AppId:           options.AppId,
				BeforeTimestamp: before,
				EnvironmentName: environmentName(options.Environment),
				IncludeFinished: false,
				Tags:            tagsList,
			}.Build())
			if err != nil {
				yield(nil, err)
				return
			}
			sandboxes := resp.GetSandboxes()
			if len(sandboxes) == 0 {
				return
			}
			for _, info := range sandboxes {
				if !yield(newSandbox(ctx, info.GetId()), nil) {
					return
				}
			}
			before = sandboxes[len(sandboxes)-1].GetCreatedAt()
		}
	}, nil
}

func getReturnCode(result *pb.GenericResult) *int {
	if result == nil || result.GetStatus() == pb.GenericResult_GENERIC_STATUS_UNSPECIFIED {
		return nil
	}

	// Statuses are converted to exitcodes so we can conform to subprocess API.
	var exitCode int
	switch result.GetStatus() {
	case pb.GenericResult_GENERIC_STATUS_TIMEOUT:
		exitCode = 124
	case pb.GenericResult_GENERIC_STATUS_TERMINATED:
		exitCode = 137
	default:
		exitCode = int(result.GetExitcode())
	}

	return &exitCode
}

// ContainerProcess represents a process running in a Modal container, allowing
// interaction with its standard input/output/error streams.
//
// It is created by executing a command in a Sandbox.
type ContainerProcess struct {
	Stdin  io.WriteCloser
	Stdout io.ReadCloser
	Stderr io.ReadCloser

	ctx    context.Context
	execId string
}

func newContainerProcess(ctx context.Context, execId string, opts ExecOptions) *ContainerProcess {
	stdoutBehavior := Pipe
	stderrBehavior := Pipe
	if opts.Stdout != "" {
		stdoutBehavior = opts.Stdout
	}
	if opts.Stderr != "" {
		stderrBehavior = opts.Stderr
	}

	cp := &ContainerProcess{execId: execId, ctx: ctx}
	cp.Stdin = inputStreamCp(ctx, execId)

	cp.Stdout = outputStreamCp(ctx, execId, pb.FileDescriptor_FILE_DESCRIPTOR_STDOUT)
	if stdoutBehavior == Ignore {
		cp.Stdout.Close()
		cp.Stdout = io.NopCloser(bytes.NewReader(nil))
	}
	cp.Stderr = outputStreamCp(ctx, execId, pb.FileDescriptor_FILE_DESCRIPTOR_STDERR)
	if stderrBehavior == Ignore {
		cp.Stderr.Close()
		cp.Stderr = io.NopCloser(bytes.NewReader(nil))
	}

	return cp
}

// Wait blocks until the container process exits and returns its exit code.
func (cp *ContainerProcess) Wait() (int, error) {
	for {
		resp, err := client.ContainerExecWait(cp.ctx, pb.ContainerExecWaitRequest_builder{
			ExecId:  cp.execId,
			Timeout: 55,
		}.Build())
		if err != nil {
			return 0, err
		}
		if resp.GetCompleted() {
			return int(resp.GetExitCode()), nil
		}
	}
}

func inputStreamSb(ctx context.Context, sandboxId string) io.WriteCloser {
	return &sbStdin{sandboxId: sandboxId, ctx: ctx, index: 1}
}

type sbStdin struct {
	sandboxId string
	ctx       context.Context

	mu    sync.Mutex // protects index
	index uint32
}

func (s *sbStdin) Write(p []byte) (n int, err error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	index := s.index
	s.index++
	_, err = client.SandboxStdinWrite(s.ctx, pb.SandboxStdinWriteRequest_builder{
		SandboxId: s.sandboxId,
		Input:     p,
		Index:     index,
	}.Build())
	if err != nil {
		return 0, err
	}
	return len(p), nil
}

func (s *sbStdin) Close() error {
	s.mu.Lock()
	defer s.mu.Unlock()
	_, err := client.SandboxStdinWrite(s.ctx, pb.SandboxStdinWriteRequest_builder{
		SandboxId: s.sandboxId,
		Index:     s.index,
		Eof:       true,
	}.Build())
	return err
}

func inputStreamCp(ctx context.Context, execId string) io.WriteCloser {
	return &cpStdin{execId: execId, messageIndex: 1, ctx: ctx}
}

type cpStdin struct {
	execId       string
	messageIndex uint64
	ctx          context.Context // context for the exec operations
}

func (c *cpStdin) Write(p []byte) (n int, err error) {
	_, err = client.ContainerExecPutInput(c.ctx, pb.ContainerExecPutInputRequest_builder{
		ExecId: c.execId,
		Input: pb.RuntimeInputMessage_builder{
			Message:      p,
			MessageIndex: c.messageIndex,
		}.Build(),
	}.Build())
	if err != nil {
		return 0, err
	}
	c.messageIndex++
	return len(p), nil
}

func (c *cpStdin) Close() error {
	_, err := client.ContainerExecPutInput(c.ctx, pb.ContainerExecPutInputRequest_builder{
		ExecId: c.execId,
		Input: pb.RuntimeInputMessage_builder{
			MessageIndex: c.messageIndex,
			Eof:          true,
		}.Build(),
	}.Build())
	return err
}

func outputStreamSb(ctx context.Context, sandboxId string, fd pb.FileDescriptor) io.ReadCloser {
	pr, pw := nio.Pipe(buffer.New(64 * 1024))
	go func() {
		defer pw.Close()
		lastIndex := "0-0"
		completed := false
		retries := 10
		for !completed {
			stream, err := client.SandboxGetLogs(ctx, pb.SandboxGetLogsRequest_builder{
				SandboxId:      sandboxId,
				FileDescriptor: fd,
				Timeout:        55,
				LastEntryId:    lastIndex,
			}.Build())
			if err != nil {
				if isRetryableGrpc(err) && retries > 0 {
					retries--
					continue
				}
				pw.CloseWithError(fmt.Errorf("error getting output stream: %w", err))
				return
			}
			for {
				batch, err := stream.Recv()
				if err != nil {
					if err != io.EOF {
						if isRetryableGrpc(err) && retries > 0 {
							retries--
						} else {
							pw.CloseWithError(fmt.Errorf("error getting output stream: %w", err))
							return
						}
					}
					break // we need to retry, either from an EOF or gRPC error
				}
				lastIndex = batch.GetEntryId()
				for _, item := range batch.GetItems() {
					// On error, writer has been closed. Still consume the rest of the channel.
					pw.Write([]byte(item.GetData()))
				}
				if batch.GetEof() {
					completed = true
					break
				}
			}
		}
	}()
	return pr
}

func outputStreamCp(ctx context.Context, execId string, fd pb.FileDescriptor) io.ReadCloser {
	pr, pw := nio.Pipe(buffer.New(64 * 1024))
	go func() {
		defer pw.Close()
		var lastIndex uint64
		completed := false
		retries := 10
		for !completed {
			stream, err := client.ContainerExecGetOutput(ctx, pb.ContainerExecGetOutputRequest_builder{
				ExecId:         execId,
				FileDescriptor: fd,
				Timeout:        55,
				GetRawBytes:    true,
				LastBatchIndex: lastIndex,
			}.Build())
			if err != nil {
				if isRetryableGrpc(err) && retries > 0 {
					retries--
					continue
				}
				pw.CloseWithError(fmt.Errorf("error getting output stream: %w", err))
				return
			}
			for {
				batch, err := stream.Recv()
				if err != nil {
					if err != io.EOF {
						if isRetryableGrpc(err) && retries > 0 {
							retries--
						} else {
							pw.CloseWithError(fmt.Errorf("error getting output stream: %w", err))
							return
						}
					}
					break // we need to retry, either from an EOF or gRPC error
				}
				lastIndex = batch.GetBatchIndex()
				for _, item := range batch.GetItems() {
					// On error, writer has been closed. Still consume the rest of the channel.
					pw.Write(item.GetMessageBytes())
				}
				if batch.HasExitCode() {
					completed = true
					break
				}
			}
		}
	}()
	return pr
}



================================================
FILE: modal-go/sandbox_filesystem.go
================================================
package modal

import (
	"context"
	"io"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// SandboxFile represents an open file in the Sandbox filesystem.
// It implements io.Reader, io.Writer, io.Seeker, and io.Closer interfaces.
type SandboxFile struct {
	fileDescriptor string
	taskId         string
	ctx            context.Context
}

// Read reads up to len(p) bytes from the file into p.
// It returns the number of bytes read and any error encountered.
func (f *SandboxFile) Read(p []byte) (int, error) {
	nBytes := uint32(len(p))
	totalRead, _, err := runFilesystemExec(f.ctx, pb.ContainerFilesystemExecRequest_builder{
		FileReadRequest: pb.ContainerFileReadRequest_builder{
			FileDescriptor: f.fileDescriptor,
			N:              &nBytes,
		}.Build(),
		TaskId: f.taskId,
	}.Build(), p)
	if err != nil {
		return 0, err
	}
	if totalRead < int(nBytes) {
		return totalRead, io.EOF
	}
	return totalRead, nil
}

// Write writes len(p) bytes from p to the file.
// It returns the number of bytes written and any error encountered.
func (f *SandboxFile) Write(p []byte) (n int, err error) {
	_, _, err = runFilesystemExec(f.ctx, pb.ContainerFilesystemExecRequest_builder{
		FileWriteRequest: pb.ContainerFileWriteRequest_builder{
			FileDescriptor: f.fileDescriptor,
			Data:           p,
		}.Build(),
		TaskId: f.taskId,
	}.Build(), nil)
	if err != nil {
		return 0, err
	}
	return len(p), nil
}

// Flush flushes any buffered data to the file.
func (f *SandboxFile) Flush() error {
	_, _, err := runFilesystemExec(f.ctx, pb.ContainerFilesystemExecRequest_builder{
		FileFlushRequest: pb.ContainerFileFlushRequest_builder{
			FileDescriptor: f.fileDescriptor,
		}.Build(),
		TaskId: f.taskId,
	}.Build(), nil)
	if err != nil {
		return err
	}
	return nil
}

// Close closes the file, rendering it unusable for I/O.
func (f *SandboxFile) Close() error {
	_, _, err := runFilesystemExec(f.ctx, pb.ContainerFilesystemExecRequest_builder{
		FileCloseRequest: pb.ContainerFileCloseRequest_builder{
			FileDescriptor: f.fileDescriptor,
		}.Build(),
		TaskId: f.taskId,
	}.Build(), nil)
	if err != nil {
		return err
	}
	return nil
}

func runFilesystemExec(ctx context.Context, req *pb.ContainerFilesystemExecRequest, p []byte) (int, *pb.ContainerFilesystemExecResponse, error) {
	resp, err := client.ContainerFilesystemExec(ctx, req)
	if err != nil {
		return 0, nil, err
	}
	retries := 10
	totalRead := 0

	for {
		outputIterator, err := client.ContainerFilesystemExecGetOutput(ctx, pb.ContainerFilesystemExecGetOutputRequest_builder{
			ExecId:  resp.GetExecId(),
			Timeout: 55,
		}.Build())
		if err != nil {
			if isRetryableGrpc(err) && retries > 0 {
				retries--
				continue
			}
			return 0, nil, err
		}

		for {
			batch, err := outputIterator.Recv()
			if err == io.EOF {
				break
			}
			if err != nil {
				if isRetryableGrpc(err) && retries > 0 {
					retries--
					break
				}
				return 0, nil, err
			}
			if batch.GetError() != nil {
				return 0, nil, SandboxFilesystemError{batch.GetError().GetErrorMessage()}
			}

			for _, chunk := range batch.GetOutput() {
				copyLen := copy(p[totalRead:], chunk)
				totalRead += copyLen
			}

			if batch.GetEof() {
				return totalRead, resp, nil
			}
		}
	}
}



================================================
FILE: modal-go/sandbox_test.go
================================================
package modal

import (
	"context"
	"testing"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/onsi/gomega"
)

func TestContainerExecProto_WithoutPTY(t *testing.T) {
	g := gomega.NewWithT(t)
	req, err := buildContainerExecRequestProto("task-123", []string{"bash"}, ExecOptions{}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	ptyInfo := req.GetPtyInfo()
	g.Expect(ptyInfo).Should(gomega.BeNil())
}

func TestContainerExecProto_WithPTY(t *testing.T) {
	g := gomega.NewWithT(t)
	req, err := buildContainerExecRequestProto("task-123", []string{"bash"}, ExecOptions{
		PTY: true,
	}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	ptyInfo := req.GetPtyInfo()
	g.Expect(ptyInfo).ShouldNot(gomega.BeNil())
	g.Expect(ptyInfo.GetEnabled()).To(gomega.BeTrue())
	g.Expect(ptyInfo.GetWinszRows()).To(gomega.Equal(uint32(24)))
	g.Expect(ptyInfo.GetWinszCols()).To(gomega.Equal(uint32(80)))
	g.Expect(ptyInfo.GetEnvTerm()).To(gomega.Equal("xterm-256color"))
	g.Expect(ptyInfo.GetEnvColorterm()).To(gomega.Equal("truecolor"))
	g.Expect(ptyInfo.GetPtyType()).To(gomega.Equal(pb.PTYInfo_PTY_TYPE_SHELL))
	g.Expect(ptyInfo.GetNoTerminateOnIdleStdin()).To(gomega.BeTrue())
}

func TestContainerExecRequestProto_MergesEnvAndSecrets(t *testing.T) {
	g := gomega.NewWithT(t)

	secretEnvVars := map[string]string{"A": "1"}
	secret, err := SecretFromMap(context.Background(), secretEnvVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	envVars := map[string]string{"B": "2"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = buildContainerExecRequestProto("ta", []string{"echo", "hello"}, ExecOptions{
		Env: envVars,
	}, nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: Env and envSecret must both be provided or neither be provided"))

	_, err = buildContainerExecRequestProto("ta", []string{"echo", "hello"}, ExecOptions{}, envSecret)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("internal error: Env and envSecret must both be provided or neither be provided"))

	req, err := buildContainerExecRequestProto("ta", []string{"echo", "hello"}, ExecOptions{
		Env:     envVars,
		Secrets: []*Secret{secret},
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(req.GetSecretIds()).To(gomega.HaveLen(2))
	g.Expect(req.GetSecretIds()).To(gomega.ContainElement(secret.SecretId))
	g.Expect(req.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
}

func TestContainerExecRequestProto_WithOnlyEnvParameter(t *testing.T) {
	g := gomega.NewWithT(t)

	envVars := map[string]string{"B": "2"}
	envSecret, err := SecretFromMap(context.Background(), envVars, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	req, err := buildContainerExecRequestProto("ta", []string{"echo", "hello"}, ExecOptions{
		Env: envVars,
	}, envSecret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(req.GetSecretIds()).To(gomega.HaveLen(1))
	g.Expect(req.GetSecretIds()).To(gomega.ContainElement(envSecret.SecretId))
}



================================================
FILE: modal-go/secret.go
================================================
package modal

import (
	"context"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// Secret represents a Modal Secret.
type Secret struct {
	SecretId string
	Name     string

	//lint:ignore U1000 may be used in future
	ctx context.Context
}

// SecretFromNameOptions are options for finding Modal Secrets.
type SecretFromNameOptions struct {
	Environment  string
	RequiredKeys []string
}

// SecretFromName references a modal.Secret by its name.
func SecretFromName(ctx context.Context, name string, options *SecretFromNameOptions) (*Secret, error) {
	if options == nil {
		options = &SecretFromNameOptions{}
	}

	resp, err := client.SecretGetOrCreate(ctx, pb.SecretGetOrCreateRequest_builder{
		DeploymentName:  name,
		EnvironmentName: environmentName(options.Environment),
		RequiredKeys:    options.RequiredKeys,
	}.Build())

	if err != nil {
		return nil, err
	}

	return &Secret{SecretId: resp.GetSecretId(), Name: name}, nil
}

// SecretFromMapOptions are options for creating a Secret from a key/value map.
type SecretFromMapOptions struct {
	Environment string
}

// SecretFromMap creates a Secret from a map of key-value pairs.
func SecretFromMap(ctx context.Context, keyValuePairs map[string]string, options *SecretFromMapOptions) (*Secret, error) {
	if options == nil {
		options = &SecretFromMapOptions{}
	}

	resp, err := client.SecretGetOrCreate(ctx, pb.SecretGetOrCreateRequest_builder{
		ObjectCreationType: pb.ObjectCreationType_OBJECT_CREATION_TYPE_EPHEMERAL,
		EnvDict:            keyValuePairs,
		EnvironmentName:    environmentName(options.Environment),
	}.Build())
	if err != nil {
		return nil, err
	}
	return &Secret{SecretId: resp.GetSecretId()}, nil
}



================================================
FILE: modal-go/serialization_test.go
================================================
package modal

// Test to make sure serialization behaviors are consistent.

import (
	"testing"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/onsi/gomega"
)

// Reproduce serialization test from the Python SDK.
// https://github.com/modal-labs/modal-client/blob/4c62d67ee2816146a2a5d42581f6fe7349fa1bf6/test/serialization_test.py
func TestParameterSerialization(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	schema := []*pb.ClassParameterSpec{
		pb.ClassParameterSpec_builder{Name: "foo", Type: pb.ParameterType_PARAM_TYPE_STRING}.Build(),
		pb.ClassParameterSpec_builder{Name: "i", Type: pb.ParameterType_PARAM_TYPE_INT}.Build(),
	}
	values := map[string]any{"i": 5, "foo": "bar"}

	serializedParams, err := encodeParameterSet(schema, values)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	byteData := []byte("\n\x0c\n\x03foo\x10\x01\x1a\x03bar\n\x07\n\x01i\x10\x02 \x05")
	g.Expect(serializedParams).Should(gomega.Equal(byteData))

	// Reverse the order of map keys and make sure it's deterministic.
	schema = []*pb.ClassParameterSpec{schema[1], schema[0]}
	serializedParams, err = encodeParameterSet(schema, values)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(serializedParams).Should(gomega.Equal(byteData))

	// Test with a parameter that has a default value.
	schema = []*pb.ClassParameterSpec{
		pb.ClassParameterSpec_builder{
			Name:         "x",
			Type:         pb.ParameterType_PARAM_TYPE_BYTES,
			HasDefault:   true,
			BytesDefault: []byte("\x00"),
		}.Build(),
	}
	serializedParams, err = encodeParameterSet(schema, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	byteData = []byte("\n\x08\n\x01x\x10\x042\x01\x00")
	g.Expect(serializedParams).Should(gomega.Equal(byteData))
}



================================================
FILE: modal-go/volume.go
================================================
package modal

import (
	"context"
	"fmt"

	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// Volume represents a Modal Volume that provides persistent storage.
type Volume struct {
	VolumeId string
	Name     string
	readOnly bool
	cancel   context.CancelFunc
	ctx      context.Context
}

// VolumeFromNameOptions are options for finding Modal Volumes.
type VolumeFromNameOptions struct {
	Environment     string
	CreateIfMissing bool
}

// VolumeFromName references a modal.Volume by its name.
func VolumeFromName(ctx context.Context, name string, options *VolumeFromNameOptions) (*Volume, error) {
	if options == nil {
		options = &VolumeFromNameOptions{}
	}

	creationType := pb.ObjectCreationType_OBJECT_CREATION_TYPE_UNSPECIFIED
	if options.CreateIfMissing {
		creationType = pb.ObjectCreationType_OBJECT_CREATION_TYPE_CREATE_IF_MISSING
	}

	resp, err := client.VolumeGetOrCreate(ctx, pb.VolumeGetOrCreateRequest_builder{
		DeploymentName:     name,
		EnvironmentName:    environmentName(options.Environment),
		ObjectCreationType: creationType,
	}.Build())

	if status, ok := status.FromError(err); ok && status.Code() == codes.NotFound {
		return nil, NotFoundError{fmt.Sprintf("Volume '%s' not found", name)}
	}
	if err != nil {
		return nil, err
	}

	return &Volume{VolumeId: resp.GetVolumeId(), Name: name, readOnly: false, cancel: nil, ctx: ctx}, nil
}

// ReadOnly configures Volume to mount as read-only.
func (v *Volume) ReadOnly() *Volume {
	return &Volume{
		VolumeId: v.VolumeId,
		Name:     v.Name,
		readOnly: true,
		cancel:   v.cancel,
		ctx:      v.ctx,
	}
}

// IsReadOnly returns true if the Volume is configured to mount as read-only.
func (v *Volume) IsReadOnly() bool {
	return v.readOnly
}

// VolumeEphemeral creates a nameless, temporary Volume, that persists until CloseEphemeral is called, or the process exits.
func VolumeEphemeral(ctx context.Context, options *EphemeralOptions) (*Volume, error) {
	if options == nil {
		options = &EphemeralOptions{}
	}

	resp, err := client.VolumeGetOrCreate(ctx, pb.VolumeGetOrCreateRequest_builder{
		ObjectCreationType: pb.ObjectCreationType_OBJECT_CREATION_TYPE_EPHEMERAL,
		EnvironmentName:    environmentName(options.Environment),
	}.Build())
	if err != nil {
		return nil, err
	}

	ephemeralCtx, cancel := context.WithCancel(ctx)
	startEphemeralHeartbeat(ephemeralCtx, func() error {
		_, err := client.VolumeHeartbeat(ephemeralCtx, pb.VolumeHeartbeatRequest_builder{
			VolumeId: resp.GetVolumeId(),
		}.Build())
		return err
	})

	return &Volume{
		VolumeId: resp.GetVolumeId(),
		readOnly: false,
		cancel:   cancel,
		ctx:      ephemeralCtx,
	}, nil
}

// CloseEphemeral deletes an ephemeral Volume, only used with VolumeEphemeral.
func (v *Volume) CloseEphemeral() {
	if v.cancel != nil {
		v.cancel()
	} else {
		// We panic in this case because of invalid usage. In general, methods
		// used with `defer` like CloseEphemeral should not return errors.
		panic(fmt.Sprintf("Volume %s is not ephemeral", v.VolumeId))
	}
}



================================================
FILE: modal-go/.golangci.toml
================================================
version = "2"

[linters]
disable = ["errcheck"]

[formatters]
enable = ["gofmt", "goimports"]



================================================
FILE: modal-go/examples/cls-call/main.go
================================================
// This example calls a Modal Cls defined in `libmodal_test_support.py`.

package main

import (
	"context"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	// Lookup a deployed Cls.
	cls, err := modal.ClsLookup(ctx, "libmodal-test-support", "EchoCls", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Cls: %v", err)
	}

	instance, err := cls.Instance(nil)
	if err != nil {
		log.Fatalf("Failed to create Cls instance: %v", err)
	}

	function, err := instance.Method("echo_string")
	if err != nil {
		log.Fatalf("Failed to access Cls method: %v", err)
	}

	// Call the Cls function with args.
	result, err := function.Remote([]any{"Hello world!"}, nil)
	if err != nil {
		log.Fatalf("Failed to call Cls method: %v", err)
	}
	log.Println("Response:", result)

	// Call the Cls function with kwargs.
	result, err = function.Remote(nil, map[string]any{"s": "Hello world!"})
	if err != nil {
		log.Fatalf("Failed to call Cls method: %v", err)
	}
	log.Println("Response:", result)
}



================================================
FILE: modal-go/examples/cls-call-with-options/main.go
================================================
// This example calls a Modal Cls defined in `libmodal_test_support.py`,
// and overrides the default options.

package main

import (
	"context"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	cls, err := modal.ClsLookup(ctx, "libmodal-test-support", "EchoClsParametrized", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Cls: %v", err)
	}

	instance, err := cls.Instance(nil)
	if err != nil {
		log.Fatalf("Failed to create Cls instance: %v", err)
	}

	method, err := instance.Method("echo_env_var")
	if err != nil {
		log.Fatalf("Failed to access Cls method: %v", err)
	}

	secret, err := modal.SecretFromMap(ctx, map[string]string{
		"SECRET_MESSAGE": "hello, Secret",
	}, nil)
	if err != nil {
		log.Fatalf("Failed to create Secret: %v", err)
	}

	instanceWithOptions, err := cls.
		WithOptions(modal.ClsOptions{
			Secrets: []*modal.Secret{secret},
		}).
		WithConcurrency(modal.ClsConcurrencyOptions{MaxInputs: 1}).
		Instance(nil)
	if err != nil {
		log.Fatalf("Failed to create Cls instance with options: %v", err)
	}

	methodWithOptions, err := instanceWithOptions.Method("echo_env_var")
	if err != nil {
		log.Fatalf("Failed to access Cls method with options: %v", err)
	}

	// Call the Cls function, without the Secret being set.
	result, err := method.Remote([]any{"SECRET_MESSAGE"}, nil)
	if err != nil {
		log.Fatalf("Failed to call Cls method: %v", err)
	}
	log.Println(result)

	// Call the Cls function with overrides, and confirm that the Secret is set.
	result, err = methodWithOptions.Remote([]any{"SECRET_MESSAGE"}, nil)
	if err != nil {
		log.Fatalf("Failed to call Cls method with options: %v", err)
	}
	log.Println(result)
}



================================================
FILE: modal-go/examples/function-call/main.go
================================================
// This example calls a function defined in `libmodal_test_support.py`.

package main

import (
	"context"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	echo, err := modal.FunctionLookup(ctx, "libmodal-test-support", "echo_string", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Function: %v", err)
	}

	ret, err := echo.Remote([]any{"Hello world!"}, nil)
	if err != nil {
		log.Fatalf("Failed to call Function: %v", err)
	}
	log.Println("Response:", ret)

	ret, err = echo.Remote(nil, map[string]any{"s": "Hello world!"})
	if err != nil {
		log.Fatalf("Failed to call Function with kwargs: %v", err)
	}
	log.Println("Response:", ret)
}



================================================
FILE: modal-go/examples/function-current-stats/main.go
================================================
// Demonstrates how to get current statistics for a Modal Function.

package main

import (
	"context"
	"fmt"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	function, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "echo_string", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Function: %v", err)
	}

	stats, err := function.GetCurrentStats()
	if err != nil {
		log.Fatalf("Failed to get Function stats: %v", err)
	}

	fmt.Println("Function Statistics:")
	fmt.Printf("  Backlog: %d inputs\n", stats.Backlog)
	fmt.Printf("  Total Runners: %d containers\n", stats.NumTotalRunners)
}



================================================
FILE: modal-go/examples/function-spawn/main.go
================================================
// This example spawns a Function defined in `libmodal_test_support.py`, and
// later gets its outputs.

package main

import (
	"context"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	echo, err := modal.FunctionLookup(ctx, "libmodal-test-support", "echo_string", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Function: %v", err)
	}

	fc, err := echo.Spawn(nil, map[string]any{"s": "Hello world!"})
	if err != nil {
		log.Fatalf("Failed to spawn Function: %v", err)
	}

	ret, err := fc.Get(nil)
	if err != nil {
		log.Fatalf("Failed to get Function results: %v", err)
	}
	log.Println("Response:", ret)
}



================================================
FILE: modal-go/examples/image-building/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatal(err)
	}

	secret, err := modal.SecretFromMap(ctx, map[string]string{
		"CURL_VERSION": "8.12.1-r1",
	}, nil)
	if err != nil {
		log.Fatal(err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil).
		DockerfileCommands([]string{"RUN apk add --no-cache curl=$CURL_VERSION"}, &modal.ImageDockerfileCommandsOptions{
			Secrets: []*modal.Secret{secret},
		}).
		DockerfileCommands([]string{"ENV SERVER=ipconfig.me"}, nil)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-c", "curl -Ls $SERVER"},
	})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Created Sandbox with ID:", sb.SandboxId)

	output, err := io.ReadAll(sb.Stdout)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Sandbox output:", string(output))

	err = sb.Terminate()
	if err != nil {
		log.Fatal(err)
	}
}



================================================
FILE: modal-go/examples/init-client/main.go
================================================
// This example configures a client using a `CUSTOM_MODAL_ID` and `CUSTOM_MODAL_SECRET` environment variable.

package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	modal_id := os.Getenv("CUSTOM_MODAL_ID")
	if modal_id == "" {
		log.Fatal("CUSTOM_MODAL_ID environment variable not set")
	}
	modal_secret := os.Getenv("CUSTOM_MODAL_SECRET")
	if modal_secret == "" {
		log.Fatal("CUSTOM_MODAL_SECRET environment variable not set")
	}

	modal.InitializeClient(modal.ClientOptions{
		TokenId:     modal_id,
		TokenSecret: modal_secret,
	})

	echo, err := modal.FunctionLookup(ctx, "libmodal-test-support", "echo_string", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Function: %v", err)
	}
	fmt.Printf("%#v\n", echo)
}



================================================
FILE: modal-go/examples/sandbox/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"cat"},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("sandbox: %s\n", sb.SandboxId)

	sbFromId, err := modal.SandboxFromId(ctx, sb.SandboxId)
	if err != nil {
		log.Fatalf("Failed to get Sandbox with ID: %v", err)
	}
	log.Printf("Queried Sandbox with ID: %v", sbFromId.SandboxId)

	_, err = sb.Stdin.Write([]byte("this is input that should be mirrored by cat"))
	if err != nil {
		log.Fatalf("Failed to write to Sandbox stdin: %v", err)
	}
	err = sb.Stdin.Close()
	if err != nil {
		log.Fatalf("Failed to close Sandbox stdin: %v", err)
	}

	output, err := io.ReadAll(sb.Stdout)
	if err != nil {
		log.Fatalf("Failed to read from Sandbox stdout: %v", err)
	}

	log.Printf("output: %s\n", string(output))
}



================================================
FILE: modal-go/examples/sandbox-agent/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}
	image := modal.NewImageFromRegistry("alpine:3.21", nil).DockerfileCommands([]string{
		"RUN apk add --no-cache bash curl git libgcc libstdc++ ripgrep",
		"RUN curl -fsSL https://claude.ai/install.sh | bash",
		"ENV PATH=/root/.local/bin:$PATH USE_BUILTIN_RIPGREP=0",
	}, nil)

	sb, err := app.CreateSandbox(image, nil)
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	fmt.Println("Started Sandbox:", sb.SandboxId)

	defer func() {
		if err := sb.Terminate(); err != nil {
			log.Printf("Failed to terminate Sandbox: %v", err)
		}
	}()

	repoUrl := "https://github.com/modal-labs/libmodal"
	git, err := sb.Exec([]string{"git", "clone", repoUrl, "/repo"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to execute git clone: %v", err)
	}
	_, err = git.Wait()
	if err != nil {
		log.Fatalf("Git clone failed: %v", err)
	}
	fmt.Printf("Cloned '%s' into /repo.\n", repoUrl)

	claudeCmd := []string{
		"claude",
		"-p",
		"Summarize what this repository is about. Don't modify any code or files.",
	}
	fmt.Println("\nRunning command:", claudeCmd)

	secret, err := modal.SecretFromName(ctx, "libmodal-anthropic-secret", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"ANTHROPIC_API_KEY"},
	})
	if err != nil {
		log.Fatalf("Failed to get secret: %v", err)
	}

	claude, err := sb.Exec(claudeCmd, modal.ExecOptions{
		PTY:     true, // Adding a PTY is important, since Claude requires it!
		Secrets: []*modal.Secret{secret},
		Workdir: "/repo",
		Stdout:  modal.Pipe,
		Stderr:  modal.Pipe,
	})
	if err != nil {
		log.Fatalf("Failed to execute claude command: %v", err)
	}
	_, err = claude.Wait()
	if err != nil {
		log.Fatalf("Claude command failed: %v", err)
	}

	fmt.Printf("\nAgent stdout:\n\n")
	stdout, err := io.ReadAll(claude.Stdout)
	if err != nil {
		log.Fatalf("Failed to read stdout: %v", err)
	}
	fmt.Print(string(stdout))

	stderr, err := io.ReadAll(claude.Stderr)
	if err != nil {
		log.Fatalf("Failed to read stderr: %v", err)
	}
	if len(stderr) > 0 {
		fmt.Println("Agent stderr:", string(stderr))
	}
}



================================================
FILE: modal-go/examples/sandbox-cloud-bucket/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	secret, err := modal.SecretFromName(ctx, "libmodal-aws-bucket-secret", nil)
	if err != nil {
		log.Fatalf("Failed to lookup Secret: %v", err)
	}

	keyPrefix := "data/"
	cloudBucketMount, err := modal.NewCloudBucketMount("my-s3-bucket", &modal.CloudBucketMountOptions{
		Secret:    secret,
		KeyPrefix: &keyPrefix,
		ReadOnly:  true,
	})
	if err != nil {
		log.Fatalf("Failed to create Cloud Bucket Mount: %v", err)
	}

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-c", "ls -la /mnt/s3-bucket"},
		CloudBucketMounts: map[string]*modal.CloudBucketMount{
			"/mnt/s3-bucket": cloudBucketMount,
		},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}

	log.Printf("S3 Sandbox: %s", sb.SandboxId)

	output, err := io.ReadAll(sb.Stdout)
	if err != nil {
		log.Fatalf("Failed to read from Sandbox stdout: %v", err)
	}

	log.Printf("Sandbox directory listing of /mnt/s3-bucket:\n%s", string(output))

	if err := sb.Terminate(); err != nil {
		log.Printf("Failed to terminate Sandbox: %v", err)
	}
}



================================================
FILE: modal-go/examples/sandbox-exec/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("python:3.13-slim", nil)

	sb, err := app.CreateSandbox(image, nil)
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Println("Started Sandbox:", sb.SandboxId)
	defer sb.Terminate()

	p, err := sb.Exec(
		[]string{
			"python",
			"-c",
			`
import time
import sys
for i in range(50000):
	if i % 1000 == 0:
		time.sleep(0.01)
	print(i)
	print(i, file=sys.stderr)`,
		},
		modal.ExecOptions{
			Stdout: modal.Pipe,
			Stderr: modal.Pipe,
		},
	)
	if err != nil {
		log.Fatalf("Failed to execute command in Sandbox: %v", err)
	}

	contentStdout, err := io.ReadAll(p.Stdout)
	if err != nil {
		log.Fatalf("Failed to read stdout: %v", err)
	}
	contentStderr, err := io.ReadAll(p.Stderr)
	if err != nil {
		log.Fatalf("Failed to read stderr: %v", err)
	}

	log.Printf("Got %d bytes stdout and %d bytes stderr\n", len(contentStdout), len(contentStderr))
	returnCode, err := p.Wait()
	if err != nil {
		log.Fatalf("Failed to wait for process completion: %v", err)
	}
	log.Println("Return code:", returnCode)

	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{RequiredKeys: []string{"c"}})
	if err != nil {
		log.Fatalf("Unable to get Secret: %v", err)
	}

	// Passing Secrets in a command
	p, err = sb.Exec([]string{"printenv", "c"}, modal.ExecOptions{Stdout: modal.Pipe, Stderr: modal.Pipe, Secrets: []*modal.Secret{secret}})
	if err != nil {
		log.Fatalf("Faield to execute env command in Sandbox: %v", err)
	}

	secretStdout, err := io.ReadAll(p.Stdout)
	if err != nil {
		log.Fatalf("Failed to read stdout: %v", err)
	}
	log.Printf("Got environment variable c=%v", string(secretStdout))
}



================================================
FILE: modal-go/examples/sandbox-filesystem/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Started Sandbox: %s", sb.SandboxId)

	defer func() {
		if err := sb.Terminate(); err != nil {
			log.Printf("Failed to terminate Sandbox: %v", err)
		}
	}()

	// Write a file
	writeFile, err := sb.Open("/tmp/example.txt", "w")
	if err != nil {
		log.Fatalf("Failed to open file for writing: %v", err)
	}

	_, err = writeFile.Write([]byte("Hello, Modal filesystem!\n"))
	if err != nil {
		log.Fatalf("Failed to write to file: %v", err)
	}

	if err := writeFile.Close(); err != nil {
		log.Fatalf("Failed to close file: %v", err)
	}

	// Read the file
	reader, err := sb.Open("/tmp/example.txt", "r")
	if err != nil {
		log.Fatalf("Failed to open file for reading: %v", err)
	}

	content, err := io.ReadAll(reader)
	if err != nil && err != io.EOF {
		log.Fatalf("Failed to read file: %v", err)
	}

	fmt.Printf("File content:\n%s", string(content))
	if err := reader.Close(); err != nil {
		log.Fatalf("Failed to close file: %v", err)
	}
}



================================================
FILE: modal-go/examples/sandbox-filesystem-snapshot/main.go
================================================
package main

import (
	"context"
	"io"
	"log"
	"time"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup App: %v", err)
	}

	baseImage := modal.NewImageFromRegistry("alpine:3.21", nil)

	sb, err := app.CreateSandbox(baseImage, &modal.SandboxOptions{})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Started Sandbox: %s", sb.SandboxId)

	defer sb.Terminate()

	_, err = sb.Exec([]string{"mkdir", "-p", "/app/data"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	_, err = sb.Exec([]string{"sh", "-c", "echo 'This file was created in the first Sandbox' > /app/data/info.txt"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	log.Printf("Created file in first Sandbox")

	snapshotImage, err := sb.SnapshotFilesystem(55 * time.Second)
	if err != nil {
		log.Fatalf("Failed to snapshot filesystem: %v", err)
	}
	log.Printf("Filesystem snapshot created with Image ID: %s", snapshotImage.ImageId)

	sb.Terminate()
	log.Printf("Terminated first Sandbox")

	// Create new Sandbox from snapshot Image
	sb2, err := app.CreateSandbox(snapshotImage, nil)
	if err != nil {
		log.Fatalf("Failed to create Sandbox from snapshot: %v", err)
	}
	log.Printf("Started new Sandbox from snapshot: %s", sb2.SandboxId)

	defer sb2.Terminate()

	proc, err := sb2.Exec([]string{"cat", "/app/data/info.txt"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to exec cat command: %v", err)
	}

	content, err := io.ReadAll(proc.Stdout)
	if err != nil {
		log.Fatalf("Failed to read output: %v", err)
	}
	log.Printf("File data read in second Sandbox: %s", string(content))

	sb2.Terminate()
}



================================================
FILE: modal-go/examples/sandbox-gpu/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("nvidia/cuda:12.4.0-devel-ubuntu22.04", nil)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		GPU: "A10G",
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Started Sandbox with A10G GPU: %s", sb.SandboxId)
	defer sb.Terminate()

	log.Println("Running `nvidia-smi` in Sandbox:")

	p, err := sb.Exec([]string{"nvidia-smi"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to execute nvidia-smi in Sandbox: %v", err)
	}

	output, err := io.ReadAll(p.Stdout)
	if err != nil {
		log.Fatalf("Failed to read stdout: %v", err)
	}

	log.Printf("%s", string(output))
}



================================================
FILE: modal-go/examples/sandbox-named/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	sandboxName := "libmodal-example-named-sandbox"

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Name:    sandboxName,
		Command: []string{"cat"},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}

	fmt.Printf("Created Sandbox with name: %s\n", sandboxName)
	fmt.Printf("Sandbox ID: %s\n", sb.SandboxId)

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		Name:    sandboxName,
		Command: []string{"cat"},
	})
	if err != nil {
		if alreadyExistsErr, ok := err.(modal.AlreadyExistsError); ok {
			fmt.Printf("Trying to create one more Sandbox with the same name fails: %s\n", alreadyExistsErr.Exception)
		} else {
			log.Fatalf("Unexpected error: %v", err)
		}
	}

	sbFromName, err := modal.SandboxFromName(ctx, "libmodal-example", sandboxName, nil)
	if err != nil {
		log.Fatalf("Failed to get Sandbox by name: %v", err)
	}
	fmt.Printf("Retrieved the same Sandbox from name: %s\n", sbFromName.SandboxId)

	_, err = sbFromName.Stdin.Write([]byte("hello, named Sandbox"))
	if err != nil {
		log.Fatalf("Failed to write to Sandbox stdin: %v", err)
	}
	err = sbFromName.Stdin.Close()
	if err != nil {
		log.Fatalf("Failed to close Sandbox stdin: %v", err)
	}

	fmt.Println("Reading output:")
	output, err := io.ReadAll(sbFromName.Stdout)
	if err != nil {
		log.Fatalf("Failed to read output from Sandbox stdout: %v", err)
	}
	fmt.Printf("%s\n", output)

	err = sb.Terminate()
	if err != nil {
		log.Fatalf("Failed to terminate Sandbox: %v", err)
	}
	fmt.Println("Sandbox terminated")
}



================================================
FILE: modal-go/examples/sandbox-poll/main.go
================================================
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	// Create a sandbox that waits for input, then exits with code 42
	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-c", "read line; exit 42"},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}

	fmt.Printf("Started Sandbox: %s\n", sandbox.SandboxId)

	initialPoll, err := sandbox.Poll()
	if err != nil {
		log.Fatalf("Failed to poll Sandbox: %v", err)
	}
	fmt.Printf("Poll result while running: %v\n", initialPoll)

	fmt.Println("\nSending input to trigger completion...")
	_, err = sandbox.Stdin.Write([]byte("hello, goodbye\n"))
	if err != nil {
		log.Fatalf("Failed to write to stdin: %v", err)
	}
	err = sandbox.Stdin.Close()
	if err != nil {
		log.Fatalf("Failed to close stdin: %v", err)
	}

	exitCode, err := sandbox.Wait()
	if err != nil {
		log.Fatalf("Failed to wait for Sandbox: %v", err)
	}
	fmt.Printf("\nSandbox completed with exit code: %d\n", exitCode)

	finalPoll, err := sandbox.Poll()
	if err != nil {
		log.Fatalf("Failed to poll Sandbox after completion: %v", err)
	}
	fmt.Printf("Poll result after completion: %d\n", *finalPoll)
}



================================================
FILE: modal-go/examples/sandbox-prewarm/main.go
================================================
// We use `Image.Build` to create an Image object on Modal
// that eagerly pulls from the registry. The first Sandbox created with this Image
// will ues this "pre-warmed" Image and will start faster.
package main

import (
	"context"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	// With `.Build(app)`, we create an Image object on Modal that eagerly pulls
	// from the registry.
	image, err := modal.NewImageFromRegistry("alpine:3.21", nil).Build(app)
	if err != nil {
		log.Fatalf("Unable to build Image: %v", err)
	}
	log.Printf("Image has ID: %v", image.ImageId)

	// You can save the ImageId and create a new Image object that referes to it.
	imageId := image.ImageId
	image2, err := modal.NewImageFromId(ctx, imageId)
	if err != nil {
		log.Fatalf("Unable to look up Image from ID: %v", err)
	}

	sb, err := app.CreateSandbox(image2, &modal.SandboxOptions{
		Command: []string{"cat"},
	})
	defer sb.Terminate()
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Sandbox: %s\n", sb.SandboxId)
}



================================================
FILE: modal-go/examples/sandbox-private-image/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	secret, err := modal.SecretFromName(ctx, "libmodal-aws-ecr-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"},
	})
	if err != nil {
		log.Fatalf("Failed to get Secret: %v", err)
	}

	image := modal.NewImageFromAwsEcr("459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python", secret)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"python", "-c", `import sys; sys.stdout.write(sys.stdin.read())`},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Sandbox: %s\n", sb.SandboxId)

	_, err = sb.Stdin.Write([]byte("this is input that should be mirrored by the Python one-liner"))
	if err != nil {
		log.Fatalf("Failed to write to Sandbox stdin: %v", err)
	}
	err = sb.Stdin.Close()
	if err != nil {
		log.Fatalf("Failed to close Sandbox stdin: %v", err)
	}

	output, err := io.ReadAll(sb.Stdout)
	if err != nil {
		log.Fatalf("Failed to read from Sandbox stdout: %v", err)
	}

	log.Printf("output: %s\n", string(output))
}



================================================
FILE: modal-go/examples/sandbox-proxy/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine/curl:8.14.1", nil)

	proxy, err := modal.ProxyFromName(ctx, "libmodal-test-proxy", nil)
	if err != nil {
		log.Fatalf("Failed to get Proxy: %v", err)
	}
	log.Printf("Using Proxy: %s", proxy.ProxyId)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Proxy: proxy,
	})
	if err != nil {
		log.Fatalf("Failed to create sandbox: %v", err)
	}
	log.Printf("Created sandbox with proxy: %s", sb.SandboxId)

	p, err := sb.Exec([]string{"curl", "-s", "ifconfig.me"}, modal.ExecOptions{})
	if err != nil {
		log.Fatalf("Failed to start IP fetch command: %v", err)
	}

	ip, err := io.ReadAll(p.Stdout)
	if err != nil {
		log.Fatalf("Failed to read IP output: %v", err)
	}

	log.Printf("External IP: %s", string(ip))

	err = sb.Terminate()
	if err != nil {
		log.Fatalf("Failed to terminate Sandbox: %v", err)
	}
}



================================================
FILE: modal-go/examples/sandbox-secrets/main.go
================================================
package main

import (
	"context"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}
	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{RequiredKeys: []string{"c"}})
	if err != nil {
		log.Fatalf("Failed finding a Secret: %v", err)
	}

	ephemeralSecret, err := modal.SecretFromMap(ctx, map[string]string{
		"d": "123",
	}, nil)
	if err != nil {
		log.Fatalf("Failed creating ephemeral Secret: %v", err)
	}

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-lc", "printenv | grep -E '^c|d='"}, Secrets: []*modal.Secret{secret, ephemeralSecret},
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}
	log.Printf("Sandbox created: %s\n", sb.SandboxId)

	output, err := io.ReadAll(sb.Stdout)
	if err != nil {
		log.Fatalf("Failed to read output: %v", err)
	}
	log.Printf("Sandbox environment variables from Secrets:\n%v", string(output))
}



================================================
FILE: modal-go/examples/sandbox-tunnels/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{CreateIfMissing: true})
	if err != nil {
		log.Fatalf("Failed to lookup or create App: %v", err)
	}

	// Create a Sandbox with Python's built-in HTTP server
	image := modal.NewImageFromRegistry("python:3.12-alpine", nil)

	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command:        []string{"python3", "-m", "http.server", "8000"},
		EncryptedPorts: []int{8000},
		Timeout:        1 * time.Minute,
		IdleTimeout:    30 * time.Second,
	})
	if err != nil {
		log.Fatalf("Failed to create Sandbox: %v", err)
	}

	log.Printf("Sandbox created: %s", sandbox.SandboxId)

	log.Printf("Waiting for server to start...")
	time.Sleep(3 * time.Second)

	log.Printf("Getting tunnel information...")
	tunnels, err := sandbox.Tunnels(30 * time.Second)
	if err != nil {
		log.Fatalf("Failed to get tunnels: %v", err)
	}

	tunnel := tunnels[8000]
	if tunnel == nil {
		log.Fatalf("No tunnel found for port 8000")
	}

	log.Printf("Tunnel information:")
	log.Printf("  URL: %s", tunnel.URL())
	log.Printf("  Port: %d", tunnel.Port)

	log.Printf("\nMaking GET request to the tunneled server at %s", tunnel.URL())

	// Make a GET request to the tunneled server
	resp, err := http.Get(tunnel.URL())
	if err != nil {
		log.Fatalf("Failed to make GET request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("HTTP error! status: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Display first 500 characters of the response
	bodyStr := string(body)
	if len(bodyStr) > 500 {
		bodyStr = bodyStr[:500]
	}

	fmt.Printf("\nDirectory listing from server (first 500 chars):\n%s\n", bodyStr)

	log.Printf("\n✅ Successfully connected to the tunneled server!")

	err = sandbox.Terminate()
	if err != nil {
		log.Fatalf("Failed to terminate Sandbox: %v", err)
	}
}



================================================
FILE: modal-go/examples/sandbox-volume/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	if err != nil {
		log.Fatalf("Failed to lookup App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	volume, err := modal.VolumeFromName(ctx, "libmodal-example-volume", &modal.VolumeFromNameOptions{
		CreateIfMissing: true,
	})
	if err != nil {
		log.Fatalf("Failed to create Volume: %v", err)
	}

	writerSandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{
			"sh",
			"-c",
			"echo 'Hello from writer Sandbox!' > /mnt/volume/message.txt",
		},
		Volumes: map[string]*modal.Volume{
			"/mnt/volume": volume,
		},
	})
	if err != nil {
		log.Fatalf("Failed to create writer Sandbox: %v", err)
	}
	fmt.Printf("Writer Sandbox: %s\n", writerSandbox.SandboxId)

	exitCode, err := writerSandbox.Wait()
	if err != nil {
		log.Fatalf("Failed to wait for writer Sandbox: %v", err)
	}
	fmt.Printf("Writer finished with exit code: %d\n", exitCode)

	readerSandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Volumes: map[string]*modal.Volume{
			"/mnt/volume": volume.ReadOnly(),
		},
	})
	if err != nil {
		log.Fatalf("Failed to create reader Sandbox: %v", err)
	}
	fmt.Printf("Reader Sandbox: %s\n", readerSandbox.SandboxId)

	rp, err := readerSandbox.Exec([]string{"cat", "/mnt/volume/message.txt"}, modal.ExecOptions{
		Stdout: modal.Pipe,
	})
	if err != nil {
		log.Fatalf("Failed to exec read command: %v", err)
	}
	readOutput, err := io.ReadAll(rp.Stdout)
	if err != nil {
		log.Fatalf("Failed to read output: %v", err)
	}
	fmt.Printf("Reader output: %s", string(readOutput))

	wp, err := readerSandbox.Exec([]string{"sh", "-c", "echo 'This should fail' >> /mnt/volume/message.txt"}, modal.ExecOptions{
		Stdout: modal.Pipe,
		Stderr: modal.Pipe,
	})
	if err != nil {
		log.Fatalf("Failed to exec write command: %v", err)
	}

	writeExitCode, err := wp.Wait()
	if err != nil {
		log.Fatalf("Failed to wait for write process: %v", err)
	}
	writeStderr, err := io.ReadAll(wp.Stderr)
	if err != nil {
		log.Fatalf("Failed to read stderr: %v", err)
	}

	fmt.Printf("Write attempt exit code: %d\n", writeExitCode)
	fmt.Printf("Write attempt stderr: %s", string(writeStderr))

	if err := writerSandbox.Terminate(); err != nil {
		log.Printf("Failed to terminate writer Sandbox: %v", err)
	}
	if err := readerSandbox.Terminate(); err != nil {
		log.Printf("Failed to terminate reader Sandbox: %v", err)
	}
}



================================================
FILE: modal-go/examples/sandbox-volume-ephemeral/main.go
================================================
package main

import (
	"context"
	"fmt"
	"io"
	"log"

	"github.com/modal-labs/libmodal/modal-go"
)

func main() {
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-example", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	if err != nil {
		log.Fatalf("Failed to lookup App: %v", err)
	}

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	volume, err := modal.VolumeEphemeral(ctx, nil)
	if err != nil {
		log.Fatalf("Failed to create ephemeral Volume: %v", err)
	}
	defer volume.CloseEphemeral()

	writerSandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{
			"sh",
			"-c",
			"echo 'Hello from writer Sandbox!' > /mnt/volume/message.txt",
		},
		Volumes: map[string]*modal.Volume{
			"/mnt/volume": volume,
		},
	})
	if err != nil {
		log.Fatalf("Failed to create writer Sandbox: %v", err)
	}
	fmt.Printf("Writer Sandbox: %s\n", writerSandbox.SandboxId)

	exitCode, err := writerSandbox.Wait()
	if err != nil {
		log.Fatalf("Failed to wait for writer Sandbox: %v", err)
	}
	fmt.Printf("Writer finished with exit code: %d\n", exitCode)

	if err := writerSandbox.Terminate(); err != nil {
		log.Printf("Failed to terminate writer Sandbox: %v", err)
	}

	readerSandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"cat", "/mnt/volume/message.txt"},
		Volumes: map[string]*modal.Volume{
			"/mnt/volume": volume.ReadOnly(),
		},
	})
	if err != nil {
		log.Fatalf("Failed to create reader Sandbox: %v", err)
	}
	fmt.Printf("Reader Sandbox: %s\n", readerSandbox.SandboxId)

	readerOutput, err := io.ReadAll(readerSandbox.Stdout)
	if err != nil {
		log.Fatalf("Failed to read reader output: %v", err)
	}
	fmt.Printf("Reader output: %s", string(readerOutput))

	if err := readerSandbox.Terminate(); err != nil {
		log.Printf("Failed to terminate reader Sandbox: %v", err)
	}
}



================================================
FILE: modal-go/proto/modal_proto/options.pb.go
================================================
// Defines custom options used internally at Modal.
// Custom options must be in the range 50000-99999.
// Reference: https://protobuf.dev/programming-guides/proto2/#customoptions

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.32.1
// source: modal_proto/options.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var file_modal_proto_options_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.FieldOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         50000,
		Name:          "modal.options.audit_target_attr",
		Tag:           "varint,50000,opt,name=audit_target_attr",
		Filename:      "modal_proto/options.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*string)(nil),
		Field:         50000,
		Name:          "modal.options.audit_event_name",
		Tag:           "bytes,50000,opt,name=audit_event_name",
		Filename:      "modal_proto/options.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*string)(nil),
		Field:         50001,
		Name:          "modal.options.audit_event_description",
		Tag:           "bytes,50001,opt,name=audit_event_description",
		Filename:      "modal_proto/options.proto",
	},
}

// Extension fields to descriptorpb.FieldOptions.
var (
	// optional bool audit_target_attr = 50000;
	E_AuditTargetAttr = &file_modal_proto_options_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
	// optional string audit_event_name = 50000;
	E_AuditEventName = &file_modal_proto_options_proto_extTypes[1]
	// optional string audit_event_description = 50001;
	E_AuditEventDescription = &file_modal_proto_options_proto_extTypes[2]
)

var File_modal_proto_options_proto protoreflect.FileDescriptor

const file_modal_proto_options_proto_rawDesc = "" +
	"\n" +
	"\x19modal_proto/options.proto\x12\rmodal.options\x1a google/protobuf/descriptor.proto:N\n" +
	"\x11audit_target_attr\x12\x1d.google.protobuf.FieldOptions\x18І\x03 \x01(\bR\x0fauditTargetAttr\x88\x01\x01:M\n" +
	"\x10audit_event_name\x12\x1e.google.protobuf.MethodOptions\x18І\x03 \x01(\tR\x0eauditEventName\x88\x01\x01:[\n" +
	"\x17audit_event_description\x12\x1e.google.protobuf.MethodOptions\x18ц\x03 \x01(\tR\x15auditEventDescription\x88\x01\x01B&Z$github.com/modal-labs/modal/go/protob\x06proto3"

var file_modal_proto_options_proto_goTypes = []any{
	(*descriptorpb.FieldOptions)(nil),  // 0: google.protobuf.FieldOptions
	(*descriptorpb.MethodOptions)(nil), // 1: google.protobuf.MethodOptions
}
var file_modal_proto_options_proto_depIdxs = []int32{
	0, // 0: modal.options.audit_target_attr:extendee -> google.protobuf.FieldOptions
	1, // 1: modal.options.audit_event_name:extendee -> google.protobuf.MethodOptions
	1, // 2: modal.options.audit_event_description:extendee -> google.protobuf.MethodOptions
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	0, // [0:3] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_modal_proto_options_proto_init() }
func file_modal_proto_options_proto_init() {
	if File_modal_proto_options_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_modal_proto_options_proto_rawDesc), len(file_modal_proto_options_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   0,
			NumExtensions: 3,
			NumServices:   0,
		},
		GoTypes:           file_modal_proto_options_proto_goTypes,
		DependencyIndexes: file_modal_proto_options_proto_depIdxs,
		ExtensionInfos:    file_modal_proto_options_proto_extTypes,
	}.Build()
	File_modal_proto_options_proto = out.File
	file_modal_proto_options_proto_goTypes = nil
	file_modal_proto_options_proto_depIdxs = nil
}



================================================
FILE: modal-go/scripts/gen-proto.sh
================================================
#!/bin/bash

rm -rf proto && mkdir -p proto

protoc \
  --go_out=paths=source_relative:proto \
  --go_opt=default_api_level=API_OPAQUE \
  --go-grpc_out=paths=source_relative:proto \
  --proto_path=../modal-client \
  ../modal-client/modal_proto/*.proto

# Find all 'package proto' declarations and replace with 'package pb'
find . -type f -name '*.go' -exec sed -i 's/^package proto$/package pb/' {} +



================================================
FILE: modal-go/test/cls_test.go
================================================
package test

import (
	"context"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestClsCall(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	instance, err := cls.Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Try accessing a non-existent method
	_, err = instance.Method("nonexistent")
	g.Expect(err).Should(gomega.BeAssignableToTypeOf(modal.NotFoundError{}))

	function, err := instance.Method("echo_string")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	result, err := function.Remote(nil, map[string]any{"s": "hello"})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))

	cls, err = modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoClsParametrized", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	instance, err = cls.Instance(map[string]any{"name": "hello-init"})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	function, err = instance.Method("echo_parameter")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	result, _ = function.Remote(nil, nil)
	g.Expect(result).Should(gomega.Equal("output: hello-init"))
}

func TestClsNotFound(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	_, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "NotRealClassName", nil)
	g.Expect(err).Should(gomega.BeAssignableToTypeOf(modal.NotFoundError{}))
}

func TestClsCallInputPlane(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoClsInputPlane", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	instance, err := cls.Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	function, err := instance.Method("echo_string")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	result, err := function.Remote(nil, map[string]any{"s": "hello"})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))
}



================================================
FILE: modal-go/test/cls_with_options_test.go
================================================
package test

import (
	"context"
	"testing"
	"time"

	modal "github.com/modal-labs/libmodal/modal-go"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/modal-labs/libmodal/modal-go/testsupport/grpcmock"
	"github.com/onsi/gomega"
)

var mockFunctionProto = pb.FunctionGetResponse_builder{
	FunctionId: "fid",
	HandleMetadata: pb.FunctionHandleMetadata_builder{
		MethodHandleMetadata: map[string]*pb.FunctionHandleMetadata{"echo_string": {}},
		ClassParameterInfo:   pb.ClassParameterInfo_builder{Schema: []*pb.ClassParameterSpec{}}.Build(),
	}.Build(),
}.Build()

func TestClsWithOptionsStacking(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "FunctionBindParams",
		func(req *pb.FunctionBindParamsRequest) (*pb.FunctionBindParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid"))
			fo := req.GetFunctionOptions()
			g.Expect(fo).ToNot(gomega.BeNil())
			g.Expect(fo.GetTimeoutSecs()).To(gomega.Equal(uint32(60)))
			g.Expect(fo.GetResources()).ToNot(gomega.BeNil())
			g.Expect(fo.GetResources().GetMilliCpu()).To(gomega.Equal(uint32(250)))
			g.Expect(fo.GetResources().GetMemoryMb()).To(gomega.Equal(uint32(256)))
			g.Expect(fo.GetResources().GetGpuConfig()).ToNot(gomega.BeNil())
			g.Expect(fo.GetSecretIds()).To(gomega.Equal([]string{"sec-1"}))
			g.Expect(fo.GetReplaceSecretIds()).To(gomega.BeTrue())
			g.Expect(fo.GetReplaceVolumeMounts()).To(gomega.BeTrue())
			g.Expect(fo.GetVolumeMounts()).To(gomega.HaveLen(1))
			g.Expect(fo.GetVolumeMounts()[0].GetMountPath()).To(gomega.Equal("/mnt/test"))
			g.Expect(fo.GetVolumeMounts()[0].GetVolumeId()).To(gomega.Equal("vol-1"))
			g.Expect(fo.GetVolumeMounts()[0].GetAllowBackgroundCommits()).To(gomega.BeTrue())
			g.Expect(fo.GetVolumeMounts()[0].GetReadOnly()).To(gomega.BeFalse())
			return pb.FunctionBindParamsResponse_builder{BoundFunctionId: "fid-1", HandleMetadata: &pb.FunctionHandleMetadata{}}.Build(), nil
		},
	)

	secret := &modal.Secret{SecretId: "sec-1"}
	volume := &modal.Volume{VolumeId: "vol-1"}
	cpu := 0.25
	memory := 256
	gpu := "T4"
	timeout := 45 * time.Second
	newTimeout := 60 * time.Second

	optioned := cls.
		WithOptions(modal.ClsOptions{Timeout: &timeout, CPU: &cpu}).
		WithOptions(modal.ClsOptions{Timeout: &newTimeout, Memory: &memory, GPU: &gpu}).
		WithOptions(modal.ClsOptions{Secrets: []*modal.Secret{secret}, Volumes: map[string]*modal.Volume{"/mnt/test": volume}})

	instance, err := optioned.Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(instance).ToNot(gomega.BeNil())
}

func TestClsWithConcurrencyWithBatchingChaining(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "FunctionBindParams",
		func(req *pb.FunctionBindParamsRequest) (*pb.FunctionBindParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid"))
			fo := req.GetFunctionOptions()
			g.Expect(fo).ToNot(gomega.BeNil())
			g.Expect(fo.GetTimeoutSecs()).To(gomega.Equal(uint32(60)))
			g.Expect(fo.GetMaxConcurrentInputs()).To(gomega.Equal(uint32(10)))
			g.Expect(fo.GetBatchMaxSize()).To(gomega.Equal(uint32(11)))
			g.Expect(fo.GetBatchLingerMs()).To(gomega.Equal(uint64(12)))
			return pb.FunctionBindParamsResponse_builder{BoundFunctionId: "fid-1", HandleMetadata: &pb.FunctionHandleMetadata{}}.Build(), nil
		},
	)

	timeout := 60 * time.Second
	chained := cls.
		WithOptions(modal.ClsOptions{Timeout: &timeout}).
		WithConcurrency(modal.ClsConcurrencyOptions{MaxInputs: 10}).
		WithBatching(modal.ClsBatchingOptions{MaxBatchSize: 11, Wait: 12 * time.Millisecond})

	instance, err := chained.Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(instance).ToNot(gomega.BeNil())
}

func TestClsWithOptionsRetries(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "FunctionBindParams",
		func(req *pb.FunctionBindParamsRequest) (*pb.FunctionBindParamsResponse, error) {
			fo := req.GetFunctionOptions()
			g.Expect(fo).ToNot(gomega.BeNil())
			g.Expect(fo.GetRetryPolicy()).ToNot(gomega.BeNil())
			g.Expect(fo.GetRetryPolicy().GetRetries()).To(gomega.Equal(uint32(2)))
			g.Expect(fo.GetRetryPolicy().GetBackoffCoefficient()).To(gomega.Equal(float32(2.0)))
			g.Expect(fo.GetRetryPolicy().GetInitialDelayMs()).To(gomega.Equal(uint32(2000)))
			g.Expect(fo.GetRetryPolicy().GetMaxDelayMs()).To(gomega.Equal(uint32(5000)))
			return pb.FunctionBindParamsResponse_builder{BoundFunctionId: "fid-2", HandleMetadata: &pb.FunctionHandleMetadata{}}.Build(), nil
		},
	)

	backoff := float32(2.0)
	initial := 2 * time.Second
	max := 5 * time.Second
	retries, err := modal.NewRetries(2, &modal.RetriesOptions{
		BackoffCoefficient: &backoff,
		InitialDelay:       &initial,
		MaxDelay:           &max,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = cls.WithOptions(modal.ClsOptions{Retries: retries}).Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestClsWithOptionsInvalidValues(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	timeout := 500 * time.Millisecond
	_, err = cls.WithOptions(modal.ClsOptions{Timeout: &timeout}).Instance(nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("timeout must be at least 1 second"))

	scaledownWindow := 100 * time.Millisecond
	_, err = cls.WithOptions(modal.ClsOptions{ScaledownWindow: &scaledownWindow}).Instance(nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("scaledownWindow must be at least 1 second"))

	fractionalTimeout := 1500 * time.Millisecond
	_, err = cls.WithOptions(modal.ClsOptions{Timeout: &fractionalTimeout}).Instance(nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("whole number of seconds"))

	fractionalScaledown := 1500 * time.Millisecond
	_, err = cls.WithOptions(modal.ClsOptions{ScaledownWindow: &fractionalScaledown}).Instance(nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("whole number of seconds"))
}

func TestWithOptionsEmptySecretsDoesNotReplace(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "FunctionBindParams",
		func(req *pb.FunctionBindParamsRequest) (*pb.FunctionBindParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid"))
			fo := req.GetFunctionOptions()
			g.Expect(fo.GetSecretIds()).To(gomega.HaveLen(0))
			g.Expect(fo.GetReplaceSecretIds()).To(gomega.BeFalse())

			return pb.FunctionBindParamsResponse_builder{BoundFunctionId: "fid-1", HandleMetadata: &pb.FunctionHandleMetadata{}}.Build(), nil
		},
	)

	_, err = cls.WithOptions(modal.ClsOptions{Secrets: []*modal.Secret{}}).Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestWithOptionsEmptyVolumesDoesNotReplace(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			return mockFunctionProto, nil
		},
	)

	cls, err := modal.ClsLookup(context.Background(), "libmodal-test-support", "EchoCls", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "FunctionBindParams",
		func(req *pb.FunctionBindParamsRequest) (*pb.FunctionBindParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid"))
			fo := req.GetFunctionOptions()
			g.Expect(fo.GetVolumeMounts()).To(gomega.HaveLen(0))
			g.Expect(fo.GetReplaceVolumeMounts()).To(gomega.BeFalse())

			return pb.FunctionBindParamsResponse_builder{BoundFunctionId: "fid-1", HandleMetadata: &pb.FunctionHandleMetadata{}}.Build(), nil
		},
	)

	_, err = cls.WithOptions(modal.ClsOptions{Volumes: map[string]*modal.Volume{}}).Instance(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}



================================================
FILE: modal-go/test/function_call_test.go
================================================
package test

import (
	"context"
	"testing"
	"time"

	pickle "github.com/kisielk/og-rek"
	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestFunctionSpawn(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	function, err := modal.FunctionLookup(
		context.Background(),
		"libmodal-test-support", "echo_string", nil,
	)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	functionCall, err := function.Spawn(nil, map[string]any{"s": "hello"})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	result, err := functionCall.Get(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))

	functionCall, err = modal.FunctionCallFromId(context.Background(), functionCall.FunctionCallId)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	result, err = functionCall.Get(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))

	sleep, err := modal.FunctionLookup(
		context.Background(),
		"libmodal-test-support", "sleep", nil,
	)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	functionCall, err = sleep.Spawn(nil, map[string]any{"t": 5})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	err = functionCall.Cancel(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = functionCall.Get(nil)
	g.Expect(err).Should(gomega.HaveOccurred())

	// Spawn function with long running input.
	functionCall, err = sleep.Spawn(nil, map[string]any{"t": 5})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Get is now expected to timeout.
	timeout := 1 * time.Second
	_, err = functionCall.Get(&modal.FunctionCallGetOptions{Timeout: &timeout})
	g.Expect(err).Should(gomega.HaveOccurred())
}

func TestFunctionCallGet0(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	sleep, _ := modal.FunctionLookup(
		context.Background(),
		"libmodal-test-support", "sleep", nil,
	)

	functionCall, err := sleep.Spawn([]any{0.5}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Polling for output with timeout 0 should raise an error, since the
	// function call has not finished yet.
	timeout := 0 * time.Second
	_, err = functionCall.Get(&modal.FunctionCallGetOptions{Timeout: &timeout})
	g.Expect(err).Should(gomega.HaveOccurred())

	// Wait for the function call to finish.
	result, err := functionCall.Get(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal(pickle.None{}))

	// Now we can get the result.
	result, err = functionCall.Get(&modal.FunctionCallGetOptions{Timeout: &timeout})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal(pickle.None{}))
}



================================================
FILE: modal-go/test/function_test.go
================================================
package test

import (
	"context"
	"testing"

	modal "github.com/modal-labs/libmodal/modal-go"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/modal-labs/libmodal/modal-go/testsupport/grpcmock"
	"github.com/onsi/gomega"
)

func TestFunctionCall(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	function, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "echo_string", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Represent Python kwargs.
	result, err := function.Remote(nil, map[string]any{"s": "hello"})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))

	// Try the same, but with args.
	result, err = function.Remote([]any{"hello"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))
}

func TestFunctionCallLargeInput(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	function, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "bytelength", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	len := 3 * 1000 * 1000 // More than 2 MiB, offload to blob storage
	input := make([]byte, len)
	result, err := function.Remote([]any{input}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal(int64(len)))
}

func TestFunctionNotFound(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	_, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "not_a_real_function", nil)
	g.Expect(err).Should(gomega.BeAssignableToTypeOf(modal.NotFoundError{}))
}

func TestFunctionCallInputPlane(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	function, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "input_plane", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Try the same, but with args.
	result, err := function.Remote([]any{"hello"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).Should(gomega.Equal("output: hello"))
}

func TestFunctionGetCurrentStats(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "/FunctionGetCurrentStats",
		func(req *pb.FunctionGetCurrentStatsRequest) (*pb.FunctionStats, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid-stats"))
			return pb.FunctionStats_builder{Backlog: 3, NumTotalTasks: 7}.Build(), nil
		},
	)

	f := &modal.Function{FunctionId: "fid-stats"}
	stats, err := f.GetCurrentStats()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(stats).To(gomega.Equal(&modal.FunctionStats{Backlog: 3, NumTotalRunners: 7}))
}

func TestFunctionUpdateAutoscaler(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "/FunctionUpdateSchedulingParams",
		func(req *pb.FunctionUpdateSchedulingParamsRequest) (*pb.FunctionUpdateSchedulingParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid-auto"))
			s := req.GetSettings()
			g.Expect(s.GetMinContainers()).To(gomega.Equal(uint32(1)))
			g.Expect(s.GetMaxContainers()).To(gomega.Equal(uint32(10)))
			g.Expect(s.GetBufferContainers()).To(gomega.Equal(uint32(2)))
			g.Expect(s.GetScaledownWindow()).To(gomega.Equal(uint32(300)))
			return &pb.FunctionUpdateSchedulingParamsResponse{}, nil
		},
	)

	f := &modal.Function{FunctionId: "fid-auto"}

	err := f.UpdateAutoscaler(modal.UpdateAutoscalerOptions{
		MinContainers:    ptrU32(1),
		MaxContainers:    ptrU32(10),
		BufferContainers: ptrU32(2),
		ScaledownWindow:  ptrU32(300),
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	grpcmock.HandleUnary(
		mock, "/FunctionUpdateSchedulingParams",
		func(req *pb.FunctionUpdateSchedulingParamsRequest) (*pb.FunctionUpdateSchedulingParamsResponse, error) {
			g.Expect(req.GetFunctionId()).To(gomega.Equal("fid-auto"))
			g.Expect(req.GetSettings().GetMinContainers()).To(gomega.Equal(uint32(2)))
			return &pb.FunctionUpdateSchedulingParamsResponse{}, nil
		},
	)

	err = f.UpdateAutoscaler(modal.UpdateAutoscalerOptions{
		MinContainers: ptrU32(2),
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func ptrU32(v uint32) *uint32 { return &v }

func TestFunctionGetWebURL(t *testing.T) {
	g := gomega.NewWithT(t)

	f, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "echo_string", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(f.GetWebURL()).To(gomega.Equal(""))

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "FunctionGet",
		func(req *pb.FunctionGetRequest) (*pb.FunctionGetResponse, error) {
			g.Expect(req.GetAppName()).To(gomega.Equal("libmodal-test-support"))
			g.Expect(req.GetObjectTag()).To(gomega.Equal("web_endpoint"))
			return pb.FunctionGetResponse_builder{
				FunctionId:     "fid-web",
				HandleMetadata: pb.FunctionHandleMetadata_builder{WebUrl: "https://endpoint.internal"}.Build(),
			}.Build(), nil
		},
	)

	wef, err := modal.FunctionLookup(context.Background(), "libmodal-test-support", "web_endpoint", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(wef.GetWebURL()).To(gomega.Equal("https://endpoint.internal"))
}



================================================
FILE: modal-go/test/image_test.go
================================================
package test

import (
	"context"
	"io"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
	"github.com/modal-labs/libmodal/modal-go/testsupport/grpcmock"
	"github.com/onsi/gomega"
)

func TestImageFromId(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := modal.NewImageFromRegistry("alpine:3.21", nil).Build(app)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	imageFromId, err := modal.NewImageFromId(ctx, image.ImageId)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(imageFromId.ImageId).Should(gomega.Equal(image.ImageId))

	_, err = modal.NewImageFromId(ctx, "im-nonexistent")
	g.Expect(err).Should(gomega.HaveOccurred())
}

//nolint:staticcheck
func TestImageFromRegistry(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

//nolint:staticcheck
func TestImageFromRegistryWithSecret(t *testing.T) {
	// GCP Artifact Registry also supports auth using username and password, if the username is "_json_key"
	// and the password is the service account JSON blob. See:
	// https://cloud.google.com/artifact-registry/docs/docker/authentication#json-key
	// So we use GCP Artifact Registry to test this too.

	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-gcp-artifact-registry-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"REGISTRY_USERNAME", "REGISTRY_PASSWORD"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image", &modal.ImageFromRegistryOptions{
		Secret: secret,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

//nolint:staticcheck
func TestImageFromAwsEcr(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-aws-ecr-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromAwsEcr("459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python", secret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

//nolint:staticcheck
func TestImageFromGcpArtifactRegistry(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-gcp-artifact-registry-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"SERVICE_ACCOUNT_JSON"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromGcpArtifactRegistry("us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image", secret)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

func TestCreateOneSandboxTopLevelImageAPI(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil)
	g.Expect(image.ImageId).Should(gomega.BeEmpty())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

func TestCreateOneSandboxTopLevelImageAPISecret(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-gcp-artifact-registry-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"REGISTRY_USERNAME", "REGISTRY_PASSWORD"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image", &modal.ImageFromRegistryOptions{
		Secret: secret,
	})
	g.Expect(image.ImageId).Should(gomega.BeEmpty())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

func TestImageFromAwsEcrTopLevel(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-aws-ecr-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromAwsEcr("459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python", secret)
	g.Expect(image.ImageId).Should(gomega.Equal(""))

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

func TestImageFromGcpEcrTopLevel(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromName(context.Background(), "libmodal-gcp-artifact-registry-test", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"SERVICE_ACCOUNT_JSON"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromGcpArtifactRegistry("us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image", secret)
	g.Expect(image.ImageId).Should(gomega.Equal(""))

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))
}

func TestImageDelete(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := modal.NewImageFromRegistry("alpine:3.13", nil).Build(app)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(image.ImageId).Should(gomega.HavePrefix("im-"))

	imageFromId, err := modal.NewImageFromId(ctx, image.ImageId)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(imageFromId.ImageId).Should(gomega.Equal(image.ImageId))

	err = modal.ImageDelete(ctx, image.ImageId, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = modal.NewImageFromId(ctx, image.ImageId)
	g.Expect(err).Should(gomega.MatchError(gomega.MatchRegexp("Image .+ not found")))

	newImage, err := modal.NewImageFromRegistry("alpine:3.13", nil).Build(app)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(newImage.ImageId).ShouldNot(gomega.Equal(image.ImageId))

	_, err = modal.NewImageFromId(ctx, "im-nonexistent")
	g.Expect(err).Should(gomega.MatchError(gomega.MatchRegexp("Image .+ not found")))
}

func TestDockerfileCommands(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil).DockerfileCommands(
		[]string{"RUN echo hey > /root/hello.txt"},
		nil,
	)

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"cat", "/root/hello.txt"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	stdout, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(stdout)).Should(gomega.Equal("hey\n"))

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestDockerfileCommandsEmptyArrayNoOp(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	image1 := modal.NewImageFromRegistry("alpine:3.21", nil)
	image2 := image1.DockerfileCommands([]string{}, nil)
	g.Expect(image2).Should(gomega.BeIdenticalTo(image1))
}

func TestDockerfileCommandsChaining(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromMap(context.Background(), map[string]string{"SECRET": "hello"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil).
		DockerfileCommands([]string{"RUN echo ${SECRET:-unset} > /root/layer1.txt"}, nil).
		DockerfileCommands([]string{"RUN echo ${SECRET:-unset} > /root/layer2.txt"}, &modal.ImageDockerfileCommandsOptions{
			Secrets: []*modal.Secret{secret},
		}).
		DockerfileCommands([]string{"RUN echo ${SECRET:-unset} > /root/layer3.txt"}, nil).
		DockerfileCommands([]string{"RUN echo ${SECRET:-unset} > /root/layer4.txt"}, &modal.ImageDockerfileCommandsOptions{
			Env: map[string]string{"SECRET": "hello again"},
		})

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{
			"cat",
			"/root/layer1.txt",
			"/root/layer2.txt",
			"/root/layer3.txt",
			"/root/layer4.txt",
		},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	stdout, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(stdout)).Should(gomega.Equal("unset\nhello\nunset\nhello again\n"))

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestDockerfileCommandsCopyCommandValidation(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	validImage := image.DockerfileCommands(
		[]string{"COPY --from=alpine:latest /etc/os-release /tmp/os-release"},
		nil,
	)
	_, err = validImage.Build(app)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	invalidImage := image.DockerfileCommands(
		[]string{"COPY ./file.txt /root/"},
		nil,
	)
	_, err = invalidImage.Build(app)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("COPY commands that copy from local context are not yet supported"))

	runImage := image.DockerfileCommands(
		[]string{"RUN echo 'COPY ./file.txt /root/'"},
		nil,
	)
	_, err = runImage.Build(app)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	multiInvalidImage := image.DockerfileCommands(
		[]string{
			"RUN echo hey",
			"copy ./file.txt /root/",
			"RUN echo hey",
		},
		nil,
	)
	_, err = multiInvalidImage.Build(app)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("COPY commands that copy from local context are not yet supported"))
}

func TestDockerfileCommandsWithOptions(t *testing.T) {
	g := gomega.NewWithT(t)

	mock, cleanup := grpcmock.Install()
	t.Cleanup(cleanup)

	grpcmock.HandleUnary(
		mock, "ImageGetOrCreate",
		func(req *pb.ImageGetOrCreateRequest) (*pb.ImageGetOrCreateResponse, error) {
			g.Expect(req.GetAppId()).To(gomega.Equal("ap-test"))
			image := req.GetImage()
			g.Expect(image.GetDockerfileCommands()).To(gomega.Equal([]string{"FROM alpine:3.21"}))
			g.Expect(image.GetSecretIds()).To(gomega.BeEmpty())
			g.Expect(image.GetBaseImages()).To(gomega.BeEmpty())
			g.Expect(image.GetGpuConfig()).To(gomega.BeNil())
			g.Expect(req.GetForceBuild()).To(gomega.BeFalse())

			return pb.ImageGetOrCreateResponse_builder{
				ImageId: "im-base",
				Result:  pb.GenericResult_builder{Status: pb.GenericResult_GENERIC_STATUS_SUCCESS}.Build(),
			}.Build(), nil
		},
	)

	grpcmock.HandleUnary(
		mock, "ImageGetOrCreate",
		func(req *pb.ImageGetOrCreateRequest) (*pb.ImageGetOrCreateResponse, error) {
			g.Expect(req.GetAppId()).To(gomega.Equal("ap-test"))
			image := req.GetImage()
			g.Expect(image.GetDockerfileCommands()).To(gomega.Equal([]string{"FROM base", "RUN echo layer1"}))
			g.Expect(image.GetSecretIds()).To(gomega.BeEmpty())
			g.Expect(image.GetBaseImages()).To(gomega.HaveLen(1))
			g.Expect(image.GetBaseImages()[0].GetDockerTag()).To(gomega.Equal("base"))
			g.Expect(image.GetBaseImages()[0].GetImageId()).To(gomega.Equal("im-base"))
			g.Expect(image.GetGpuConfig()).To(gomega.BeNil())
			g.Expect(req.GetForceBuild()).To(gomega.BeFalse())

			return pb.ImageGetOrCreateResponse_builder{
				ImageId: "im-layer1",
				Result:  pb.GenericResult_builder{Status: pb.GenericResult_GENERIC_STATUS_SUCCESS}.Build(),
			}.Build(), nil
		},
	)

	grpcmock.HandleUnary(
		mock, "ImageGetOrCreate",
		func(req *pb.ImageGetOrCreateRequest) (*pb.ImageGetOrCreateResponse, error) {
			g.Expect(req.GetAppId()).To(gomega.Equal("ap-test"))
			image := req.GetImage()
			g.Expect(image.GetDockerfileCommands()).To(gomega.Equal([]string{"FROM base", "RUN echo layer2"}))
			g.Expect(image.GetSecretIds()).To(gomega.Equal([]string{"sc-test"}))
			g.Expect(image.GetBaseImages()).To(gomega.HaveLen(1))
			g.Expect(image.GetBaseImages()[0].GetDockerTag()).To(gomega.Equal("base"))
			g.Expect(image.GetBaseImages()[0].GetImageId()).To(gomega.Equal("im-layer1"))
			g.Expect(image.GetGpuConfig()).ToNot(gomega.BeNil())
			g.Expect(image.GetGpuConfig().GetType()).To(gomega.Equal(pb.GPUType(0)))
			g.Expect(image.GetGpuConfig().GetCount()).To(gomega.Equal(uint32(1)))
			g.Expect(image.GetGpuConfig().GetGpuType()).To(gomega.Equal("A100"))
			g.Expect(req.GetForceBuild()).To(gomega.BeTrue())

			return pb.ImageGetOrCreateResponse_builder{
				ImageId: "im-layer2",
				Result:  pb.GenericResult_builder{Status: pb.GenericResult_GENERIC_STATUS_SUCCESS}.Build(),
			}.Build(), nil
		},
	)

	grpcmock.HandleUnary(
		mock, "ImageGetOrCreate",
		func(req *pb.ImageGetOrCreateRequest) (*pb.ImageGetOrCreateResponse, error) {
			g.Expect(req.GetAppId()).To(gomega.Equal("ap-test"))
			image := req.GetImage()
			g.Expect(image.GetDockerfileCommands()).To(gomega.Equal([]string{"FROM base", "RUN echo layer3"}))
			g.Expect(image.GetSecretIds()).To(gomega.BeEmpty())
			g.Expect(image.GetBaseImages()).To(gomega.HaveLen(1))
			g.Expect(image.GetBaseImages()[0].GetDockerTag()).To(gomega.Equal("base"))
			g.Expect(image.GetBaseImages()[0].GetImageId()).To(gomega.Equal("im-layer2"))
			g.Expect(image.GetGpuConfig()).To(gomega.BeNil())
			g.Expect(req.GetForceBuild()).To(gomega.BeTrue())

			return pb.ImageGetOrCreateResponse_builder{
				ImageId: "im-layer3",
				Result:  pb.GenericResult_builder{Status: pb.GenericResult_GENERIC_STATUS_SUCCESS}.Build(),
			}.Build(), nil
		},
	)

	app := &modal.App{AppId: "ap-test"}
	secret := &modal.Secret{SecretId: "sc-test"}

	builtImage, err := modal.NewImageFromRegistry("alpine:3.21", nil).
		DockerfileCommands([]string{"RUN echo layer1"}, nil).
		DockerfileCommands([]string{"RUN echo layer2"}, &modal.ImageDockerfileCommandsOptions{
			Secrets:    []*modal.Secret{secret},
			GPU:        "A100",
			ForceBuild: true,
		}).
		DockerfileCommands([]string{"RUN echo layer3"}, &modal.ImageDockerfileCommandsOptions{
			ForceBuild: true,
		}).
		Build(app)

	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(builtImage.ImageId).To(gomega.Equal("im-layer3"))
}



================================================
FILE: modal-go/test/proxy_test.go
================================================
//nolint:staticcheck // SA1019 We need to use deprecated API for testing
package test

import (
	"context"
	"strings"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestCreateSandboxWithProxy(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	proxy, err := modal.ProxyFromName(context.Background(), "libmodal-test-proxy", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(proxy.ProxyId).ShouldNot(gomega.BeEmpty())
	g.Expect(strings.HasPrefix(proxy.ProxyId, "pr-")).To(gomega.BeTrue())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Proxy:   proxy,
		Command: []string{"echo", "hello, Sandbox with Proxy"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	exitcode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitcode).To(gomega.Equal(137))
}

func TestProxyNotFound(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	_, err := modal.ProxyFromName(context.Background(), "non-existent-proxy-name", nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("Proxy 'non-existent-proxy-name' not found"))
}



================================================
FILE: modal-go/test/queue_test.go
================================================
package test

import (
	"context"
	"errors"
	"strconv"
	"sync"
	"testing"
	"time"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestQueueInvalidName(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	for _, name := range []string{"has space", "has/slash", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"} {
		_, err := modal.QueueLookup(context.Background(), name, nil)
		g.Expect(err).Should(gomega.HaveOccurred(), "Queue lookup should fail for invalid name: %s", name)
	}
}

func TestQueueEphemeral(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	queue, err := modal.QueueEphemeral(context.Background(), nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer queue.CloseEphemeral()
	g.Expect(queue.Name).To(gomega.BeEmpty())

	err = queue.Put(123, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	len, err := queue.Len(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(len).To(gomega.Equal(1))

	result, err := queue.Get(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(result).To(gomega.Equal(int64(123)))
}

func TestQueueSuite1(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	queue, err := modal.QueueEphemeral(ctx, nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	defer queue.CloseEphemeral()

	// queue.len() == 0
	n, err := queue.Len(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(n).To(gomega.Equal(0))

	// put / len / get
	g.Expect(queue.Put(123, nil)).ToNot(gomega.HaveOccurred())

	n, err = queue.Len(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(n).To(gomega.Equal(1))

	item, err := queue.Get(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(item).To(gomega.Equal(int64(123)))

	// put, then non-blocking get
	g.Expect(queue.Put(432, nil)).ToNot(gomega.HaveOccurred())

	var timeout time.Duration
	item, err = queue.Get(&modal.QueueGetOptions{Timeout: &timeout})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(item).To(gomega.Equal(int64(432)))

	// queue is now empty – non-blocking get should error
	_, err = queue.Get(&modal.QueueGetOptions{Timeout: &timeout})
	g.Expect(errors.As(err, &modal.QueueEmptyError{})).To(gomega.BeTrue())

	n, err = queue.Len(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(n).To(gomega.Equal(0))

	// putMany + iterator
	g.Expect(queue.PutMany([]any{1, 2, 3}, nil)).ToNot(gomega.HaveOccurred())

	results := make([]int64, 0, 3)
	for v, err := range queue.Iterate(nil) {
		g.Expect(err).ToNot(gomega.HaveOccurred())
		results = append(results, v.(int64))
	}
	g.Expect(results).To(gomega.Equal([]int64{1, 2, 3}))
}

func TestQueueSuite2(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	queue, err := modal.QueueEphemeral(ctx, nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	defer queue.CloseEphemeral()

	var wg sync.WaitGroup
	results := make([]int64, 0, 10)

	// producer
	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := range 10 {
			_ = queue.Put(i, nil) // ignore error for brevity
		}
	}()

	// consumer
	wg.Add(1)
	go func() {
		defer wg.Done()
		for v, err := range queue.Iterate(&modal.QueueIterateOptions{ItemPollTimeout: time.Second}) {
			g.Expect(err).ToNot(gomega.HaveOccurred())
			results = append(results, v.(int64))
		}
	}()

	wg.Wait()
	g.Expect(results).To(gomega.Equal([]int64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))
}

func TestQueuePutAndGetMany(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	queue, err := modal.QueueEphemeral(ctx, nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	defer queue.CloseEphemeral()

	g.Expect(queue.PutMany([]any{1, 2, 3}, nil)).ToNot(gomega.HaveOccurred())

	n, err := queue.Len(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(n).To(gomega.Equal(3))

	items, err := queue.GetMany(3, nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(items).To(gomega.Equal([]any{int64(1), int64(2), int64(3)}))
}

func TestQueueNonBlocking(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	queue, err := modal.QueueEphemeral(ctx, nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	defer queue.CloseEphemeral()

	var timeout time.Duration
	err = queue.Put(123, &modal.QueuePutOptions{Timeout: &timeout})
	g.Expect(err).ToNot(gomega.HaveOccurred())

	n, err := queue.Len(nil)
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(n).To(gomega.Equal(1))

	item, err := queue.Get(&modal.QueueGetOptions{Timeout: &timeout})
	g.Expect(err).ToNot(gomega.HaveOccurred())
	g.Expect(item).To(gomega.Equal(int64(123)))
}

func TestQueueNonEphemeral(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	queueName := "test-queue-" + strconv.FormatInt(time.Now().UnixNano(), 10)
	queue1, err := modal.QueueLookup(ctx, queueName, &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(queue1.Name).To(gomega.Equal(queueName))

	defer func() {
		err := modal.QueueDelete(ctx, queueName, nil)
		g.Expect(err).ShouldNot(gomega.HaveOccurred())

		_, err = modal.QueueLookup(ctx, queueName, nil)
		g.Expect(err).Should(gomega.HaveOccurred())
	}()

	err = queue1.Put("data", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	queue2, err := modal.QueueLookup(ctx, queueName, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	value, err := queue2.Get(nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(value).To(gomega.Equal("data"))
}

func TestQueueCloseEphemeral(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	ctx := context.Background()
	queue, err := modal.QueueEphemeral(ctx, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	err = queue.Put("test-data", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	queue.CloseEphemeral()

	err = queue.Put("should-fail", nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("context canceled"))

	// The external context should not have been cancelled by CloseEphemeral
	g.Expect(ctx.Err()).Should(gomega.BeNil())
}



================================================
FILE: modal-go/test/retries_test.go
================================================
package test

import (
	"testing"
	"time"

	modal "github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestRetriesConstructor(t *testing.T) {
	g := gomega.NewWithT(t)

	backoff := float32(2.0)
	initial := 2 * time.Second
	max := 5 * time.Second
	r, err := modal.NewRetries(2, &modal.RetriesOptions{
		BackoffCoefficient: &backoff,
		InitialDelay:       &initial,
		MaxDelay:           &max,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(r.MaxRetries).To(gomega.Equal(2))
	g.Expect(r.BackoffCoefficient).To(gomega.Equal(float32(2.0)))
	g.Expect(r.InitialDelay).To(gomega.Equal(2 * time.Second))
	g.Expect(r.MaxDelay).To(gomega.Equal(5 * time.Second))

	r, err = modal.NewRetries(3, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(r.MaxRetries).To(gomega.Equal(3))
	g.Expect(r.BackoffCoefficient).To(gomega.Equal(float32(2.0)))
	g.Expect(r.InitialDelay).To(gomega.Equal(1 * time.Second))
	g.Expect(r.MaxDelay).To(gomega.Equal(60 * time.Second))

	zeroDelay := 0 * time.Millisecond
	r, err = modal.NewRetries(1, &modal.RetriesOptions{
		InitialDelay: &zeroDelay,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(r.InitialDelay).To(gomega.Equal(0 * time.Millisecond))
	g.Expect(r.BackoffCoefficient).To(gomega.Equal(float32(2.0))) // default
	g.Expect(r.MaxDelay).To(gomega.Equal(60 * time.Second))       // default

	_, err = modal.NewRetries(-1, nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("maxRetries"))

	invalidBackoff := float32(0.9)
	_, err = modal.NewRetries(0, &modal.RetriesOptions{BackoffCoefficient: &invalidBackoff})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("backoffCoefficient"))

	invalidInitial := 61 * time.Second
	_, err = modal.NewRetries(0, &modal.RetriesOptions{InitialDelay: &invalidInitial})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("initialDelay"))

	invalidMax := 500 * time.Millisecond
	_, err = modal.NewRetries(0, &modal.RetriesOptions{MaxDelay: &invalidMax})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("maxDelay"))
}



================================================
FILE: modal-go/test/sandbox_filesystem_snapshot_test.go
================================================
//nolint:staticcheck // SA1019 We need to use deprecated API for testing
package test

import (
	"context"
	"io"
	"testing"
	"time"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestSnapshotFilesystem(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	_, err = sb.Exec([]string{"sh", "-c", "echo -n 'test content' > /tmp/test.txt"}, modal.ExecOptions{})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = sb.Exec([]string{"mkdir", "-p", "/tmp/testdir"}, modal.ExecOptions{})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	snapshotImage, err := sb.SnapshotFilesystem(55 * time.Second)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(snapshotImage).ShouldNot(gomega.BeNil())
	g.Expect(snapshotImage.ImageId).To(gomega.HavePrefix("im-"))

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Create new Sandbox from snapshot
	sb2, err := app.CreateSandbox(snapshotImage, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb2.Terminate()

	// Verify file exists in snapshot
	proc, err := sb2.Exec([]string{"cat", "/tmp/test.txt"}, modal.ExecOptions{})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output, err := io.ReadAll(proc.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("test content"))

	// Verify directory exists in snapshot
	dirCheck, err := sb2.Exec([]string{"test", "-d", "/tmp/testdir"}, modal.ExecOptions{})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	exitCode, err := dirCheck.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).To(gomega.Equal(0))
}



================================================
FILE: modal-go/test/sandbox_filesystem_test.go
================================================
//nolint:staticcheck // SA1019 We need to use deprecated API for testing
package test

import (
	"bytes"
	"context"
	"io"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func createSandbox(g *gomega.WithT) *modal.Sandbox {
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())
	return sb
}

func terminateSandbox(g *gomega.WithT, sb *modal.Sandbox) {
	err := sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestSandboxWriteAndReadBinaryFile(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	writer, err := sb.Open("/tmp/test.bin", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	text := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	n, err := writer.Write(text)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(text)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader, err := sb.Open("/tmp/test.bin", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output := make([]byte, 10)
	n, err = reader.Read(output)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(10))
	g.Expect(output).Should(gomega.Equal(text))

	err = reader.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestSandboxAppendToFileBinary(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	writer, err := sb.Open("/tmp/append.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	text := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	n, err := writer.Write(text)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(text)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	appender, err := sb.Open("/tmp/append.txt", "a")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	more_text := []byte{7, 8, 9, 10}
	appender.Write(more_text)

	reader, err := sb.Open("/tmp/append.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	expected_text := []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 7, 8, 9, 10}
	out, err := io.ReadAll(reader)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(out).Should(gomega.Equal(expected_text))

	err = reader.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}
func TestSandboxFileFlush(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	writer, err := sb.Open("/tmp/flush.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	text := []byte("Test data")
	n, err := writer.Write(text)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(text)))
	err = writer.Flush()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader, err := sb.Open("/tmp/flush.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	out, err := io.ReadAll(reader)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(out).Should(gomega.Equal(text))

	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	err = reader.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestSandboxMultipleFileOperations(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	content1 := []byte("File 1 content")
	writer, err := sb.Open("/tmp/file1.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	n, err := writer.Write(content1)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(content1)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	content2 := []byte("File 2 content")
	writer, err = sb.Open("/tmp/file2.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	n, err = writer.Write(content2)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(content2)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader1, err := sb.Open("/tmp/file1.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	readContent1, err := io.ReadAll(reader1)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	err = reader1.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader2, err := sb.Open("/tmp/file2.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	readContent2, err := io.ReadAll(reader2)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	err = reader2.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(readContent1).Should(gomega.Equal(content1))
	g.Expect(readContent2).Should(gomega.Equal(content2))

}

func TestSandboxFileOpenModes(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	// Test write mode (truncates)
	content1 := []byte("Initial content")
	writer, err := sb.Open("/tmp/modes.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	n, err := writer.Write(content1)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(content1)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Test read mode
	reader1, err := sb.Open("/tmp/modes.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	readContent1, err := io.ReadAll(reader1)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(readContent1).Should(gomega.Equal(content1))
	err = reader1.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	// Test append mode
	content2 := []byte(" appended")
	appender, err := sb.Open("/tmp/modes.txt", "a")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	n, err = appender.Write(content2)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(content2)))
	err = appender.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader2, err := sb.Open("/tmp/modes.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	readContent2, err := io.ReadAll(reader2)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	expectedContent := []byte("Initial content appended")
	g.Expect(readContent2).Should(gomega.Equal(expectedContent))
	err = reader2.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestSandboxLargeFileOperations(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	sb := createSandbox(g)
	defer terminateSandbox(g, sb)

	xByte := []byte{'x'}
	largeData := bytes.Repeat(xByte, 1000)

	writer, err := sb.Open("/tmp/large.txt", "w")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	n, err := writer.Write(largeData)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(n).Should(gomega.Equal(len(largeData)))
	err = writer.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	reader1, err := sb.Open("/tmp/large.txt", "r")
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	readContent1, err := io.ReadAll(reader1)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(readContent1).Should(gomega.Equal(largeData))
	err = reader1.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}



================================================
FILE: modal-go/test/sandbox_test.go
================================================
//nolint:staticcheck // SA1019 We need to use deprecated API for testing
package test

import (
	"context"
	"fmt"
	"io"
	"math/rand"
	"testing"
	"time"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestCreateOneSandbox(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(app.Name).To(gomega.Equal("libmodal-test"))

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	exitcode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitcode).To(gomega.Equal(137))
}

func TestPassCatToStdin(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{Command: []string{"cat"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	_, err = sb.Stdin.Write([]byte("this is input that should be mirrored by cat"))
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	err = sb.Stdin.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("this is input that should be mirrored by cat"))

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestIgnoreLargeStdout(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("python:3.13-alpine", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	p, err := sb.Exec([]string{"python", "-c", `print("a" * 1_000_000)`}, modal.ExecOptions{Stdout: modal.Ignore})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	buf, err := io.ReadAll(p.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(len(buf)).To(gomega.Equal(0)) // Stdout is ignored

	// Stdout should be consumed after cancel, without blocking the process.
	exitCode, err := p.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).To(gomega.Equal(0))
}

func TestSandboxCreateOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"echo", "hello, params"},
		Cloud:   "aws",
		Regions: []string{"us-east-1", "us-west-2"},
		Verbose: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb).ShouldNot(gomega.BeNil())
	g.Expect(sb.SandboxId).Should(gomega.HavePrefix("sb-"))

	defer sb.Terminate()

	exitCode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).Should(gomega.Equal(0))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		Cloud: "invalid-cloud",
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("InvalidArgument"))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		Regions: []string{"invalid-region"},
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("InvalidArgument"))
}

func TestSandboxExecOptions(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	// Test with a custom working directory and timeout.
	p, err := sb.Exec([]string{"pwd"}, modal.ExecOptions{
		Workdir: "/tmp",
		Timeout: 5,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output, err := io.ReadAll(p.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("/tmp\n"))

	exitCode, err := p.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).To(gomega.Equal(0))
}

func TestSandboxWithVolume(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	volume, err := modal.VolumeFromName(ctx, "libmodal-test-sandbox-volume", &modal.VolumeFromNameOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"echo", "volume test"},
		Volumes: map[string]*modal.Volume{
			"/mnt/test": volume,
		},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sandbox).ShouldNot(gomega.BeNil())
	g.Expect(sandbox.SandboxId).Should(gomega.HavePrefix("sb-"))

	exitCode, err := sandbox.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).Should(gomega.Equal(0))
}

func TestSandboxWithReadOnlyVolume(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil)

	volume, err := modal.VolumeFromName(ctx, "libmodal-test-sandbox-volume", &modal.VolumeFromNameOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	readOnlyVolume := volume.ReadOnly()
	g.Expect(readOnlyVolume.IsReadOnly()).To(gomega.BeTrue())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-c", "echo 'test' > /mnt/test/test.txt"},
		Volumes: map[string]*modal.Volume{
			"/mnt/test": readOnlyVolume,
		},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	exitCode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).Should(gomega.Equal(1))

	stderr, err := io.ReadAll(sb.Stderr)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(stderr)).Should(gomega.ContainSubstring("Read-only file system"))

	err = sb.Terminate()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
}

func TestSandboxWithTunnels(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command:          []string{"cat"},
		EncryptedPorts:   []int{8443},
		UnencryptedPorts: []int{8080},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sandbox).ShouldNot(gomega.BeNil())
	g.Expect(sandbox.SandboxId).Should(gomega.HavePrefix("sb-"))

	defer sandbox.Terminate()

	tunnels, err := sandbox.Tunnels(30 * time.Second)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(tunnels).Should(gomega.HaveLen(2))

	// Test encrypted tunnel (port 8443)
	encryptedTunnel := tunnels[8443]
	g.Expect(encryptedTunnel.Host).Should(gomega.MatchRegexp(`\.modal\.host$`))
	g.Expect(encryptedTunnel.Port).Should(gomega.Equal(443))
	g.Expect(encryptedTunnel.URL()).Should(gomega.HavePrefix("https://"))

	host, port := encryptedTunnel.TLSSocket()
	g.Expect(host).Should(gomega.Equal(encryptedTunnel.Host))
	g.Expect(port).Should(gomega.Equal(encryptedTunnel.Port))

	// Test unencrypted tunnel (port 8080)
	unencryptedTunnel := tunnels[8080]
	g.Expect(unencryptedTunnel.UnencryptedHost).Should(gomega.MatchRegexp(`\.modal\.host$`))
	g.Expect(unencryptedTunnel.UnencryptedPort).Should(gomega.BeNumerically(">", 0))

	tcpHost, tcpPort, err := unencryptedTunnel.TCPSocket()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(tcpHost).Should(gomega.Equal(unencryptedTunnel.UnencryptedHost))
	g.Expect(tcpPort).Should(gomega.Equal(unencryptedTunnel.UnencryptedPort))
}

func TestCreateSandboxWithSecrets(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{RequiredKeys: []string{"c"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{Secrets: []*modal.Secret{secret}, Command: []string{"printenv", "c"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("hello world\n"))
}
func TestSandboxPollAndReturnCode(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{Command: []string{"cat"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	pollResult, err := sandbox.Poll()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(pollResult).Should(gomega.BeNil())

	// Send input to make the cat command complete
	_, err = sandbox.Stdin.Write([]byte("hello, sandbox"))
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	err = sandbox.Stdin.Close()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	waitResult, err := sandbox.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(waitResult).To(gomega.Equal(0))

	pollResult, err = sandbox.Poll()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(pollResult).ShouldNot(gomega.BeNil())
	g.Expect(*pollResult).To(gomega.Equal(0))
}

func TestSandboxPollAfterFailure(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sandbox, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"sh", "-c", "exit 42"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	waitResult, err := sandbox.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(waitResult).To(gomega.Equal(42))

	pollResult, err := sandbox.Poll()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(pollResult).ShouldNot(gomega.BeNil())
	g.Expect(*pollResult).To(gomega.Equal(42))
}

func TestCreateSandboxWithNetworkAccessParams(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command:       []string{"echo", "hello, network access"},
		BlockNetwork:  false,
		CIDRAllowlist: []string{"10.0.0.0/8", "192.168.0.0/16"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb).ShouldNot(gomega.BeNil())
	g.Expect(sb.SandboxId).Should(gomega.HavePrefix("sb-"))

	defer sb.Terminate()

	exitCode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).Should(gomega.Equal(0))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		BlockNetwork:  false,
		CIDRAllowlist: []string{"not-an-ip/8"},
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("Invalid CIDR: not-an-ip/8"))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		BlockNetwork:  true,
		CIDRAllowlist: []string{"10.0.0.0/8"},
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).Should(gomega.ContainSubstring("CIDRAllowlist cannot be used when BlockNetwork is enabled"))
}

func TestSandboxExecSecret(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())
	defer sb.Terminate()

	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{RequiredKeys: []string{"c"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret2, err := modal.SecretFromMap(context.Background(), map[string]string{"d": "3"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	p, err := sb.Exec([]string{"printenv", "c", "d"}, modal.ExecOptions{Stdout: modal.Pipe, Secrets: []*modal.Secret{secret, secret2}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	buf, err := io.ReadAll(p.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(buf)).Should(gomega.Equal("hello world\n3\n"))
}

func TestSandboxFromId(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})

	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())
	defer sb.Terminate()

	sbFromId, err := modal.SandboxFromId(ctx, sb.SandboxId)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sbFromId.SandboxId).Should(gomega.Equal(sb.SandboxId))
}

func TestSandboxWithWorkdir(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Command: []string{"pwd"},
		Workdir: "/tmp",
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	output, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("/tmp\n"))

	exitCode, err := sb.Wait()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(exitCode).To(gomega.Equal(0))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		Workdir: "relative/path",
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("the Workdir value must be an absolute path"))
}

func TestSandboxSetTagsAndList(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	unique := fmt.Sprintf("%d", rand.Int())

	var before []string
	it, err := modal.SandboxList(ctx, &modal.SandboxListOptions{Tags: map[string]string{"test-key": unique}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		before = append(before, s.SandboxId)
	}
	g.Expect(before).To(gomega.HaveLen(0))

	err = sb.SetTags(map[string]string{"test-key": unique})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	var after []string
	it, err = modal.SandboxList(ctx, &modal.SandboxListOptions{Tags: map[string]string{"test-key": unique}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		after = append(after, s.SandboxId)
	}
	g.Expect(after).To(gomega.Equal([]string{sb.SandboxId}))
}

func TestSandboxTags(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	retrievedTagsBefore, err := sb.GetTags()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(retrievedTagsBefore).To(gomega.Equal(map[string]string{}))

	tagA := fmt.Sprintf("%d", rand.Int())
	tagB := fmt.Sprintf("%d", rand.Int())
	tagC := fmt.Sprintf("%d", rand.Int())

	err = sb.SetTags(map[string]string{"key-a": tagA, "key-b": tagB, "key-c": tagC})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	retrievedTags, err := sb.GetTags()
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(retrievedTags).To(gomega.Equal(map[string]string{"key-a": tagA, "key-b": tagB, "key-c": tagC}))

	var ids []string
	it, err := modal.SandboxList(ctx, &modal.SandboxListOptions{Tags: map[string]string{"key-a": tagA}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		ids = append(ids, s.SandboxId)
	}
	g.Expect(ids).To(gomega.Equal([]string{sb.SandboxId}))

	ids = nil
	it, err = modal.SandboxList(ctx, &modal.SandboxListOptions{Tags: map[string]string{"key-a": tagA, "key-b": tagB}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		ids = append(ids, s.SandboxId)
	}
	g.Expect(ids).To(gomega.Equal([]string{sb.SandboxId}))

	ids = nil
	it, err = modal.SandboxList(ctx, &modal.SandboxListOptions{Tags: map[string]string{"key-a": tagA, "key-b": tagB, "key-d": "not-set"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		ids = append(ids, s.SandboxId)
	}
	g.Expect(ids).To(gomega.HaveLen(0))
}

func TestSandboxListByAppId(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sb, err := app.CreateSandbox(image, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer sb.Terminate()

	count := 0
	it, err := modal.SandboxList(ctx, &modal.SandboxListOptions{AppId: app.AppId})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	for s, err := range it {
		g.Expect(err).ShouldNot(gomega.HaveOccurred())
		g.Expect(s.SandboxId).Should(gomega.HavePrefix("sb-"))
		count++
		if count >= 1 {
			break
		}
	}
	g.Expect(count).ToNot(gomega.Equal(0))
}

func TestNamedSandbox(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	app, err := modal.AppLookup(ctx, "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image, err := app.ImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	sandboxName := fmt.Sprintf("test-sandbox-%d", rand.Int())

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{
		Name:    sandboxName,
		Command: []string{"sleep", "60"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb.SandboxId).ShouldNot(gomega.BeEmpty())

	defer sb.Terminate()

	sb1FromName, err := modal.SandboxFromName(ctx, "libmodal-test", sandboxName, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb1FromName.SandboxId).To(gomega.Equal(sb.SandboxId))

	sb2FromName, err := modal.SandboxFromName(ctx, "libmodal-test", sandboxName, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(sb2FromName.SandboxId).To(gomega.Equal(sb1FromName.SandboxId))

	_, err = app.CreateSandbox(image, &modal.SandboxOptions{
		Name:    sandboxName,
		Command: []string{"sleep", "60"},
	})
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("already exists"))
}

func TestNamedSandboxNotFound(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	ctx := context.Background()

	_, err := modal.SandboxFromName(ctx, "libmodal-test", "non-existent-sandbox", nil)
	g.Expect(err).Should(gomega.HaveOccurred())
	g.Expect(err.Error()).To(gomega.ContainSubstring("not found"))
}



================================================
FILE: modal-go/test/secret_test.go
================================================
package test

import (
	"context"
	"io"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestSecretFromName(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(secret.SecretId).Should(gomega.HavePrefix("st-"))
	g.Expect(secret.Name).To(gomega.Equal("libmodal-test-secret"))

	_, err = modal.SecretFromName(context.Background(), "missing-secret", nil)
	g.Expect(err).Should(gomega.MatchError(gomega.ContainSubstring("Secret 'missing-secret' not found")))
}

func TestSecretFromNameWithRequiredKeys(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	secret, err := modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"a", "b", "c"},
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(secret.SecretId).Should(gomega.HavePrefix("st-"))

	_, err = modal.SecretFromName(context.Background(), "libmodal-test-secret", &modal.SecretFromNameOptions{
		RequiredKeys: []string{"a", "b", "c", "missing-key"},
	})
	g.Expect(err).Should(gomega.MatchError(gomega.ContainSubstring("Secret is missing key(s): missing-key")))
}

func TestSecretFromMap(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	app, err := modal.AppLookup(context.Background(), "libmodal-test", &modal.LookupOptions{CreateIfMissing: true})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	image := modal.NewImageFromRegistry("alpine:3.21", nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	secret, err := modal.SecretFromMap(context.Background(), map[string]string{"key": "value"}, nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(secret.SecretId).Should(gomega.HavePrefix("st-"))

	sb, err := app.CreateSandbox(image, &modal.SandboxOptions{Secrets: []*modal.Secret{secret}, Command: []string{"printenv", "key"}})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	output, err := io.ReadAll(sb.Stdout)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(string(output)).To(gomega.Equal("value\n"))
}



================================================
FILE: modal-go/test/volume_test.go
================================================
package test

import (
	"context"
	"testing"

	"github.com/modal-labs/libmodal/modal-go"
	"github.com/onsi/gomega"
)

func TestVolumeFromName(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	volume, err := modal.VolumeFromName(context.Background(), "libmodal-test-volume", &modal.VolumeFromNameOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	g.Expect(volume).ShouldNot(gomega.BeNil())
	g.Expect(volume.VolumeId).Should(gomega.HavePrefix("vo-"))
	g.Expect(volume.Name).To(gomega.Equal("libmodal-test-volume"))

	_, err = modal.VolumeFromName(context.Background(), "missing-volume", nil)
	g.Expect(err).Should(gomega.MatchError(gomega.ContainSubstring("Volume 'missing-volume' not found")))
}

func TestVolumeReadOnly(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)
	volume, err := modal.VolumeFromName(context.Background(), "libmodal-test-volume", &modal.VolumeFromNameOptions{
		CreateIfMissing: true,
	})
	g.Expect(err).ShouldNot(gomega.HaveOccurred())

	g.Expect(volume.IsReadOnly()).To(gomega.BeFalse())

	readOnlyVolume := volume.ReadOnly()
	g.Expect(readOnlyVolume.IsReadOnly()).To(gomega.BeTrue())
	g.Expect(readOnlyVolume.VolumeId).To(gomega.Equal(volume.VolumeId))
	g.Expect(readOnlyVolume.Name).To(gomega.Equal(volume.Name))

	g.Expect(volume.IsReadOnly()).To(gomega.BeFalse())
}

func TestVolumeEphemeral(t *testing.T) {
	t.Parallel()
	g := gomega.NewWithT(t)

	volume, err := modal.VolumeEphemeral(context.Background(), nil)
	g.Expect(err).ShouldNot(gomega.HaveOccurred())
	defer volume.CloseEphemeral()
	g.Expect(volume.Name).To(gomega.BeEmpty())
	g.Expect(volume.VolumeId).Should(gomega.HavePrefix("vo-"))
	g.Expect(volume.IsReadOnly()).To(gomega.BeFalse())
	g.Expect(volume.ReadOnly().IsReadOnly()).To(gomega.BeTrue())
}



================================================
FILE: modal-go/testsupport/grpcmock/mock.go
================================================
package grpcmock

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"google.golang.org/grpc"
	"google.golang.org/protobuf/proto"

	modal "github.com/modal-labs/libmodal/modal-go"
	pb "github.com/modal-labs/libmodal/modal-go/proto/modal_proto"
)

// unaryHandler handles a single unary RPC request and returns a response.
type unaryHandler func(proto.Message) (proto.Message, error)

type Mock struct {
	// mu guards access to internal state.
	mu sync.Mutex
	// methodHandlerQueues maps short RPC names to FIFO queues of handlers.
	methodHandlerQueues map[string][]unaryHandler
	// conn is the fake ClientConn used by the SDK client.
	conn *mockClientConn
}

// Install swaps the SDK client factory to use a mock gRPC connection.
// Register the returned cleanup function with t.Cleanup.
func Install() (*Mock, func()) {
	m := &Mock{methodHandlerQueues: map[string][]unaryHandler{}}
	m.conn = &mockClientConn{mock: m}

	restore := modal.SetClientFactoryForTesting(func(profile modal.Profile) (grpc.ClientConnInterface, pb.ModalClientClient, error) {
		return m.conn, pb.NewModalClientClient(m.conn), nil
	})
	cleanup := func() {
		if err := m.AssertExhausted(); err != nil {
			panic(err)
		}
		restore()
	}
	return m, cleanup
}

// HandleUnary registers a typed handler for a unary RPC, e.g. "/FunctionGetCurrentStats".
func HandleUnary[Req proto.Message, Resp proto.Message](m *Mock, rpc string, handler func(Req) (Resp, error)) {
	m.mu.Lock()
	defer m.mu.Unlock()
	name := shortName(rpc)
	q := m.methodHandlerQueues[name]
	wrapped := unaryHandler(func(in proto.Message) (proto.Message, error) {
		req, ok := any(in).(Req)
		if !ok {
			return nil, fmt.Errorf("grpcmock: request type mismatch for %s: expected %T, got %T", name, *new(Req), in)
		}
		resp, err := handler(req)
		if err != nil {
			return nil, err
		}
		var out proto.Message = resp
		return out, nil
	})
	m.methodHandlerQueues[name] = append(q, wrapped)
}

// AssertExhausted errors unless all registered mock expectations have been consumed.
func (m *Mock) AssertExhausted() error {
	m.mu.Lock()
	defer m.mu.Unlock()
	var outstanding []string
	for k, q := range m.methodHandlerQueues {
		if len(q) > 0 {
			outstanding = append(outstanding, fmt.Sprintf("%s: %d remaining", k, len(q)))
		}
	}
	if len(outstanding) > 0 {
		return fmt.Errorf("not all expected gRPC calls were made:\n- %s", strings.Join(outstanding, "\n- "))
	}
	return nil
}

// mockClientConn implements grpc.ClientConnInterface for unary calls.
type mockClientConn struct{ mock *Mock }

// Invoke implements grpc.ClientConnInterface.Invoke for unary RPCs.
func (c *mockClientConn) Invoke(ctx context.Context, method string, in, out any, opts ...grpc.CallOption) error {
	name := shortName(method)
	handler, err := c.dequeueNextHandler(name)
	if err != nil {
		return err
	}
	resp, err := handler(in.(proto.Message))
	if err != nil {
		return err
	}
	if resp != nil {
		if outMsg, ok := out.(proto.Message); ok {
			proto.Merge(outMsg, resp)
		} else {
			return fmt.Errorf("grpcmock: response cannot be written into type %T", out)
		}
	}
	return nil
}

// NewStream returns an error because streaming RPCs are not supported yet.
func (c *mockClientConn) NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) {
	return nil, fmt.Errorf("grpcmock: streaming not implemented for %s", shortName(method))
}

func (c *mockClientConn) dequeueNextHandler(method string) (unaryHandler, error) {
	c.mock.mu.Lock()
	defer c.mock.mu.Unlock()
	q := c.mock.methodHandlerQueues[method]
	if len(q) == 0 {
		return nil, fmt.Errorf("grpcmock: unexpected gRPC call to %s", method)
	}
	h := q[0]
	c.mock.methodHandlerQueues[method] = q[1:]
	return h, nil
}

func shortName(method string) string {
	if strings.HasPrefix(method, "/") {
		if idx := strings.LastIndex(method, "/"); idx >= 0 && idx+1 < len(method) {
			return method[idx+1:]
		}
	}
	return method
}



================================================
FILE: modal-js/README.md
================================================
# Modal JavaScript Library

[![Documentation](https://img.shields.io/badge/docs-reference-blue)](https://modal-labs.github.io/libmodal/)
[![Version](https://img.shields.io/npm/v/modal.svg)](https://www.npmjs.org/package/modal)
[![Build Status](https://github.com/modal-labs/libmodal/actions/workflows/ci.yaml/badge.svg?branch=main)](https://github.com/modal-labs/libmodal/actions?query=branch%3Amain)
[![Downloads](https://img.shields.io/npm/dm/modal.svg)](https://www.npmjs.com/package/modal)

The [Modal](https://modal.com/) JavaScript SDK allows you to run Modal Functions and Sandboxes from server-side JavaScript applications.

It comes with built-in TypeScript type definitions.

## Documentation

See the [documentation and examples](https://github.com/modal-labs/libmodal?tab=readme-ov-file#javascript-modal-js) on GitHub.

## Requirements

Node 22 or higher. We bundle both ES Modules and CommonJS formats, so you can load the package with either `import` or `require()` in any project.

## Installation

Install the package with

```bash
npm install modal
```



================================================
FILE: modal-js/eslint.config.js
================================================
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import { defineConfig, globalIgnores } from "eslint/config";

export default defineConfig([
  globalIgnores(["dist", "docs", "proto"]),
  {
    files: ["**/*.{js,mjs,cjs,ts,mts,cts}"],
    plugins: { js },
    extends: ["js/recommended"],
  },
  {
    files: ["**/*.{js,mjs,cjs,ts,mts,cts}"],
    languageOptions: { globals: globals.node },
  },
  tseslint.configs.recommended,
  {
    files: ["**/*.{ts,mts,cts}"],
    languageOptions: {
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
    rules: {
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          args: "all",
          argsIgnorePattern: "^_",
          caughtErrors: "all",
          caughtErrorsIgnorePattern: "^_",
          destructuredArrayIgnorePattern: "^_",
          varsIgnorePattern: "^_",
          ignoreRestSiblings: true,
        },
      ],
      // We added this lint because `tsx` gets confused when you export types
      // without using the `type` keyword.
      "@typescript-eslint/consistent-type-exports": "error",
      "object-shorthand": "warn",
    },
  },
]);



================================================
FILE: modal-js/package.json
================================================
{
  "name": "modal",
  "version": "0.3.24",
  "description": "Modal client library for JavaScript",
  "license": "Apache-2.0",
  "homepage": "https://modal.com/docs",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/modal-labs/libmodal.git"
  },
  "bugs": "https://github.com/modal-labs/libmodal/issues",
  "type": "module",
  "sideEffects": false,
  "files": [
    "/dist"
  ],
  "main": "dist/index.js",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs"
    }
  },
  "types": "dist/index.d.ts",
  "module": "dist/index.js",
  "scripts": {
    "build": "tsup",
    "check": "tsc",
    "docs": "typedoc src/index.ts --treatWarningsAsErrors",
    "docs:serve": "npm run docs && http-server ./docs",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "lint": "eslint",
    "prepare": "scripts/gen-proto.sh",
    "test": "vitest",
    "version": "npm run check && git add -A && git commit -m \"modal-js/v$npm_package_version\"",
    "prepublishOnly": "npm run build && git push",
    "postpublish": "git tag modal-js/v$npm_package_version && git push --tags"
  },
  "dependencies": {
    "long": "^5.3.1",
    "nice-grpc": "^2.1.12",
    "protobufjs": "^7.5.0",
    "smol-toml": "^1.3.3",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.28.0",
    "@types/node": "^22.15.2",
    "eslint": "^9.28.0",
    "globals": "^16.2.0",
    "grpc-tools": "^1.13.0",
    "http-server": "^14.1.1",
    "p-queue": "^8.1.0",
    "prettier": "^3.5.3",
    "ts-proto": "^2.7.0",
    "tsup": "^8.4.0",
    "tsx": "^4.19.3",
    "typedoc": "^0.28.5",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.33.1",
    "vitest": "^3.1.2"
  }
}



================================================
FILE: modal-js/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Preserve",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "noEmit": true,
    "paths": {
      "modal": ["./src/index.ts"]
    }
  },
  "include": ["src", "examples", "test", "*.config.ts"]
}



================================================
FILE: modal-js/tsup.config.ts
================================================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["esm", "cjs"],
  dts: true,
  clean: true,
});



================================================
FILE: modal-js/vitest.config.ts
================================================
import { defineConfig } from "vitest/config";
import path from "node:path";

export default defineConfig({
  test: {
    maxConcurrency: 10,
    slowTestThreshold: 5_000,
    testTimeout: 20_000,
    reporters: ["verbose"],
  },
  resolve: {
    alias: {
      modal: path.resolve(__dirname, "./src/index.ts"),
    },
  },
});



================================================
FILE: modal-js/examples/cls-call-with-options.ts
================================================
// This example calls a Modal Cls defined in `libmodal_test_support.py`,
// and overrides the default options.

import { Cls, Secret } from "modal";

const cls = await Cls.lookup("libmodal-test-support", "EchoClsParametrized");
const instance = await cls.instance();
const method = instance.method("echo_env_var");

const instanceWithOptions = await cls
  .withOptions({
    secrets: [await Secret.fromObject({ SECRET_MESSAGE: "hello, Secret" })],
  })
  .withConcurrency({ maxInputs: 1 })
  .instance();
const methodWithOptions = instanceWithOptions.method("echo_env_var");

// Call the Cls function, without the Secret being set.
console.log(await method.remote(["SECRET_MESSAGE"]));

// Call the Cls function with overrides, and confirm that the Secret is set.
console.log(await methodWithOptions.remote(["SECRET_MESSAGE"]));



================================================
FILE: modal-js/examples/cls-call.ts
================================================
// This example calls a Modal Cls defined in `libmodal_test_support.py`.

import { Cls } from "modal";

const cls = await Cls.lookup("libmodal-test-support", "EchoCls");
const instance = await cls.instance();
const method = instance.method("echo_string");

// Call the Cls function with args.
let ret = await method.remote(["Hello world!"]);
console.log(ret);

// Call the Cls function with kwargs.
ret = await method.remote([], { s: "Hello world!" });
console.log(ret);



================================================
FILE: modal-js/examples/function-call.ts
================================================
// This example calls a Function defined in `libmodal_test_support.py`.

import { Function_ } from "modal";

const echo = await Function_.lookup("libmodal-test-support", "echo_string");

// Call the Function with args.
let ret = await echo.remote(["Hello world!"]);
console.log(ret);

// Call the Function with kwargs.
ret = await echo.remote([], { s: "Hello world!" });
console.log(ret);



================================================
FILE: modal-js/examples/function-current-stats.ts
================================================
// Demonstrates how to get current statistics for a Modal Function.

import { Function_ } from "modal";

const func = await Function_.lookup("libmodal-test-support", "echo_string");

const stats = await func.getCurrentStats();

console.log("Function Statistics:");
console.log(`  Backlog: ${stats.backlog} inputs`);
console.log(`  Total Runners: ${stats.numTotalRunners} containers`);



================================================
FILE: modal-js/examples/function-spawn.ts
================================================
// This example calls a Function defined in `libmodal_test_support.py`.

import { Function_ } from "modal";

const echo = await Function_.lookup("libmodal-test-support", "echo_string");

// Spawn the Function with kwargs.
const functionCall = await echo.spawn([], { s: "Hello world!" });
const ret = await functionCall.get();
console.log(ret);



================================================
FILE: modal-js/examples/image-building.ts
================================================
import { App, Image, Secret } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });

const image = Image.fromRegistry("alpine:3.21")
  .dockerfileCommands(["RUN apk add --no-cache curl=$CURL_VERSION"], {
    secrets: [
      await Secret.fromObject({
        CURL_VERSION: "8.12.1-r1",
      }),
    ],
  })
  .dockerfileCommands(["ENV SERVER=ipconfig.me"]);

const sb = await app.createSandbox(image, {
  command: ["sh", "-c", "curl -Ls $SERVER"],
});
console.log("Created Sandbox with ID:", sb.sandboxId);

console.log("Sandbox output:", await sb.stdout.readText());
await sb.terminate();



================================================
FILE: modal-js/examples/init-client.ts
================================================
// This example configures a client using a `CUSTOM_MODAL_ID` and `CUSTOM_MODAL_SECRET` environment variable.

import { Function_, initializeClient } from "modal";

const modalId = process.env.CUSTOM_MODAL_ID;
if (!modalId) {
  throw new Error("CUSTOM_MODAL_ID environment variable not set");
}
const modalSecret = process.env.CUSTOM_MODAL_SECRET;
if (!modalSecret) {
  throw new Error("CUSTOM_MODAL_SECRET environment variable not set");
}

initializeClient({ tokenId: modalId, tokenSecret: modalSecret });

const echo = await Function_.lookup("libmodal-test-support", "echo_string");
console.log(echo);



================================================
FILE: modal-js/examples/reliability.ts
================================================
// Run a bunch of container exec commands, alerting of any output issues.

import PQueue from "p-queue";
import { App } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await app.imageFromRegistry("python:3.13-slim");

const sandboxes = [
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
  await app.createSandbox(image),
];

try {
  const expectedContent = Array.from(
    { length: 50000 },
    (_, i) => `${i}\n`,
  ).join("");

  const queue = new PQueue({ concurrency: 50 });

  let success = 0;
  let failure = 0;

  for (let i = 0; i < 10000; i++) {
    await queue.onEmpty();

    queue.add(async () => {
      const sb = sandboxes[i % sandboxes.length];
      const p = await sb.exec(
        [
          "python",
          "-c",
          `
import time
import sys
for i in range(50000):
  if i % 1000 == 0:
    time.sleep(0.01)
  print(i)
  print(i, file=sys.stderr)`,
        ],
        {
          stdout: "pipe",
          stderr: "pipe",
        },
      );
      const [contentStdout, contentStderr] = await Promise.all([
        p.stdout.readText(),
        p.stderr.readText(),
      ]);
      if (
        contentStdout === expectedContent &&
        contentStderr === expectedContent
      ) {
        success++;
        console.log("Output matches expected content.", i);
      } else {
        failure++;
        console.error("MISMATCH", i);
      }
    });
  }

  await queue.onIdle();
  console.log("Success:", success);
  console.log("Failure:", failure);
} finally {
  for (const sb of sandboxes) {
    await sb.terminate();
  }
}



================================================
FILE: modal-js/examples/reliability2.ts
================================================
// Quick script for making sure Sandboxes can be created and wait() without stalling.

import PQueue from "p-queue";
import { App } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await app.imageFromRegistry("python:3.13-slim");

async function createAndWaitOne() {
  const sb = await app.createSandbox(image);
  if (!sb.sandboxId) throw new Error("Sandbox ID is missing");
  await sb.terminate();
  const exitCode = await Promise.race([
    sb.wait(),
    new Promise<number>((_, reject) => {
      setTimeout(() => reject(new Error("wait() timed out")), 10000).unref();
    }),
  ]);
  console.log("Sandbox wait completed with exit code:", exitCode);
  if (exitCode !== 0) throw new Error(`Sandbox exited with code ${exitCode}`);
}

const queue = new PQueue({ concurrency: 50 });

let success = 0;
let failure = 0;

for (let i = 0; i < 150; i++) {
  await queue.onEmpty();

  queue.add(async () => {
    try {
      await createAndWaitOne();
      success++;
      console.log("Sandbox created and waited successfully.", i);
    } catch (error) {
      failure++;
      console.error("Error in Sandbox creation/waiting:", error, i);
    }
  });
}

await queue.onIdle();
console.log("Success:", success);
console.log("Failure:", failure);



================================================
FILE: modal-js/examples/sandbox-agent.ts
================================================
import { App, Image, Secret } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21").dockerfileCommands([
  "RUN apk add --no-cache bash curl git libgcc libstdc++ ripgrep",
  "RUN curl -fsSL https://claude.ai/install.sh | bash",
  "ENV PATH=/root/.local/bin:$PATH USE_BUILTIN_RIPGREP=0",
]);

const sb = await app.createSandbox(image);
console.log("Started Sandbox:", sb.sandboxId);

try {
  const repoUrl = "https://github.com/modal-labs/libmodal";
  const git = await sb.exec(["git", "clone", repoUrl, "/repo"]);
  await git.wait();
  console.log(`Cloned '${repoUrl}' into /repo.`);

  const claudeCmd = [
    "claude",
    "-p",
    "Summarize what this repository is about. Don't modify any code or files.",
  ];
  console.log("\nRunning command:");
  console.log(claudeCmd);
  const claude = await sb.exec(claudeCmd, {
    // Adding a PTY is important, since Claude requires it!
    pty: true,
    secrets: [
      await Secret.fromName("libmodal-anthropic-secret", {
        requiredKeys: ["ANTHROPIC_API_KEY"],
      }),
    ],
    workdir: "/repo",
  });
  await claude.wait();

  console.log("\nAgent stdout:\n");
  console.log(await claude.stdout.readText());

  const stderr = await claude.stderr.readText();
  if (stderr !== "") {
    console.log("Agent stderr:", stderr);
  }
} finally {
  await sb.terminate();
}



================================================
FILE: modal-js/examples/sandbox-cloud-bucket.ts
================================================
import { App, Secret, CloudBucketMount, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const secret = await Secret.fromName("libmodal-aws-bucket-secret");

const sb = await app.createSandbox(image, {
  command: ["sh", "-c", "ls -la /mnt/s3-bucket"],
  cloudBucketMounts: {
    "/mnt/s3-bucket": new CloudBucketMount("my-s3-bucket", {
      secret,
      keyPrefix: "data/",
      readOnly: true,
    }),
  },
});

console.log("S3 Sandbox:", sb.sandboxId);
console.log(
  "Sandbox directory listing of /mnt/s3-bucket:",
  await sb.stdout.readText(),
);

await sb.terminate();



================================================
FILE: modal-js/examples/sandbox-exec.ts
================================================
import { App, Secret, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("python:3.13-slim");

const sb = await app.createSandbox(image);
console.log("Started Sandbox:", sb.sandboxId);

try {
  const p = await sb.exec(
    [
      "python",
      "-c",
      `
import time
import sys
for i in range(50000):
    if i % 1000 == 0:
        time.sleep(0.01)
    print(i)
    print(i, file=sys.stderr)`,
    ],
    {
      stdout: "pipe",
      stderr: "pipe",
    },
  );

  // Read both the stdout and stderr streams.
  const [contentStdout, contentStderr] = await Promise.all([
    p.stdout.readText(),
    p.stderr.readText(),
  ]);
  console.log(
    `Got ${contentStdout.length} bytes stdout and ${contentStderr.length} bytes stderr`,
  );
  console.log("Return code:", await p.wait());

  const secret = await Secret.fromName("libmodal-test-secret", {
    requiredKeys: ["c"],
  });
  const printSecret = await sb.exec(["printenv", "c"], {
    stdout: "pipe",
    secrets: [secret],
  });
  const secretText = await printSecret.stdout.readText();
  console.log(`Got environment variable c=${secretText}`);
} finally {
  await sb.terminate();
}



================================================
FILE: modal-js/examples/sandbox-filesystem-snapshot.ts
================================================
import { App, Image } from "modal";

const app = await App.lookup("libmodal-example", {
  createIfMissing: true,
});
const baseImage = await Image.fromRegistry("alpine:3.21");

const sb = await app.createSandbox(baseImage);
console.log("Started Sandbox:", sb.sandboxId);

await sb.exec(["mkdir", "-p", "/app/data"]);
await sb.exec([
  "sh",
  "-c",
  "echo 'This file was created in the first Sandbox' > /app/data/info.txt",
]);
console.log("Created file in first Sandbox");

const snapshotImage = await sb.snapshotFilesystem();
console.log(
  "Filesystem snapshot created with Image ID:",
  snapshotImage.imageId,
);

await sb.terminate();
console.log("Terminated first Sandbox");

// Create new Sandbox from the snapshot Image
const sb2 = await app.createSandbox(snapshotImage);
console.log("\nStarted new Sandbox from snapshot:", sb2.sandboxId);

const proc = await sb2.exec(["cat", "/app/data/info.txt"]);
const info = await proc.stdout.readText();
console.log("File data read in second Sandbox:", info);

await sb2.terminate();



================================================
FILE: modal-js/examples/sandbox-filesystem.ts
================================================
import { App, Image } from "modal";

/**
 * Example demonstrating filesystem operations in a Modal Sandbox.
 *
 * This example shows how to:
 * - Open files for reading and writing
 * - Read file contents as binary data
 * - Write data to files
 * - Close file handles
 */

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const sb = await app.createSandbox(image);
console.log("Started Sandbox:", sb.sandboxId);

try {
  const writeHandle = await sb.open("/tmp/example.txt", "w");
  const encoder = new TextEncoder();
  const deocder = new TextDecoder();

  await writeHandle.write(encoder.encode("Hello, Modal filesystem!\n"));
  await writeHandle.write(encoder.encode("This is line 2.\n"));
  await writeHandle.write(encoder.encode("And this is line 3.\n"));
  await writeHandle.close();

  const readHandle = await sb.open("/tmp/example.txt", "r");
  const content = await readHandle.read();
  console.log("File content:", deocder.decode(content));
  await readHandle.close();

  const appendHandle = await sb.open("/tmp/example.txt", "a");
  await appendHandle.write(encoder.encode("This line was appended.\n"));
  await appendHandle.close();

  const seekHandle = await sb.open("/tmp/example.txt", "r");
  const appendedContent = await seekHandle.read();
  console.log("File with appended:", deocder.decode(appendedContent));
  await seekHandle.close();

  const binaryHandle = await sb.open("/tmp/data.bin", "w");
  const binaryData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  await binaryHandle.write(binaryData);
  await binaryHandle.close();

  const readBinaryHandle = await sb.open("/tmp/data.bin", "r");
  const readData = await readBinaryHandle.read();
  console.log("Binary data:", readData);
  await readBinaryHandle.close();
} catch (error) {
  console.error("Filesystem operation failed:", error);
} finally {
  await sb.terminate();
}



================================================
FILE: modal-js/examples/sandbox-gpu.ts
================================================
import { App, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("nvidia/cuda:12.4.0-devel-ubuntu22.04");

const sb = await app.createSandbox(image, { gpu: "A10G" });
console.log("Started Sandbox with A10G GPU:", sb.sandboxId);

try {
  console.log("Running `nvidia-smi` in Sandbox:");

  const gpuCheck = await sb.exec(["nvidia-smi"]);

  console.log(await gpuCheck.stdout.readText());
} finally {
  await sb.terminate();
}



================================================
FILE: modal-js/examples/sandbox-named.ts
================================================
import { App, Image, Sandbox, AlreadyExistsError } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const sandboxName = `libmodal-example-named-sandbox`;

const sb = await app.createSandbox(image, {
  name: sandboxName,
  command: ["cat"],
});

console.log(`Created Sandbox with name: ${sandboxName}`);
console.log(`Sandbox ID: ${sb.sandboxId}`);

try {
  await app.createSandbox(image, {
    name: sandboxName,
    command: ["cat"],
  });
} catch (e) {
  if (e instanceof AlreadyExistsError) {
    console.log(
      "Trying to create one more Sandbox with the same name throws:",
      e.message,
    );
  } else {
    throw e;
  }
}

const sbFromName = await Sandbox.fromName("libmodal-example", sandboxName);
console.log(`Retrieved the same Sandbox from name: ${sbFromName.sandboxId}`);

await sbFromName.stdin.writeText("hello, named Sandbox");
await sbFromName.stdin.close();

console.log("Reading output:");
console.log(await sbFromName.stdout.readText());

await sb.terminate();
console.log("Sandbox terminated");



================================================
FILE: modal-js/examples/sandbox-poll.ts
================================================
import { App, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

// Create a Sandbox that waits for input, then exits with code 42
const sandbox = await app.createSandbox(image, {
  command: ["sh", "-c", "read line; exit 42"],
});

console.log("Started Sandbox:", sandbox.sandboxId);

console.log("Poll result while running:", await sandbox.poll());

console.log("\nSending input to trigger completion...");
await sandbox.stdin.writeText("hello, goodbye");
await sandbox.stdin.close();

const exitCode = await sandbox.wait();
console.log("\nSandbox completed with exit code:", exitCode);
console.log("Poll result after completion:", await sandbox.poll());



================================================
FILE: modal-js/examples/sandbox-prewarm.ts
================================================
// We use `Image.build` to create an Image object on Modal
// that eagerly pulls from the registry. The first Sandbox created with this Image
// will ues this "pre-warmed" Image and will start faster.
import { App, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });

// With `.build(app)`, we create an Image object on Modal that eagerly pulls
// from the registry.
const image = await Image.fromRegistry("alpine:3.21").build(app);
console.log("image id:", image.imageId);

const imageId = image.imageId;
// You can save the Image ID and create a new Image object that referes to it.
const image2 = await Image.fromId(imageId);

const sb = await app.createSandbox(image2, { command: ["cat"] });
console.log("Sandbox:", sb.sandboxId);

await sb.terminate();



================================================
FILE: modal-js/examples/sandbox-private-image.ts
================================================
import { App, Secret, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromAwsEcr(
  "459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python",
  await Secret.fromName("libmodal-aws-ecr-test", {
    requiredKeys: ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"],
  }),
);

// Spawn a Sandbox running a simple Python version of the "cat" command.
const sb = await app.createSandbox(image, {
  command: ["python", "-c", `import sys; sys.stdout.write(sys.stdin.read())`],
});
console.log("Sandbox:", sb.sandboxId);

await sb.stdin.writeText(
  "this is input that should be mirrored by the Python one-liner",
);
await sb.stdin.close();
console.log("output:", await sb.stdout.readText());

await sb.terminate();



================================================
FILE: modal-js/examples/sandbox-proxy.ts
================================================
import { App, Image, Proxy } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine/curl:8.14.1");

const proxy = await Proxy.fromName("libmodal-test-proxy");
console.log("Using Proxy with ID:", proxy.proxyId);

const sb = await app.createSandbox(image, {
  proxy,
});
console.log("Created Sandbox with Proxy:", sb.sandboxId);

try {
  const p = await sb.exec(["curl", "-s", "ifconfig.me"]);
  const ip = await p.stdout.readText();

  console.log("External IP:", ip.trim());
} finally {
  await sb.terminate();
}



================================================
FILE: modal-js/examples/sandbox-secrets.ts
================================================
import { App, Image, Secret } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const secret = await Secret.fromName("libmodal-test-secret", {
  requiredKeys: ["c"],
});

const ephemeralSecret = await Secret.fromObject({
  d: "123",
});

const sandbox = await app.createSandbox(image, {
  command: ["sh", "-lc", "printenv | grep -E '^c|d='"],
  secrets: [secret, ephemeralSecret],
});

console.log("Sandbox created:", sandbox.sandboxId);

console.log("Sandbox environment variables from Secrets:");
console.log(await sandbox.stdout.readText());



================================================
FILE: modal-js/examples/sandbox-tunnels.ts
================================================
import { App, Image } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });

// Create a Sandbox with Python's built-in HTTP server
const image = await Image.fromRegistry("python:3.12-alpine");
const sandbox = await app.createSandbox(image, {
  command: ["python3", "-m", "http.server", "8000"],
  encryptedPorts: [8000],
  timeout: 60000, // 1 minute
  idleTimeout: 30000, // 30 seconds
});

console.log("Sandbox created:", sandbox.sandboxId);

console.log("Getting tunnel information...");
const tunnels = await sandbox.tunnels();

console.log("Waiting for server to start...");
await new Promise((resolve) => setTimeout(resolve, 3000));
const tunnel = tunnels[8000];

console.log("Tunnel information:");
console.log("  URL:", tunnel.url);
console.log("  Port:", tunnel.port);

console.log("\nMaking GET request to the tunneled server at " + tunnel.url);

const response = await fetch(tunnel.url);

const html = await response.text();
console.log("\nDirectory listing from server (first 500 chars):");
console.log(html.substring(0, 500));

console.log("\n✅ Successfully connected to the tunneled server!");

await sandbox.terminate();



================================================
FILE: modal-js/examples/sandbox-volume-ephemeral.ts
================================================
import { App, Image, Volume } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const volume = await Volume.ephemeral();

const writerSandbox = await app.createSandbox(image, {
  command: [
    "sh",
    "-c",
    "echo 'Hello from writer Sandbox!' > /mnt/volume/message.txt",
  ],
  volumes: { "/mnt/volume": volume },
});
console.log("Writer Sandbox:", writerSandbox.sandboxId);

await writerSandbox.wait();
console.log("Writer finished");
await writerSandbox.terminate();

const readerSandbox = await app.createSandbox(image, {
  command: ["cat", "/mnt/volume/message.txt"],
  volumes: { "/mnt/volume": volume.readOnly() },
});
console.log("Reader Sandbox:", readerSandbox.sandboxId);
console.log("Reader output:", await readerSandbox.stdout.readText());

await readerSandbox.terminate();
volume.closeEphemeral();



================================================
FILE: modal-js/examples/sandbox-volume.ts
================================================
import { App, Image, Volume } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const volume = await Volume.fromName("libmodal-example-volume", {
  createIfMissing: true,
});

const writerSandbox = await app.createSandbox(image, {
  command: [
    "sh",
    "-c",
    "echo 'Hello from writer Sandbox!' > /mnt/volume/message.txt",
  ],
  volumes: { "/mnt/volume": volume },
});
console.log("Writer Sandbox:", writerSandbox.sandboxId);

await writerSandbox.wait();
console.log("Writer finished");

const readerSandbox = await app.createSandbox(image, {
  volumes: { "/mnt/volume": volume.readOnly() },
});
console.log("Reader Sandbox:", readerSandbox.sandboxId);

const rp = await readerSandbox.exec(["cat", "/mnt/volume/message.txt"]);
console.log("Reader output:", await rp.stdout.readText());

const wp = await readerSandbox.exec([
  "sh",
  "-c",
  "echo 'This should fail' >> /mnt/volume/message.txt",
]);
const wpExitCode = await wp.wait();

console.log("Write attempt exit code:", wpExitCode);
console.log("Write attempt stderr:", await wp.stderr.readText());

await writerSandbox.terminate();
await readerSandbox.terminate();



================================================
FILE: modal-js/examples/sandbox.ts
================================================
import { App, Image, Sandbox } from "modal";

const app = await App.lookup("libmodal-example", { createIfMissing: true });
const image = await Image.fromRegistry("alpine:3.21");

const sb = await app.createSandbox(image, { command: ["cat"] });
console.log("Sandbox:", sb.sandboxId);

const sbFromId = await Sandbox.fromId(sb.sandboxId);
console.log("Queried Sandbox from ID:", sbFromId.sandboxId);

await sb.stdin.writeText("this is input that should be mirrored by cat");
await sb.stdin.close();
console.log("output:", await sb.stdout.readText());

await sb.terminate();



================================================
FILE: modal-js/scripts/gen-proto.sh
================================================
#!/bin/bash
# Called from package.json scripts.

mkdir -p proto

./node_modules/.bin/grpc_tools_node_protoc \
  --plugin=protoc-gen-ts_proto=./node_modules/.bin/protoc-gen-ts_proto \
  --ts_proto_out=./proto \
  --ts_proto_opt=outputServices=nice-grpc,outputServices=generic-definitions,useExactTypes=false \
  --proto_path=../modal-client \
  ../modal-client/modal_proto/*.proto

# Add @ts-nocheck to all generated files.
find proto -name '*.ts' | while read -r file; do
  if ! grep -q '@ts-nocheck' "$file"; then
    (echo '// @ts-nocheck'; cat "$file") > "$file.tmp" && mv "$file.tmp" "$file"
  fi
done

# HACK: Patch for bad Protobuf codegen: fix the "Object" type conflicting with
# builtin `Object` API in JavaScript and breaking Protobuf import.
perl -pi -e 's/Object\.entries/PLACEHOLDER_OBJECT_ENTRIES/g' proto/modal_proto/api.ts
perl -pi -e 's/\bObject\b/Object_/g' proto/modal_proto/api.ts
perl -pi -e 's/PLACEHOLDER_OBJECT_ENTRIES/Object.entries/g' proto/modal_proto/api.ts



================================================
FILE: modal-js/src/app.ts
================================================
import { ClientError, Status } from "nice-grpc";
import {
  NetworkAccess_NetworkAccessType,
  ObjectCreationType,
  PortSpec,
  TunnelType,
  NetworkAccess,
  GPUConfig,
  SchedulerPlacement,
  VolumeMount,
  CloudBucketMount as CloudBucketMountProto,
  PTYInfo,
  SandboxCreateRequest,
} from "../proto/modal_proto/api";
import { client } from "./client";
import { environmentName } from "./config";
import { Image } from "./image";
import { Sandbox, defaultSandboxPTYInfo } from "./sandbox";
import { NotFoundError, AlreadyExistsError } from "./errors";
import { Secret, mergeEnvAndSecrets } from "./secret";
import { Volume } from "./volume";
import { Proxy } from "./proxy";
import {
  CloudBucketMount,
  cloudBucketMountToProto,
} from "./cloud_bucket_mount";

/** Options for functions that find deployed Modal objects. */
export type LookupOptions = {
  environment?: string;
  createIfMissing?: boolean;
};

/** Options for deleting a named object. */
export type DeleteOptions = {
  environment?: string;
};

/** Options for constructors that create a temporary, nameless object. */
export type EphemeralOptions = {
  environment?: string;
};

/** Options for `App.createSandbox()`. */
export type SandboxCreateOptions = {
  /** Reservation of physical CPU cores for the Sandbox, can be fractional. */
  cpu?: number;

  /** Reservation of memory in MiB. */
  memory?: number;

  /** GPU reservation for the Sandbox (e.g. "A100", "T4:2", "A100-80GB:4"). */
  gpu?: string;

  /** Timeout of the Sandbox container, defaults to 10 minutes. */
  timeout?: number;

  /** The amount of time in milliseconds that a sandbox can be idle before being terminated. */
  idleTimeout?: number;

  /** Working directory of the Sandbox. */
  workdir?: string;

  /**
   * Sequence of program arguments for the main process.
   * Default behavior is to sleep indefinitely until timeout or termination.
   */
  command?: string[]; // default is ["sleep", "48h"]

  /** Environment variables to set in the Sandbox. */
  env?: Record<string, string>;

  /** Secrets to inject into the Sandbox as environment variables. */
  secrets?: Secret[];

  /** Mount points for Modal Volumes. */
  volumes?: Record<string, Volume>;

  /** Mount points for cloud buckets. */
  cloudBucketMounts?: Record<string, CloudBucketMount>;

  /** Enable a PTY for the Sandbox. */
  pty?: boolean;

  /** List of ports to tunnel into the Sandbox. Encrypted ports are tunneled with TLS. */
  encryptedPorts?: number[];

  /** List of encrypted ports to tunnel into the Sandbox, using HTTP/2. */
  h2Ports?: number[];

  /** List of ports to tunnel into the Sandbox without encryption. */
  unencryptedPorts?: number[];

  /** Whether to block all network access from the Sandbox. */
  blockNetwork?: boolean;

  /** List of CIDRs the Sandbox is allowed to access. If None, all CIDRs are allowed. Cannot be used with blockNetwork. */
  cidrAllowlist?: string[];

  /** Cloud provider to run the Sandbox on. */
  cloud?: string;

  /** Region(s) to run the Sandbox on. */
  regions?: string[];

  /** Enable verbose logging. */
  verbose?: boolean;

  /** Reference to a Modal Proxy to use in front of this Sandbox. */
  proxy?: Proxy;

  /** Optional name for the Sandbox. Unique within an App. */
  name?: string;
};

/**
 * Parse a GPU configuration string into a GPUConfig object.
 * @param gpu - GPU string in format "type" or "type:count" (e.g. "T4", "A100:2")
 * @returns GPUConfig object or undefined if no GPU specified
 */
export function parseGpuConfig(gpu: string | undefined): GPUConfig | undefined {
  if (!gpu) {
    return undefined;
  }

  let gpuType = gpu;
  let count = 1;

  if (gpu.includes(":")) {
    const [type, countStr] = gpu.split(":", 2);
    gpuType = type;
    count = parseInt(countStr, 10);
    if (isNaN(count) || count < 1) {
      throw new Error(
        `Invalid GPU count: ${countStr}. Value must be a positive integer.`,
      );
    }
  }

  return {
    type: 0, // Deprecated field, but required by proto
    count,
    gpuType: gpuType.toUpperCase(),
  };
}

export async function buildSandboxCreateRequestProto(
  appId: string,
  imageId: string,
  options: SandboxCreateOptions = {},
): Promise<SandboxCreateRequest> {
  const gpuConfig = parseGpuConfig(options.gpu);

  // The gRPC API only accepts a whole number of seconds.
  if (options.timeout && options.timeout % 1000 !== 0) {
    throw new Error(
      `timeout must be a multiple of 1000ms, got ${options.timeout}`,
    );
  }
  if (options.idleTimeout && options.idleTimeout % 1000 !== 0) {
    throw new Error(
      `idleTimeout must be a multiple of 1000ms, got ${options.idleTimeout}`,
    );
  }

  if (options.workdir && !options.workdir.startsWith("/")) {
    throw new Error(
      `workdir must be an absolute path, got: ${options.workdir}`,
    );
  }

  const volumeMounts: VolumeMount[] = options.volumes
    ? Object.entries(options.volumes).map(([mountPath, volume]) => ({
        volumeId: volume.volumeId,
        mountPath,
        allowBackgroundCommits: true,
        readOnly: volume.isReadOnly,
      }))
    : [];

  const cloudBucketMounts: CloudBucketMountProto[] = options.cloudBucketMounts
    ? Object.entries(options.cloudBucketMounts).map(([mountPath, mount]) =>
        cloudBucketMountToProto(mount, mountPath),
      )
    : [];

  const openPorts: PortSpec[] = [];
  if (options.encryptedPorts) {
    openPorts.push(
      ...options.encryptedPorts.map((port) => ({
        port,
        unencrypted: false,
      })),
    );
  }
  if (options.h2Ports) {
    openPorts.push(
      ...options.h2Ports.map((port) => ({
        port,
        unencrypted: false,
        tunnelType: TunnelType.TUNNEL_TYPE_H2,
      })),
    );
  }
  if (options.unencryptedPorts) {
    openPorts.push(
      ...options.unencryptedPorts.map((port) => ({
        port,
        unencrypted: true,
      })),
    );
  }

  const mergedSecrets = await mergeEnvAndSecrets(options.env, options.secrets);
  const secretIds = mergedSecrets.map((secret) => secret.secretId);

  let networkAccess: NetworkAccess;
  if (options.blockNetwork) {
    if (options.cidrAllowlist) {
      throw new Error(
        "cidrAllowlist cannot be used when blockNetwork is enabled",
      );
    }
    networkAccess = {
      networkAccessType: NetworkAccess_NetworkAccessType.BLOCKED,
      allowedCidrs: [],
    };
  } else if (options.cidrAllowlist) {
    networkAccess = {
      networkAccessType: NetworkAccess_NetworkAccessType.ALLOWLIST,
      allowedCidrs: options.cidrAllowlist,
    };
  } else {
    networkAccess = {
      networkAccessType: NetworkAccess_NetworkAccessType.OPEN,
      allowedCidrs: [],
    };
  }

  const schedulerPlacement = SchedulerPlacement.create({
    regions: options.regions ?? [],
  });

  let ptyInfo: PTYInfo | undefined;
  if (options.pty) {
    ptyInfo = defaultSandboxPTYInfo();
  }

  return SandboxCreateRequest.create({
    appId,
    definition: {
      // Sleep default is implicit in image builder version <=2024.10
      entrypointArgs: options.command ?? ["sleep", "48h"],
      imageId,
      timeoutSecs: options.timeout != undefined ? options.timeout / 1000 : 600,
      idleTimeoutSecs:
        options.idleTimeout != undefined
          ? options.idleTimeout / 1000
          : undefined,
      workdir: options.workdir ?? undefined,
      networkAccess,
      resources: {
        // https://modal.com/docs/guide/resources
        milliCpu: Math.round(1000 * (options.cpu ?? 0.125)),
        memoryMb: options.memory ?? 128,
        gpuConfig,
      },
      volumeMounts,
      cloudBucketMounts,
      ptyInfo,
      secretIds,
      openPorts: openPorts.length > 0 ? { ports: openPorts } : undefined,
      cloudProviderStr: options.cloud ?? "",
      schedulerPlacement,
      verbose: options.verbose ?? false,
      proxyId: options.proxy?.proxyId,
      name: options.name,
    },
  });
}

/** Represents a deployed Modal App. */
export class App {
  readonly appId: string;
  readonly name?: string;

  /** @ignore */
  constructor(appId: string, name?: string) {
    this.appId = appId;
    this.name = name;
  }

  /** Lookup a deployed App by name, or create if it does not exist. */
  static async lookup(name: string, options: LookupOptions = {}): Promise<App> {
    try {
      const resp = await client.appGetOrCreate({
        appName: name,
        environmentName: environmentName(options.environment),
        objectCreationType: options.createIfMissing
          ? ObjectCreationType.OBJECT_CREATION_TYPE_CREATE_IF_MISSING
          : ObjectCreationType.OBJECT_CREATION_TYPE_UNSPECIFIED,
      });
      return new App(resp.appId, name);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(`App '${name}' not found`);
      throw err;
    }
  }

  async createSandbox(
    image: Image,
    options: SandboxCreateOptions = {},
  ): Promise<Sandbox> {
    await image.build(this);

    const createReq = await buildSandboxCreateRequestProto(
      this.appId,
      image.imageId,
      options,
    );
    let createResp;
    try {
      createResp = await client.sandboxCreate(createReq);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.ALREADY_EXISTS) {
        throw new AlreadyExistsError(err.details || err.message);
      }
      throw err;
    }

    return new Sandbox(createResp.sandboxId);
  }

  /**
   * @deprecated Use `Image.fromRegistry` instead.
   */
  async imageFromRegistry(tag: string, secret?: Secret): Promise<Image> {
    return await Image.fromRegistry(tag, secret).build(this);
  }

  /**
   * @deprecated Use `Image.fromAwsEcr` instead.
   */
  async imageFromAwsEcr(tag: string, secret: Secret): Promise<Image> {
    return await Image.fromAwsEcr(tag, secret).build(this);
  }

  /**
   * @deprecated Use `Image.fromGcpArtifactRegistry` instead.
   */
  async imageFromGcpArtifactRegistry(
    tag: string,
    secret: Secret,
  ): Promise<Image> {
    return await Image.fromGcpArtifactRegistry(tag, secret).build(this);
  }
}



================================================
FILE: modal-js/src/client.ts
================================================
import { v4 as uuidv4 } from "uuid";
import {
  CallOptions,
  ClientError,
  ClientMiddleware,
  ClientMiddlewareCall,
  createChannel,
  createClientFactory,
  Metadata,
  Status,
} from "nice-grpc";

import { ClientType, ModalClientDefinition } from "../proto/modal_proto/api";
import { getProfile, type Profile } from "./config";

const defaultProfile = getProfile(process.env["MODAL_PROFILE"]);

let modalAuthToken: string | undefined;

/** gRPC client middleware to add auth token to request. */
function authMiddleware(profile: Profile): ClientMiddleware {
  return async function* authMiddleware<Request, Response>(
    call: ClientMiddlewareCall<Request, Response>,
    options: CallOptions,
  ) {
    if (!profile.tokenId || !profile.tokenSecret) {
      throw new Error(
        `Profile is missing token_id or token_secret. Please set them in .modal.toml, or as environment variables, or initializeClient().`,
      );
    }
    const { tokenId, tokenSecret } = profile;

    options.metadata ??= new Metadata();
    options.metadata.set(
      "x-modal-client-type",
      String(ClientType.CLIENT_TYPE_LIBMODAL_JS),
    );
    options.metadata.set("x-modal-client-version", "1.0.0"); // CLIENT VERSION: Behaves like this Python SDK version
    options.metadata.set("x-modal-token-id", tokenId);
    options.metadata.set("x-modal-token-secret", tokenSecret);
    if (modalAuthToken) {
      options.metadata.set("x-modal-auth-token", modalAuthToken);
    }

    // We receive an auth token from the control plane on our first request. We then include that auth token in every
    // subsequent request to both the control plane and the input plane. The python server returns it in the trailers,
    // the worker returns it in the headers.
    const prevOnHeader = options.onHeader;
    options.onHeader = (header) => {
      const token = header.get("x-modal-auth-token");
      if (token) {
        modalAuthToken = token;
      }
      prevOnHeader?.(header);
    };
    const prevOnTrailer = options.onTrailer;
    options.onTrailer = (trailer) => {
      const token = trailer.get("x-modal-auth-token");
      if (token) {
        modalAuthToken = token;
      }
      prevOnTrailer?.(trailer);
    };
    return yield* call.next(call.request, options);
  };
}

type TimeoutOptions = {
  /** Timeout for this call, interpreted as a duration in milliseconds */
  timeout?: number;
};

/** gRPC client middleware to set timeout and retries on a call. */
const timeoutMiddleware: ClientMiddleware<TimeoutOptions> =
  async function* timeoutMiddleware(call, options) {
    if (!options.timeout || options.signal?.aborted) {
      return yield* call.next(call.request, options);
    }

    const { timeout, signal: origSignal, ...restOptions } = options;
    const abortController = new AbortController();
    const abortListener = () => abortController.abort();
    origSignal?.addEventListener("abort", abortListener);

    let timedOut = false;

    const timer = setTimeout(() => {
      timedOut = true;
      abortController.abort();
    }, timeout);

    try {
      return yield* call.next(call.request, {
        ...restOptions,
        signal: abortController.signal,
      });
    } finally {
      origSignal?.removeEventListener("abort", abortListener);
      clearTimeout(timer);

      if (timedOut) {
        // eslint-disable-next-line no-unsafe-finally
        throw new ClientError(
          call.method.path,
          Status.DEADLINE_EXCEEDED,
          `Timed out after ${timeout}ms`,
        );
      }
    }
  };

const retryableGrpcStatusCodes = new Set([
  Status.DEADLINE_EXCEEDED,
  Status.UNAVAILABLE,
  Status.CANCELLED,
  Status.INTERNAL,
  Status.UNKNOWN,
]);

export function isRetryableGrpc(err: unknown) {
  if (err instanceof ClientError) {
    return retryableGrpcStatusCodes.has(err.code);
  }
  return false;
}

/** Sleep helper that can be cancelled via an AbortSignal. */
const sleep = (ms: number, signal?: AbortSignal) =>
  new Promise<void>((resolve, reject) => {
    if (signal?.aborted) return reject(signal.reason);
    const t = setTimeout(resolve, ms);
    signal?.addEventListener(
      "abort",
      () => {
        clearTimeout(t);
        reject(signal.reason);
      },
      { once: true },
    );
  });

type RetryOptions = {
  /** Number of retries to take. */
  retries?: number;

  /** Base delay in milliseconds. */
  baseDelay?: number;

  /** Maximum delay in milliseconds. */
  maxDelay?: number;

  /** Exponential factor to multiply successive delays. */
  delayFactor?: number;

  /** Additional status codes to retry. */
  additionalStatusCodes?: Status[];
};

/** Middleware to retry transient errors and timeouts for unary requests. */
const retryMiddleware: ClientMiddleware<RetryOptions> =
  async function* retryMiddleware(call, options) {
    const {
      retries = 3,
      baseDelay = 100,
      maxDelay = 1000,
      delayFactor = 2,
      additionalStatusCodes = [],
      signal,
      ...restOptions
    } = options;

    if (call.requestStream || call.responseStream || !retries) {
      // Don't retry streaming calls, or if retries are disabled.
      return yield* call.next(call.request, restOptions);
    }

    const retryableCodes = new Set([
      ...retryableGrpcStatusCodes,
      ...additionalStatusCodes,
    ]);

    // One idempotency key for the whole call (all attempts).
    const idempotencyKey = uuidv4();

    const startTime = Date.now();
    let attempt = 0;
    let delayMs = baseDelay;

    while (true) {
      // Clone/augment metadata for this attempt.
      const metadata = new Metadata(restOptions.metadata ?? {});

      metadata.set("x-idempotency-key", idempotencyKey);
      metadata.set("x-retry-attempt", String(attempt));
      if (attempt > 0) {
        metadata.set(
          "x-retry-delay",
          ((Date.now() - startTime) / 1000).toFixed(3),
        );
      }

      try {
        // Forward the call.
        return yield* call.next(call.request, {
          ...restOptions,
          metadata,
          signal,
        });
      } catch (err) {
        // Immediately propagate non-retryable situations.
        if (
          !(err instanceof ClientError) ||
          !retryableCodes.has(err.code) ||
          attempt >= retries
        ) {
          throw err;
        }

        // Exponential back-off with a hard cap.
        await sleep(delayMs, signal);
        delayMs = Math.min(delayMs * delayFactor, maxDelay);
        attempt += 1;
      }
    }
  };

/** Map of server URL to input-plane client. */
const inputPlaneClients: Record<string, ReturnType<typeof createClient>> = {};

/** Returns a client for the given server URL, creating it if it doesn't exist. */
export const getOrCreateInputPlaneClient = (
  serverUrl: string,
): ReturnType<typeof createClient> => {
  const client = inputPlaneClients[serverUrl];
  if (client) {
    return client;
  }
  const profile = { ...clientProfile, serverUrl };
  const newClient = createClient(profile);
  inputPlaneClients[serverUrl] = newClient;
  return newClient;
};

function createClient(profile: Profile) {
  // Channels don't do anything until you send a request on them.
  // Ref: https://github.com/modal-labs/modal-client/blob/main/modal/_utils/grpc_utils.py
  const channel = createChannel(profile.serverUrl, undefined, {
    "grpc.max_receive_message_length": 100 * 1024 * 1024,
    "grpc.max_send_message_length": 100 * 1024 * 1024,
    "grpc-node.flow_control_window": 64 * 1024 * 1024,
  });
  return createClientFactory()
    .use(authMiddleware(profile))
    .use(retryMiddleware)
    .use(timeoutMiddleware)
    .create(ModalClientDefinition, channel);
}

export let clientProfile = defaultProfile;

export let client = createClient(clientProfile);

/** Options for initializing a client at runtime. */
export type ClientOptions = {
  tokenId: string;
  tokenSecret: string;
  environment?: string;
};

/**
 * Initialize the Modal client, passing in token authentication credentials.
 *
 * You should call this function at the start of your application if not
 * configuring Modal with a `.modal.toml` file or environment variables.
 */
export function initializeClient(options: ClientOptions) {
  const mergedProfile = {
    ...defaultProfile,
    tokenId: options.tokenId,
    tokenSecret: options.tokenSecret,
    environment: options.environment || defaultProfile.environment,
  };
  clientProfile = mergedProfile;
  client = createClient(mergedProfile);
}



================================================
FILE: modal-js/src/cloud_bucket_mount.ts
================================================
import {
  CloudBucketMount_BucketType,
  CloudBucketMount as CloudBucketMountProto,
} from "../proto/modal_proto/api";
import { Secret } from "./secret";

/** Cloud Bucket Mounts provide access to cloud storage buckets within Modal Functions. */
export class CloudBucketMount {
  readonly bucketName: string;
  readonly secret?: Secret;
  readonly readOnly: boolean;
  readonly requesterPays: boolean;
  readonly bucketEndpointUrl?: string;
  readonly keyPrefix?: string;
  readonly oidcAuthRoleArn?: string;

  constructor(
    bucketName: string,
    options: {
      secret?: Secret;
      readOnly?: boolean;
      requesterPays?: boolean;
      bucketEndpointUrl?: string;
      keyPrefix?: string;
      oidcAuthRoleArn?: string;
    } = {},
  ) {
    this.bucketName = bucketName;
    this.secret = options.secret;
    this.readOnly = options.readOnly ?? false;
    this.requesterPays = options.requesterPays ?? false;
    this.bucketEndpointUrl = options.bucketEndpointUrl;
    this.keyPrefix = options.keyPrefix;
    this.oidcAuthRoleArn = options.oidcAuthRoleArn;

    if (this.bucketEndpointUrl) {
      const url = new URL(this.bucketEndpointUrl);
      if (
        !url.hostname.endsWith("r2.cloudflarestorage.com") &&
        !url.hostname.endsWith("storage.googleapis.com")
      ) {
        console.warn(
          "CloudBucketMount received unrecognized bucket endpoint URL. " +
            "Assuming AWS S3 configuration as fallback.",
        );
      }
    }

    if (this.requesterPays && !this.secret) {
      throw new Error("Credentials required in order to use Requester Pays.");
    }

    if (this.keyPrefix && !this.keyPrefix.endsWith("/")) {
      throw new Error(
        "keyPrefix will be prefixed to all object paths, so it must end in a '/'",
      );
    }
  }
}

export function endpointUrlToBucketType(
  bucketEndpointUrl?: string,
): CloudBucketMount_BucketType {
  if (!bucketEndpointUrl) {
    return CloudBucketMount_BucketType.S3;
  }

  const url = new URL(bucketEndpointUrl);
  if (url.hostname.endsWith("r2.cloudflarestorage.com")) {
    return CloudBucketMount_BucketType.R2;
  } else if (url.hostname.endsWith("storage.googleapis.com")) {
    return CloudBucketMount_BucketType.GCP;
  } else {
    return CloudBucketMount_BucketType.S3;
  }
}

export function cloudBucketMountToProto(
  mount: CloudBucketMount,
  mountPath: string,
): CloudBucketMountProto {
  return {
    bucketName: mount.bucketName,
    mountPath,
    credentialsSecretId: mount.secret?.secretId ?? "",
    readOnly: mount.readOnly,
    bucketType: endpointUrlToBucketType(mount.bucketEndpointUrl),
    requesterPays: mount.requesterPays,
    bucketEndpointUrl: mount.bucketEndpointUrl,
    keyPrefix: mount.keyPrefix,
    oidcAuthRoleArn: mount.oidcAuthRoleArn,
  };
}



================================================
FILE: modal-js/src/cls.ts
================================================
import { ClientError, Status } from "nice-grpc";
import {
  ClassParameterInfo_ParameterSerializationFormat,
  ClassParameterSet,
  ClassParameterSpec,
  ClassParameterValue,
  FunctionOptions,
  FunctionRetryPolicy,
  ParameterType,
  VolumeMount,
} from "../proto/modal_proto/api";
import type { LookupOptions } from "./app";
import { NotFoundError } from "./errors";
import { client } from "./client";
import { environmentName } from "./config";
import { Function_ } from "./function";
import { parseGpuConfig } from "./app";
import type { Secret } from "./secret";
import { mergeEnvAndSecrets } from "./secret";
import { Retries, parseRetries } from "./retries";
import type { Volume } from "./volume";

export type ClsOptions = {
  cpu?: number;
  memory?: number;
  gpu?: string;
  env?: Record<string, string>;
  secrets?: Secret[];
  volumes?: Record<string, Volume>;
  retries?: number | Retries;
  maxContainers?: number;
  bufferContainers?: number;
  scaledownWindow?: number; // in milliseconds
  timeout?: number; // in milliseconds
};

export type ClsConcurrencyOptions = {
  maxInputs: number;
  targetInputs?: number;
};

export type ClsBatchingOptions = {
  maxBatchSize: number;
  waitMs: number;
};

type ServiceOptions = ClsOptions & {
  maxConcurrentInputs?: number;
  targetConcurrentInputs?: number;
  batchMaxSize?: number;
  batchWaitMs?: number;
};

/** Represents a deployed Modal Cls. */
export class Cls {
  #serviceFunctionId: string;
  #schema: ClassParameterSpec[];
  #methodNames: string[];
  #inputPlaneUrl?: string;
  #options?: ServiceOptions;

  /** @ignore */
  constructor(
    serviceFunctionId: string,
    schema: ClassParameterSpec[],
    methodNames: string[],
    inputPlaneUrl?: string,
    options?: ServiceOptions,
  ) {
    this.#serviceFunctionId = serviceFunctionId;
    this.#schema = schema;
    this.#methodNames = methodNames;
    this.#inputPlaneUrl = inputPlaneUrl;
    this.#options = options;
  }

  static async lookup(
    appName: string,
    name: string,
    options: LookupOptions = {},
  ): Promise<Cls> {
    try {
      const serviceFunctionName = `${name}.*`;
      const serviceFunction = await client.functionGet({
        appName,
        objectTag: serviceFunctionName,
        environmentName: environmentName(options.environment),
      });

      const parameterInfo = serviceFunction.handleMetadata?.classParameterInfo;
      const schema = parameterInfo?.schema ?? [];
      if (
        schema.length > 0 &&
        parameterInfo?.format !==
          ClassParameterInfo_ParameterSerializationFormat.PARAM_SERIALIZATION_FORMAT_PROTO
      ) {
        throw new Error(
          `Unsupported parameter format: ${parameterInfo?.format}`,
        );
      }

      let methodNames: string[];
      if (serviceFunction.handleMetadata?.methodHandleMetadata) {
        methodNames = Object.keys(
          serviceFunction.handleMetadata.methodHandleMetadata,
        );
      } else {
        // Legacy approach not supported
        throw new Error(
          "Cls requires Modal deployments using client v0.67 or later.",
        );
      }
      return new Cls(
        serviceFunction.functionId,
        schema,
        methodNames,
        serviceFunction.handleMetadata?.inputPlaneUrl,
        undefined,
      );
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(`Class '${appName}/${name}' not found`);
      throw err;
    }
  }

  /** Create a new instance of the Cls with parameters and/or runtime options. */
  async instance(params: Record<string, any> = {}): Promise<ClsInstance> {
    let functionId: string;
    if (this.#schema.length === 0 && this.#options === undefined) {
      functionId = this.#serviceFunctionId;
    } else {
      functionId = await this.#bindParameters(params);
    }
    const methods = new Map<string, Function_>();
    for (const name of this.#methodNames) {
      methods.set(name, new Function_(functionId, name, this.#inputPlaneUrl));
    }
    return new ClsInstance(methods);
  }

  /** Override the static Function configuration at runtime. */
  withOptions(options: ClsOptions): Cls {
    const merged = mergeServiceOptions(this.#options, options);
    return new Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged,
    );
  }

  /** Create an instance of the Cls with input concurrency enabled or overridden with new values. */
  withConcurrency(options: ClsConcurrencyOptions): Cls {
    const merged = mergeServiceOptions(this.#options, {
      maxConcurrentInputs: options.maxInputs,
      targetConcurrentInputs: options.targetInputs,
    });
    return new Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged,
    );
  }

  /** Create an instance of the Cls with dynamic batching enabled or overridden with new values. */
  withBatching(options: ClsBatchingOptions): Cls {
    const merged = mergeServiceOptions(this.#options, {
      batchMaxSize: options.maxBatchSize,
      batchWaitMs: options.waitMs,
    });
    return new Cls(
      this.#serviceFunctionId,
      this.#schema,
      this.#methodNames,
      this.#inputPlaneUrl,
      merged,
    );
  }

  /** Bind parameters to the Cls function. */
  async #bindParameters(params: Record<string, any>): Promise<string> {
    const serializedParams = encodeParameterSet(this.#schema, params);
    const functionOptions = await buildFunctionOptionsProto(this.#options);
    const bindResp = await client.functionBindParams({
      functionId: this.#serviceFunctionId,
      serializedParams,
      functionOptions,
    });
    return bindResp.boundFunctionId;
  }
}

export function encodeParameterSet(
  schema: ClassParameterSpec[],
  params: Record<string, any>,
): Uint8Array {
  const encoded: ClassParameterValue[] = [];
  for (const paramSpec of schema) {
    const paramValue = encodeParameter(paramSpec, params[paramSpec.name]);
    encoded.push(paramValue);
  }
  // Sort keys, identical to Python `SerializeToString(deterministic=True)`.
  encoded.sort((a, b) => a.name.localeCompare(b.name));
  return ClassParameterSet.encode({ parameters: encoded }).finish();
}

function mergeServiceOptions(
  base: ServiceOptions | undefined,
  diff: Partial<ServiceOptions>,
): ServiceOptions | undefined {
  const filteredDiff = Object.fromEntries(
    Object.entries(diff).filter(([, value]) => value !== undefined),
  ) as Partial<ServiceOptions>;
  const merged = { ...(base ?? {}), ...filteredDiff } as ServiceOptions;
  return Object.keys(merged).length === 0 ? undefined : merged;
}

async function buildFunctionOptionsProto(
  options?: ServiceOptions,
): Promise<FunctionOptions | undefined> {
  if (!options) return undefined;
  const o = options ?? {};

  const gpuConfig = parseGpuConfig(o.gpu);
  const resources =
    o.cpu !== undefined || o.memory !== undefined || gpuConfig
      ? {
          milliCpu: o.cpu !== undefined ? Math.round(1000 * o.cpu) : undefined,
          memoryMb: o.memory,
          gpuConfig,
        }
      : undefined;

  const mergedSecrets = await mergeEnvAndSecrets(o.env, o.secrets);
  const secretIds = mergedSecrets.map((s) => s.secretId);

  const volumeMounts: VolumeMount[] = o.volumes
    ? Object.entries(o.volumes).map(([mountPath, volume]) => ({
        volumeId: volume.volumeId,
        mountPath,
        allowBackgroundCommits: true,
        readOnly: volume.isReadOnly,
      }))
    : [];

  const parsedRetries = parseRetries(o.retries);
  const retryPolicy: FunctionRetryPolicy | undefined = parsedRetries
    ? {
        retries: parsedRetries.maxRetries,
        backoffCoefficient: parsedRetries.backoffCoefficient,
        initialDelayMs: parsedRetries.initialDelayMs,
        maxDelayMs: parsedRetries.maxDelayMs,
      }
    : undefined;

  if (o.scaledownWindow !== undefined && o.scaledownWindow % 1000 !== 0) {
    throw new Error(
      `scaledownWindow must be a multiple of 1000ms, got ${o.scaledownWindow}`,
    );
  }
  if (o.timeout !== undefined && o.timeout % 1000 !== 0) {
    throw new Error(`timeout must be a multiple of 1000ms, got ${o.timeout}`);
  }

  const functionOptions = FunctionOptions.create({
    secretIds,
    replaceSecretIds: secretIds.length > 0,
    replaceVolumeMounts: volumeMounts.length > 0,
    volumeMounts,
    resources,
    retryPolicy,
    concurrencyLimit: o.maxContainers,
    bufferContainers: o.bufferContainers,
    taskIdleTimeoutSecs:
      o.scaledownWindow !== undefined ? o.scaledownWindow / 1000 : undefined,
    timeoutSecs: o.timeout !== undefined ? o.timeout / 1000 : undefined,
    maxConcurrentInputs: o.maxConcurrentInputs,
    targetConcurrentInputs: o.targetConcurrentInputs,
    batchMaxSize: o.batchMaxSize,
    batchLingerMs: o.batchWaitMs,
  });

  return functionOptions;
}

function encodeParameter(
  paramSpec: ClassParameterSpec,
  value: any,
): ClassParameterValue {
  const name = paramSpec.name;
  const paramType = paramSpec.type;
  const paramValue: ClassParameterValue = { name, type: paramType };

  switch (paramType) {
    case ParameterType.PARAM_TYPE_STRING:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.stringDefault ?? "";
      }
      if (typeof value !== "string") {
        throw new Error(`Parameter '${name}' must be a string`);
      }
      paramValue.stringValue = value;
      break;

    case ParameterType.PARAM_TYPE_INT:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.intDefault ?? 0;
      }
      if (typeof value !== "number") {
        throw new Error(`Parameter '${name}' must be an integer`);
      }
      paramValue.intValue = value;
      break;

    case ParameterType.PARAM_TYPE_BOOL:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.boolDefault ?? false;
      }
      if (typeof value !== "boolean") {
        throw new Error(`Parameter '${name}' must be a boolean`);
      }
      paramValue.boolValue = value;
      break;

    case ParameterType.PARAM_TYPE_BYTES:
      if (value == null && paramSpec.hasDefault) {
        value = paramSpec.bytesDefault ?? new Uint8Array();
      }
      if (!(value instanceof Uint8Array)) {
        throw new Error(`Parameter '${name}' must be a byte array`);
      }
      paramValue.bytesValue = value;
      break;

    default:
      throw new Error(`Unsupported parameter type: ${paramType}`);
  }

  return paramValue;
}

/** Represents an instance of a deployed Modal Cls, optionally with parameters. */
export class ClsInstance {
  #methods: Map<string, Function_>;

  constructor(methods: Map<string, Function_>) {
    this.#methods = methods;
  }

  method(name: string): Function_ {
    const method = this.#methods.get(name);
    if (!method) {
      throw new NotFoundError(`Method '${name}' not found on class`);
    }
    return method;
  }
}



================================================
FILE: modal-js/src/config.ts
================================================
import { readFileSync } from "node:fs";
import { homedir } from "node:os";
import path from "node:path";
import { parse as parseToml } from "smol-toml";
import { clientProfile } from "./client";

/** Raw representation of the .modal.toml file. */
interface Config {
  [profile: string]: {
    server_url?: string;
    token_id?: string;
    token_secret?: string;
    environment?: string;
    imageBuilderVersion?: string;
    active?: boolean;
  };
}

/** Resolved configuration object from `Config` and environment variables. */
export interface Profile {
  serverUrl: string;
  tokenId?: string;
  tokenSecret?: string;
  environment?: string;
  imageBuilderVersion?: string;
}

function readConfigFile(): Config {
  try {
    const configContent = readFileSync(path.join(homedir(), ".modal.toml"), {
      encoding: "utf-8",
    });
    return parseToml(configContent) as Config;
  } catch (err: any) {
    if (err.code === "ENOENT") {
      return {} as Config;
    }
    // Ignore failure to read or parse .modal.toml
    // throw new Error(`Failed to read or parse .modal.toml: ${err.message}`);
    return {} as Config;
  }
}

// Synchronous on startup to avoid top-level await in CJS output.
//
// Any performance impact is minor because the .modal.toml file is small and
// only read once. This is comparable to how OpenSSL certificates can be probed
// synchronously, for instance.
const config: Config = readConfigFile();

export function getProfile(profileName?: string): Profile {
  if (!profileName) {
    for (const [name, profileData] of Object.entries(config)) {
      if (profileData.active) {
        profileName = name;
        break;
      }
    }
  }
  const profileData =
    profileName && Object.hasOwn(config, profileName)
      ? config[profileName]
      : {};

  const profile: Partial<Profile> = {
    serverUrl:
      process.env["MODAL_SERVER_URL"] ||
      profileData.server_url ||
      "https://api.modal.com:443",
    tokenId: process.env["MODAL_TOKEN_ID"] || profileData.token_id,
    tokenSecret: process.env["MODAL_TOKEN_SECRET"] || profileData.token_secret,
    environment: process.env["MODAL_ENVIRONMENT"] || profileData.environment,
    imageBuilderVersion:
      process.env["MODAL_IMAGE_BUILDER_VERSION"] ||
      profileData.imageBuilderVersion,
  };
  return profile as Profile; // safe to null-cast because of check above
}

export function environmentName(environment?: string): string {
  return environment || clientProfile.environment || "";
}

export function imageBuilderVersion(version?: string): string {
  return version || clientProfile.imageBuilderVersion || "2024.10";
}



================================================
FILE: modal-js/src/ephemeral.ts
================================================
export const ephemeralObjectHeartbeatSleep = 300_000; // 300 seconds

export type HeartbeatFunction = () => Promise<any>;

export class EphemeralHeartbeatManager {
  private readonly heartbeatFn: HeartbeatFunction;
  private readonly abortController: AbortController;

  constructor(heartbeatFn: HeartbeatFunction) {
    this.heartbeatFn = heartbeatFn;
    this.abortController = new AbortController();

    this.start();
  }

  private start(): void {
    const signal = this.abortController.signal;
    (async () => {
      while (!signal.aborted) {
        await this.heartbeatFn();
        await Promise.race([
          new Promise((resolve) => {
            // unref so the heartbeat timer doesn't prevent the process from exiting
            setTimeout(resolve, ephemeralObjectHeartbeatSleep).unref();
          }),
          new Promise((resolve) => {
            signal.addEventListener("abort", resolve, { once: true });
          }),
        ]);
      }
    })();
  }

  stop(): void {
    this.abortController.abort();
  }
}



================================================
FILE: modal-js/src/errors.ts
================================================
/** Function execution exceeds the allowed time limit. */
export class FunctionTimeoutError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "FunctionTimeoutError";
  }
}

/** An error on the Modal server, or a Python exception. */
export class RemoteError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "RemoteError";
  }
}

/** A retryable internal error from Modal. */
export class InternalFailure extends Error {
  constructor(message: string) {
    super(message);
    this.name = "InternalFailure";
  }
}

/** Some resource was not found. */
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

/** A resource already exists. */
export class AlreadyExistsError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AlreadyExistsError";
  }
}

/** A request or other operation was invalid. */
export class InvalidError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "InvalidError";
  }
}

/** The Queue is empty. */
export class QueueEmptyError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "QueueEmptyError";
  }
}

/** The Queue is full. */
export class QueueFullError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "QueueFullError";
  }
}

/** Errors from invalid Sandbox FileSystem operations. */
export class SandboxFilesystemError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "SandboxFilesystemError";
  }
}

/** Sandbox operations that exceed the allowed time limit. */
export class SandboxTimeoutError extends Error {
  constructor(message: string = "Sandbox operation timed out") {
    super(message);
    this.name = "SandboxTimeoutError";
  }
}



================================================
FILE: modal-js/src/function.ts
================================================
// Function calls and invocations, to be used with Modal Functions.

import { createHash } from "node:crypto";

import {
  DataFormat,
  FunctionCallInvocationType,
  FunctionInput,
} from "../proto/modal_proto/api";
import type { LookupOptions } from "./app";
import { client } from "./client";
import { FunctionCall } from "./function_call";
import { environmentName } from "./config";
import { InternalFailure, NotFoundError } from "./errors";
import { dumps } from "./pickle";
import { ClientError, Status } from "nice-grpc";
import {
  ControlPlaneInvocation,
  InputPlaneInvocation,
  Invocation,
} from "./invocation";

// From: modal/_utils/blob_utils.py
const maxObjectSizeBytes = 2 * 1024 * 1024; // 2 MiB

// From: client/modal/_functions.py
const maxSystemRetries = 8;

/** Simple data structure storing stats for a running Function. */
export interface FunctionStats {
  backlog: number;
  numTotalRunners: number;
}

/** Options for overriding a Function's autoscaler behavior. */
export interface UpdateAutoscalerOptions {
  minContainers?: number;
  maxContainers?: number;
  bufferContainers?: number;
  scaledownWindow?: number;
}

/** Represents a deployed Modal Function, which can be invoked remotely. */
export class Function_ {
  readonly functionId: string;
  readonly methodName?: string;
  #inputPlaneUrl?: string;
  #webUrl?: string;

  /** @ignore */
  constructor(
    functionId: string,
    methodName?: string,
    inputPlaneUrl?: string,
    webUrl?: string,
  ) {
    this.functionId = functionId;
    this.methodName = methodName;
    this.#inputPlaneUrl = inputPlaneUrl;
    this.#webUrl = webUrl;
  }

  static async lookup(
    appName: string,
    name: string,
    options: LookupOptions = {},
  ): Promise<Function_> {
    try {
      const resp = await client.functionGet({
        appName,
        objectTag: name,
        environmentName: environmentName(options.environment),
      });
      return new Function_(
        resp.functionId,
        undefined,
        resp.handleMetadata?.inputPlaneUrl,
        resp.handleMetadata?.webUrl,
      );
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(`Function '${appName}/${name}' not found`);
      throw err;
    }
  }

  // Execute a single input into a remote Function.
  async remote(
    args: any[] = [],
    kwargs: Record<string, any> = {},
  ): Promise<any> {
    const input = await this.#createInput(args, kwargs);
    const invocation = await this.#createRemoteInvocation(input);
    // TODO(ryan): Add tests for retries.
    let retryCount = 0;
    while (true) {
      try {
        return await invocation.awaitOutput();
      } catch (err) {
        if (err instanceof InternalFailure && retryCount <= maxSystemRetries) {
          await invocation.retry(retryCount);
          retryCount++;
        } else {
          throw err;
        }
      }
    }
  }

  async #createRemoteInvocation(input: FunctionInput): Promise<Invocation> {
    if (this.#inputPlaneUrl) {
      return await InputPlaneInvocation.create(
        this.#inputPlaneUrl,
        this.functionId,
        input,
      );
    }

    return await ControlPlaneInvocation.create(
      this.functionId,
      input,
      FunctionCallInvocationType.FUNCTION_CALL_INVOCATION_TYPE_SYNC,
    );
  }

  // Spawn a single input into a remote Function.
  async spawn(
    args: any[] = [],
    kwargs: Record<string, any> = {},
  ): Promise<FunctionCall> {
    const input = await this.#createInput(args, kwargs);
    const invocation = await ControlPlaneInvocation.create(
      this.functionId,
      input,
      FunctionCallInvocationType.FUNCTION_CALL_INVOCATION_TYPE_ASYNC,
    );
    return new FunctionCall(invocation.functionCallId);
  }

  // Returns statistics about the Function.
  async getCurrentStats(): Promise<FunctionStats> {
    const resp = await client.functionGetCurrentStats(
      { functionId: this.functionId },
      { timeout: 10000 },
    );
    return {
      backlog: resp.backlog,
      numTotalRunners: resp.numTotalTasks,
    };
  }

  // Overrides the current autoscaler behavior for this Function.
  async updateAutoscaler(options: UpdateAutoscalerOptions): Promise<void> {
    await client.functionUpdateSchedulingParams({
      functionId: this.functionId,
      warmPoolSizeOverride: 0, // Deprecated field, always set to 0
      settings: {
        minContainers: options.minContainers,
        maxContainers: options.maxContainers,
        bufferContainers: options.bufferContainers,
        scaledownWindow: options.scaledownWindow,
      },
    });
  }

  /**
   * URL of a Function running as a web endpoint.
   * @returns The web URL if this Function is a web endpoint, otherwise undefined
   */
  async getWebUrl(): Promise<string | undefined> {
    return this.#webUrl || undefined;
  }

  async #createInput(
    args: any[] = [],
    kwargs: Record<string, any> = {},
  ): Promise<FunctionInput> {
    const payload = dumps([args, kwargs]);

    let argsBlobId: string | undefined = undefined;
    if (payload.length > maxObjectSizeBytes) {
      argsBlobId = await blobUpload(payload);
    }

    // Single input sync invocation
    return {
      args: argsBlobId ? undefined : payload,
      argsBlobId,
      dataFormat: DataFormat.DATA_FORMAT_PICKLE,
      methodName: this.methodName,
      finalInput: false, // This field isn't specified in the Python client, so it defaults to false.
    };
  }
}

async function blobUpload(data: Uint8Array): Promise<string> {
  const contentMd5 = createHash("md5").update(data).digest("base64");
  const contentSha256 = createHash("sha256").update(data).digest("base64");
  const resp = await client.blobCreate({
    contentMd5,
    contentSha256Base64: contentSha256,
    contentLength: data.length,
  });
  if (resp.multipart) {
    throw new Error(
      "Function input size exceeds multipart upload threshold, unsupported by this SDK version",
    );
  } else if (resp.uploadUrl) {
    const uploadResp = await fetch(resp.uploadUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "application/octet-stream",
        "Content-MD5": contentMd5,
      },
      body: data,
    });
    if (uploadResp.status < 200 || uploadResp.status >= 300) {
      throw new Error(`Failed blob upload: ${uploadResp.statusText}`);
    }
    // Skip client-side ETag header validation for now (MD5 checksum).
    return resp.blobId;
  } else {
    throw new Error("Missing upload URL in BlobCreate response");
  }
}



================================================
FILE: modal-js/src/function_call.ts
================================================
// Manage existing Function Calls (look-ups, polling for output, cancellation).

import { client } from "./client";
import { ControlPlaneInvocation } from "./invocation";

/** Options for `FunctionCall.get()`. */
export type FunctionCallGetOptions = {
  timeout?: number; // in milliseconds
};

/** Options for `FunctionCall.cancel()`. */
export type FunctionCallCancelOptions = {
  terminateContainers?: boolean;
};

/**
 * Represents a Modal FunctionCall. Function Calls are Function invocations with
 * a given input. They can be consumed asynchronously (see `get()`) or cancelled
 * (see `cancel()`).
 */
export class FunctionCall {
  readonly functionCallId: string;

  /** @ignore */
  constructor(functionCallId: string) {
    this.functionCallId = functionCallId;
  }

  /** Create a new Function call from ID. */
  fromId(functionCallId: string): FunctionCall {
    return new FunctionCall(functionCallId);
  }

  /** Get the result of a Function call, optionally waiting with a timeout. */
  async get(options: FunctionCallGetOptions = {}): Promise<any> {
    const timeout = options.timeout;
    const invocation = ControlPlaneInvocation.fromFunctionCallId(
      this.functionCallId,
    );
    return invocation.awaitOutput(timeout);
  }

  /** Cancel a running Function call. */
  async cancel(options: FunctionCallCancelOptions = {}) {
    await client.functionCallCancel({
      functionCallId: this.functionCallId,
      terminateContainers: options.terminateContainers,
    });
  }
}



================================================
FILE: modal-js/src/image.ts
================================================
import {
  GenericResult,
  GenericResult_GenericStatus,
  RegistryAuthType,
  ImageRegistryConfig,
  Image as ImageProto,
  GPUConfig,
} from "../proto/modal_proto/api";
import { client } from "./client";
import { App, parseGpuConfig } from "./app";
import { Secret, mergeEnvAndSecrets } from "./secret";
import { imageBuilderVersion } from "./config";
import { ClientError } from "nice-grpc";
import { Status } from "nice-grpc";
import { NotFoundError, InvalidError } from "./errors";

/** Options for deleting an Image. */
export type ImageDeleteOptions = Record<never, never>;

/** Options for Image.dockerfileCommands(). */
export type ImageDockerfileCommandsOptions = {
  /** Environment variables to set in the build environment. */
  env?: Record<string, string>;

  /** Secrets that will be made available as environment variables to this layer's build environment. */
  secrets?: Secret[];

  /** GPU reservation for this layer's build environment (e.g. "A100", "T4:2", "A100-80GB:4"). */
  gpu?: string;

  /** Ignore cached builds for this layer, similar to 'docker build --no-cache'. */
  forceBuild?: boolean;
};

/** Represents a single image layer with its build configuration. */
type Layer = {
  commands: string[];
  env?: Record<string, string>;
  secrets?: Secret[];
  gpuConfig?: GPUConfig;
  forceBuild?: boolean;
};

/** A container image, used for starting Sandboxes. */
export class Image {
  #imageId: string;
  #tag: string;
  #imageRegistryConfig?: ImageRegistryConfig;
  #layers: Layer[];

  /** @ignore */
  constructor(
    imageId: string,
    tag: string,
    imageRegistryConfig?: ImageRegistryConfig,
    layers?: Layer[],
  ) {
    this.#imageId = imageId;
    this.#tag = tag;
    this.#imageRegistryConfig = imageRegistryConfig;
    this.#layers = layers || [
      {
        commands: [],
        env: undefined,
        secrets: undefined,
        gpuConfig: undefined,
        forceBuild: false,
      },
    ];
  }
  get imageId(): string {
    return this.#imageId;
  }

  /**
   * Creates an Image from an Image ID
   *
   * @param imageId - Image ID.
   */
  static async fromId(imageId: string): Promise<Image> {
    try {
      const resp = await client.imageFromId({ imageId });
      return new Image(resp.imageId, "");
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(err.details);
      if (
        err instanceof ClientError &&
        err.code === Status.FAILED_PRECONDITION &&
        err.details.includes("Could not find image with ID")
      )
        throw new NotFoundError(err.details);
      throw err;
    }
  }

  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - Optional. A Secret containing credentials for registry authentication.
   */
  static fromRegistry(tag: string, secret?: Secret): Image {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`",
        );
      }
      imageRegistryConfig = {
        registryAuthType: RegistryAuthType.REGISTRY_AUTH_TYPE_STATIC_CREDS,
        secretId: secret.secretId,
      };
    }
    return new Image("", tag, imageRegistryConfig);
  }

  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - A Secret containing credentials for registry authentication.
   */
  static fromAwsEcr(tag: string, secret: Secret): Image {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`",
        );
      }
      imageRegistryConfig = {
        registryAuthType: RegistryAuthType.REGISTRY_AUTH_TYPE_AWS,
        secretId: secret.secretId,
      };
    }
    return new Image("", tag, imageRegistryConfig);
  }

  /**
   * Creates an Image from a raw registry tag, optionally using a Secret for authentication.
   *
   * @param tag - The registry tag for the Image.
   * @param secret - A Secret containing credentials for registry authentication.
   */
  static fromGcpArtifactRegistry(tag: string, secret: Secret): Image {
    let imageRegistryConfig;
    if (secret) {
      if (!(secret instanceof Secret)) {
        throw new TypeError(
          "secret must be a reference to an existing Secret, e.g. `await Secret.fromName('my_secret')`",
        );
      }
      imageRegistryConfig = {
        registryAuthType: RegistryAuthType.REGISTRY_AUTH_TYPE_GCP,
        secretId: secret.secretId,
      };
    }
    return new Image("", tag, imageRegistryConfig);
  }

  private static validateDockerfileCommands(commands: string[]): void {
    for (const command of commands) {
      const trimmed = command.trim().toUpperCase();
      if (trimmed.startsWith("COPY ") && !trimmed.startsWith("COPY --FROM=")) {
        throw new InvalidError(
          "COPY commands that copy from local context are not yet supported.",
        );
      }
    }
  }

  /**
   * Extend an image with arbitrary Dockerfile-like commands.
   *
   * Each call creates a new Image layer that will be built sequentially.
   * The provided options apply only to this layer.
   *
   * @param commands - Array of Dockerfile commands as strings
   * @param options - Optional configuration for this layer's build
   * @returns A new Image instance
   */
  dockerfileCommands(
    commands: string[],
    options?: ImageDockerfileCommandsOptions,
  ): Image {
    if (commands.length === 0) {
      return this;
    }

    Image.validateDockerfileCommands(commands);

    const newLayer: Layer = {
      commands: [...commands],
      env: options?.env,
      secrets: options?.secrets,
      gpuConfig: options?.gpu ? parseGpuConfig(options.gpu) : undefined,
      forceBuild: options?.forceBuild,
    };

    return new Image("", this.#tag, this.#imageRegistryConfig, [
      ...this.#layers,
      newLayer,
    ]);
  }

  /**
   * Eagerly builds an Image on Modal.
   *
   * @param app - App to use to build the Image.
   */
  async build(app: App): Promise<Image> {
    if (this.imageId !== "") {
      // Image is already built with an Image ID
      return this;
    }

    let baseImageId: string | undefined;

    for (let i = 0; i < this.#layers.length; i++) {
      const layer = this.#layers[i];

      const mergedSecrets = await mergeEnvAndSecrets(layer.env, layer.secrets);
      const secretIds = mergedSecrets.map((secret) => secret.secretId);
      const gpuConfig = layer.gpuConfig;

      let dockerfileCommands: string[];
      let baseImages: Array<{ dockerTag: string; imageId: string }>;

      if (i === 0) {
        dockerfileCommands = [`FROM ${this.#tag}`, ...layer.commands];
        baseImages = [];
      } else {
        dockerfileCommands = ["FROM base", ...layer.commands];
        baseImages = [{ dockerTag: "base", imageId: baseImageId! }];
      }

      const resp = await client.imageGetOrCreate({
        appId: app.appId,
        image: ImageProto.create({
          dockerfileCommands,
          imageRegistryConfig: this.#imageRegistryConfig,
          secretIds,
          gpuConfig,
          contextFiles: [],
          baseImages,
        }),
        builderVersion: imageBuilderVersion(),
        forceBuild: layer.forceBuild || false,
      });

      let result: GenericResult;

      if (resp.result?.status) {
        // Image has already been built
        result = resp.result;
      } else {
        // Not built or in the process of building - wait for build
        let lastEntryId = "";
        let resultJoined: GenericResult | undefined = undefined;
        while (!resultJoined) {
          for await (const item of client.imageJoinStreaming({
            imageId: resp.imageId,
            timeout: 55,
            lastEntryId,
          })) {
            if (item.entryId) lastEntryId = item.entryId;
            if (item.result?.status) {
              resultJoined = item.result;
              break;
            }
            // Ignore all log lines and progress updates.
          }
        }
        result = resultJoined;
      }

      if (
        result.status === GenericResult_GenericStatus.GENERIC_STATUS_FAILURE
      ) {
        throw new Error(
          `Image build for ${resp.imageId} failed with the exception:\n${result.exception}`,
        );
      } else if (
        result.status === GenericResult_GenericStatus.GENERIC_STATUS_TERMINATED
      ) {
        throw new Error(
          `Image build for ${resp.imageId} terminated due to external shut-down. Please try again.`,
        );
      } else if (
        result.status === GenericResult_GenericStatus.GENERIC_STATUS_TIMEOUT
      ) {
        throw new Error(
          `Image build for ${resp.imageId} timed out. Please try again with a larger timeout parameter.`,
        );
      } else if (
        result.status !== GenericResult_GenericStatus.GENERIC_STATUS_SUCCESS
      ) {
        throw new Error(
          `Image build for ${resp.imageId} failed with unknown status: ${result.status}`,
        );
      }

      // the new image is the base for the next layer
      baseImageId = resp.imageId;
    }
    this.#imageId = baseImageId!;
    return this;
  }

  /** Delete an Image by ID. Warning: This removes an *entire Image*, and cannot be undone. */
  static async delete(
    imageId: string,
    _: ImageDeleteOptions = {},
  ): Promise<void> {
    const image = await Image.fromId(imageId);
    await client.imageDelete({ imageId: image.imageId });
  }
}



================================================
FILE: modal-js/src/index.ts
================================================
export {
  App,
  type DeleteOptions,
  type EphemeralOptions,
  type LookupOptions,
  type SandboxCreateOptions,
} from "./app";
export { type ClientOptions, initializeClient } from "./client";
export {
  Cls,
  ClsInstance,
  type ClsOptions,
  type ClsConcurrencyOptions,
  type ClsBatchingOptions,
} from "./cls";
export {
  FunctionTimeoutError,
  RemoteError,
  InternalFailure,
  NotFoundError,
  InvalidError,
  AlreadyExistsError,
  QueueEmptyError,
  QueueFullError,
  SandboxTimeoutError,
} from "./errors";
export {
  Function_,
  type FunctionStats,
  type UpdateAutoscalerOptions,
} from "./function";
export {
  FunctionCall,
  type FunctionCallGetOptions,
  type FunctionCallCancelOptions,
} from "./function_call";
export {
  Queue,
  type QueueClearOptions,
  type QueueGetOptions,
  type QueueIterateOptions,
  type QueueLenOptions,
  type QueuePutOptions,
} from "./queue";
export {
  Image,
  type ImageDeleteOptions,
  type ImageDockerfileCommandsOptions,
} from "./image";
export { Retries } from "./retries";
export type {
  ExecOptions,
  StdioBehavior,
  StreamMode,
  Tunnel,
  SandboxListOptions,
} from "./sandbox";
export { ContainerProcess, Sandbox } from "./sandbox";
export type { ModalReadStream, ModalWriteStream } from "./streams";
export { Secret, type SecretFromNameOptions } from "./secret";
export { SandboxFile, type SandboxFileMode } from "./sandbox_filesystem";
export { Volume, type VolumeFromNameOptions } from "./volume";
export { Proxy, type ProxyFromNameOptions } from "./proxy";
export { CloudBucketMount } from "./cloud_bucket_mount";



================================================
FILE: modal-js/src/invocation.ts
================================================
import {
  DataFormat,
  FunctionCallInvocationType,
  FunctionCallType,
  FunctionGetOutputsItem,
  FunctionInput,
  FunctionPutInputsItem,
  FunctionRetryInputsItem,
  GeneratorDone,
  GenericResult,
  GenericResult_GenericStatus,
  ModalClientClient,
} from "../proto/modal_proto/api";
import { client, getOrCreateInputPlaneClient } from "./client";
import { FunctionTimeoutError, InternalFailure, RemoteError } from "./errors";
import { loads } from "./pickle";

// From: modal-client/modal/_utils/function_utils.py
const outputsTimeout = 55 * 1000;

/**
 * This abstraction exists so that we can easily send inputs to either the control plane or the input plane.
 * For the control plane, we call the FunctionMap, FunctionRetryInputs, and FunctionGetOutputs RPCs.
 * For the input plane, we call the AttemptStart, AttemptRetry, and AttemptAwait RPCs.
 * For now, we support just the control plane, and will add support for the input plane soon.
 */
export interface Invocation {
  awaitOutput(timeout?: number): Promise<any>;
  retry(retryCount: number): Promise<void>;
}

/**
 * Implementation of Invocation which sends inputs to the control plane.
 */
export class ControlPlaneInvocation implements Invocation {
  readonly functionCallId: string;
  private readonly input?: FunctionInput;
  private readonly functionCallJwt?: string;
  private inputJwt?: string;

  private constructor(
    functionCallId: string,
    input?: FunctionInput,
    functionCallJwt?: string,
    inputJwt?: string,
  ) {
    this.functionCallId = functionCallId;
    this.input = input;
    this.functionCallJwt = functionCallJwt;
    this.inputJwt = inputJwt;
  }

  static async create(
    functionId: string,
    input: FunctionInput,
    invocationType: FunctionCallInvocationType,
  ) {
    const functionPutInputsItem = FunctionPutInputsItem.create({
      idx: 0,
      input,
    });

    const functionMapResponse = await client.functionMap({
      functionId,
      functionCallType: FunctionCallType.FUNCTION_CALL_TYPE_UNARY,
      functionCallInvocationType: invocationType,
      pipelinedInputs: [functionPutInputsItem],
    });

    return new ControlPlaneInvocation(
      functionMapResponse.functionCallId,
      input,
      functionMapResponse.functionCallJwt,
      functionMapResponse.pipelinedInputs[0].inputJwt,
    );
  }

  static fromFunctionCallId(functionCallId: string) {
    return new ControlPlaneInvocation(functionCallId);
  }

  async awaitOutput(timeout?: number): Promise<any> {
    return await pollFunctionOutput(
      (timeoutMillis: number) => this.#getOutput(timeoutMillis),
      timeout,
    );
  }

  async #getOutput(
    timeoutMillis: number,
  ): Promise<FunctionGetOutputsItem | undefined> {
    const response = await client.functionGetOutputs({
      functionCallId: this.functionCallId,
      maxValues: 1,
      timeout: timeoutMillis / 1000, // Backend needs seconds
      lastEntryId: "0-0",
      clearOnSuccess: true,
      requestedAt: timeNowSeconds(),
    });
    return response.outputs ? response.outputs[0] : undefined;
  }

  async retry(retryCount: number): Promise<void> {
    // we do not expect this to happen
    if (!this.input) {
      throw new Error("Cannot retry Function invocation - input missing");
    }

    const retryItem: FunctionRetryInputsItem = {
      inputJwt: this.inputJwt!,
      input: this.input,
      retryCount,
    };

    const functionRetryResponse = await client.functionRetryInputs({
      functionCallJwt: this.functionCallJwt,
      inputs: [retryItem],
    });
    this.inputJwt = functionRetryResponse.inputJwts[0];
  }
}

/**
 * Implementation of Invocation which sends inputs to the input plane.
 */
export class InputPlaneInvocation implements Invocation {
  private readonly client: ModalClientClient;
  private readonly functionId: string;
  private readonly input: FunctionPutInputsItem;
  private attemptToken: string;

  constructor(
    client: ModalClientClient,
    functionId: string,
    input: FunctionPutInputsItem,
    attemptToken: string,
  ) {
    this.client = client;
    this.functionId = functionId;
    this.input = input;
    this.attemptToken = attemptToken;
  }

  static async create(
    inputPlaneUrl: string,
    functionId: string,
    input: FunctionInput,
  ) {
    const functionPutInputsItem = FunctionPutInputsItem.create({
      idx: 0,
      input,
    });
    const client = getOrCreateInputPlaneClient(inputPlaneUrl);
    // Single input sync invocation
    const attemptStartResponse = await client.attemptStart({
      functionId,
      input: functionPutInputsItem,
    });
    return new InputPlaneInvocation(
      client,
      functionId,
      functionPutInputsItem,
      attemptStartResponse.attemptToken,
    );
  }

  async awaitOutput(timeout?: number): Promise<any> {
    return await pollFunctionOutput(
      (timeoutMillis: number) => this.#getOutput(timeoutMillis),
      timeout,
    );
  }

  async #getOutput(
    timeoutMillis: number,
  ): Promise<FunctionGetOutputsItem | undefined> {
    const response = await this.client.attemptAwait({
      attemptToken: this.attemptToken,
      requestedAt: timeNowSeconds(),
      timeoutSecs: timeoutMillis / 1000,
    });
    return response.output;
  }

  async retry(_retryCount: number): Promise<void> {
    const attemptRetryResponse = await this.client.attemptRetry({
      functionId: this.functionId,
      input: this.input,
      attemptToken: this.attemptToken,
    });
    this.attemptToken = attemptRetryResponse.attemptToken;
  }
}

function timeNowSeconds() {
  return Date.now() / 1e3;
}

/**
 * Signature of a function that fetches a single output using the given timeout. Used by `pollForOutputs` to fetch
 * from either the control plane or the input plane, depending on the implementation.
 */
type GetOutput = (
  timeoutMillis: number,
) => Promise<FunctionGetOutputsItem | undefined>;

/***
 * Repeatedly tries to fetch an output using the provided `getOutput` function, and the specified timeout value.
 * We use a timeout value of 55 seconds if the caller does not specify a timeout value, or if the specified timeout
 * value is greater than 55 seconds.
 */
async function pollFunctionOutput(
  getOutput: GetOutput,
  timeout?: number, // in milliseconds
): Promise<any> {
  const startTime = Date.now();
  let pollTimeout = outputsTimeout;
  if (timeout !== undefined) {
    pollTimeout = Math.min(timeout, outputsTimeout);
  }

  while (true) {
    const output = await getOutput(pollTimeout);
    if (output) {
      return await processResult(output.result, output.dataFormat);
    }

    if (timeout !== undefined) {
      const remainingTime = timeout - (Date.now() - startTime);
      if (remainingTime <= 0) {
        const message = `Timeout exceeded: ${(timeout / 1000).toFixed(1)}s`;
        throw new FunctionTimeoutError(message);
      }
      pollTimeout = Math.min(outputsTimeout, remainingTime);
    }
  }
}

async function processResult(
  result: GenericResult | undefined,
  dataFormat: DataFormat,
): Promise<unknown> {
  if (!result) {
    throw new Error("Received null result from invocation");
  }

  let data = new Uint8Array();
  if (result.data !== undefined) {
    data = result.data;
  } else if (result.dataBlobId) {
    data = await blobDownload(result.dataBlobId);
  }

  switch (result.status) {
    case GenericResult_GenericStatus.GENERIC_STATUS_TIMEOUT:
      throw new FunctionTimeoutError(`Timeout: ${result.exception}`);
    case GenericResult_GenericStatus.GENERIC_STATUS_INTERNAL_FAILURE:
      throw new InternalFailure(`Internal failure: ${result.exception}`);
    case GenericResult_GenericStatus.GENERIC_STATUS_SUCCESS:
      // Proceed to deserialize the data.
      break;
    default:
      // Handle other statuses, e.g., remote error.
      throw new RemoteError(`Remote error: ${result.exception}`);
  }

  return deserializeDataFormat(data, dataFormat);
}

async function blobDownload(blobId: string): Promise<Uint8Array> {
  const resp = await client.blobGet({ blobId });
  const s3resp = await fetch(resp.downloadUrl);
  if (!s3resp.ok) {
    throw new Error(`Failed to download blob: ${s3resp.statusText}`);
  }
  const buf = await s3resp.arrayBuffer();
  return new Uint8Array(buf);
}

function deserializeDataFormat(
  data: Uint8Array | undefined,
  dataFormat: DataFormat,
): unknown {
  if (!data) {
    return null; // No data to deserialize.
  }

  switch (dataFormat) {
    case DataFormat.DATA_FORMAT_PICKLE:
      return loads(data);
    case DataFormat.DATA_FORMAT_ASGI:
      throw new Error("ASGI data format is not supported in Go");
    case DataFormat.DATA_FORMAT_GENERATOR_DONE:
      return GeneratorDone.decode(data);
    default:
      throw new Error(`Unsupported data format: ${dataFormat}`);
  }
}



================================================
FILE: modal-js/src/pickle.test.ts
================================================
import { describe, expect, test } from "vitest";
import { dumps, loads, type Protocol } from "./pickle";
import { Buffer } from "node:buffer";

test("PickleUnpickle", () => {
  const sample = {
    a: 1,
    b: [2, 3, true, null],
    c: new Uint8Array([4, 5, 6]),
    d: "hello 🎉",
  };
  for (const proto of [3, 4, 5] as Protocol[]) {
    const pkl = dumps(sample, proto);
    const back = loads(pkl);
    expect(back).toEqual(sample);
  }
});

// Python pickle compatibility tests (v4)
// Using `python -c "import pickle, base64; print(base64.b64encode(pickle.dumps(..., protocol=4)).decode())"`
const testCases = [
  {
    name: "MinusOne",
    b64: "gASVBgAAAAAAAABK/////y4=",
    expected: -1,
  },
  {
    // [b'1', b'2', b'3']
    name: "BytesList - uses MARK and APPENDS",
    b64: "gASVEQAAAAAAAABdlChDATGUQwEylEMBM5RlLg==",
    expected: [
      new Uint8Array([49]),
      new Uint8Array([50]),
      new Uint8Array([51]),
    ],
  },
  {
    name: "SimpleList",
    b64: "gASVCwAAAAAAAABdlChLAUsCSwNlLg==",
    expected: [1, 2, 3],
  },
  {
    name: "SimpleDict",
    b64: "gASVEQAAAAAAAAB9lCiMAWGUSwGMAWKUSwJ1Lg==",
    expected: { a: 1, b: 2 },
  },
  // Integer edge cases
  { name: "BININT1_0", b64: "gARLAC4=", expected: 0 },
  { name: "BININT1_255", b64: "gARL/y4=", expected: 255 },
  { name: "BININT2_-32768", b64: "gASVBgAAAAAAAABKAID//y4=", expected: -32768 },
  { name: "BININT2_32767", b64: "gASVBAAAAAAAAABN/38u", expected: 32767 },
  {
    name: "BININT4_-2147483648",
    b64: "gASVBgAAAAAAAABKAAAAgC4=",
    expected: -2147483648,
  },
  {
    name: "BININT4_2147483647",
    b64: "gASVBgAAAAAAAABK////fy4=",
    expected: 2147483647,
  },
];

describe("Python compatibility", () => {
  for (const { name, b64, expected } of testCases) {
    test(name, () => {
      const buf = Buffer.from(b64, "base64");
      const val = loads(new Uint8Array(buf));
      expect(val).toEqual(expected);
      expect(loads(dumps(val, 4))).toEqual(val);
    });
  }
});



================================================
FILE: modal-js/src/pickle.ts
================================================
// Minimal pickle codec in TypeScript supporting protocol 3, 4 and 5
// ============================================================
// Focus: JSON‑compatible primitives (null, bool, number, string, arrays, plain
//         objects) plus Uint8Array.  The encoder can *emit* protocol 3, 4 or 5
// (default 4).  The decoder can *read* any pickle whose first PROTO opcode is
// 3, 4 or 5 **provided it only uses the opcodes below**.  This is *not* a full
// Python pickler, but is more than good enough for lightweight data exchange.
// -------------------------------------------------------------
// Implemented opcodes
//   Generic:  PROTO, STOP, NONE, NEWTRUE, NEWFALSE
//   Numbers:  BININT1, BININT2, BININT4 (aka BININT), BINFLOAT
//   Text:     SHORT_BINUNICODE, BINUNICODE, BINUNICODE8
//   Bytes:    SHORT_BINBYTES,  BINBYTES,  BINBYTES8
//   Containers: EMPTY_LIST, APPEND, EMPTY_DICT, SETITEM, MARK, SETITEMS, APPENDS
//   Memo:     MEMOIZE   (≥4), BINPUT/LONG_BINPUT + BINGET/LONG_BINGET (≤3)
//   Frames:   FRAME (proto‑5) – we just skip the announced length.
// -------------------------------------------------------------

class PickleError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PickleError";
  }
}

// ─── Opcode values (single‑byte) ─────────────────────────────
const enum Op {
  PROTO = 0x80, // PROTO n
  STOP = 0x2e, // .
  NONE = 0x4e, // N
  NEWTRUE = 0x88, // \x88
  NEWFALSE = 0x89, // \x89

  BININT1 = 0x4b, // K  (uint8)
  BININT2 = 0x4d, // M  (uint16 LE)
  BININT4 = 0x4a, // J  (int32 LE)
  BINFLOAT = 0x47, // G  (float64 BE)

  SHORT_BINUNICODE = 0x8c, // \x8c len(1) data
  BINUNICODE = 0x58, // X len(4) data
  BINUNICODE8 = 0x8d, // \x8d len(8) data (≥4)

  SHORT_BINBYTES = 0x43, // C len(1) data (≥3)
  BINBYTES = 0x42, // B len(4) data (≥3)
  BINBYTES8 = 0x8e, // \x8e len(8) data (≥4)

  EMPTY_LIST = 0x5d, // ]
  APPEND = 0x61, // a
  EMPTY_DICT = 0x7d, // }
  SETITEM = 0x73, // s
  MARK = 0x28, // (  (mark stack position)

  // Memo / frame machinery
  BINPUT = 0x71, // q  idx(1)
  LONG_BINPUT = 0x72, // r  idx(4)
  BINGET = 0x68, // h  idx(1)
  LONG_BINGET = 0x6a, // j  idx(4)
  MEMOIZE = 0x94, // \x94 (≥4)
  FRAME = 0x95, // \x95 size(8) (proto‑5)
  APPENDS = 0x65, // e
  SETITEMS = 0x75, // u
}

// ─── Binary helpers ─────────────────────────────────────────
class Writer {
  private out: number[] = [];
  byte(b: number) {
    this.out.push(b & 0xff);
  }
  bytes(arr: Uint8Array | number[]) {
    for (const b of arr) this.byte(b as number);
  }
  uint32LE(x: number) {
    this.byte(x);
    this.byte(x >>> 8);
    this.byte(x >>> 16);
    this.byte(x >>> 24);
  }
  uint64LE(n: number | bigint) {
    let v = BigInt(n);
    for (let i = 0; i < 8; i++) {
      this.byte(Number(v & 0xffn));
      v >>= 8n;
    }
  }
  float64BE(v: number) {
    const dv = new DataView(new ArrayBuffer(8));
    dv.setFloat64(0, v, false);
    this.bytes(new Uint8Array(dv.buffer));
  }
  toUint8(): Uint8Array {
    return new Uint8Array(this.out);
  }
}

class Reader {
  constructor(
    private buf: Uint8Array,
    private pos = 0,
  ) {}
  eof() {
    return this.pos >= this.buf.length;
  }
  byte() {
    return this.buf[this.pos++];
  }
  take(n: number) {
    const s = this.buf.subarray(this.pos, this.pos + n);
    this.pos += n;
    return s;
  }
  uint32LE() {
    const b0 = this.byte(),
      b1 = this.byte(),
      b2 = this.byte(),
      b3 = this.byte();
    return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
  }
  uint64LE() {
    const lo = this.uint32LE() >>> 0;
    const hi = this.uint32LE() >>> 0;
    return hi * 2 ** 32 + lo;
  }
  int32LE() {
    const v = new DataView(
      this.buf.buffer,
      this.buf.byteOffset + this.pos,
      4,
    ).getInt32(0, true);
    this.pos += 4;
    return v;
  }
  float64BE() {
    const v = new DataView(
      this.buf.buffer,
      this.buf.byteOffset + this.pos,
      8,
    ).getFloat64(0, false);
    this.pos += 8;
    return v;
  }
}

// ─── Encoder ────────────────────────────────────────────────
export type Protocol = 3 | 4 | 5;

function encodeValue(val: any, w: Writer, proto: Protocol) {
  // null / bool ------------------------------------------------
  if (val === null || val === undefined) {
    w.byte(Op.NONE);
    return;
  }
  if (typeof val === "boolean") {
    w.byte(val ? Op.NEWTRUE : Op.NEWFALSE);
    return;
  }

  // number -----------------------------------------------------
  if (typeof val === "number") {
    if (Number.isInteger(val)) {
      if (val >= 0 && val <= 0xff) {
        w.byte(Op.BININT1);
        w.byte(val);
      } else if (val >= -0x8000 && val <= 0x7fff) {
        w.byte(Op.BININT2);
        w.byte(val & 0xff);
        w.byte((val >> 8) & 0xff);
      } else {
        w.byte(Op.BININT4);
        w.uint32LE(val >>> 0);
      }
    } else {
      w.byte(Op.BINFLOAT);
      w.float64BE(val);
    }
    maybeMemoize(w, proto);
    return;
  }

  // string -----------------------------------------------------
  if (typeof val === "string") {
    const utf8 = new TextEncoder().encode(val);
    if (proto >= 4 && utf8.length < 256) {
      w.byte(Op.SHORT_BINUNICODE);
      w.byte(utf8.length);
    } else if (proto >= 4 && utf8.length > 0xffff_ffff) {
      w.byte(Op.BINUNICODE8);
      w.uint64LE(utf8.length);
    } else {
      w.byte(Op.BINUNICODE);
      w.uint32LE(utf8.length);
    }
    w.bytes(utf8);
    maybeMemoize(w, proto);
    return;
  }

  // bytes / Uint8Array ----------------------------------------
  if (val instanceof Uint8Array) {
    const len = val.length;
    if (proto >= 4 && len < 256) {
      w.byte(Op.SHORT_BINBYTES);
      w.byte(len);
    } else if (proto >= 4 && len > 0xffff_ffff) {
      w.byte(Op.BINBYTES8);
      w.uint64LE(len);
    } else {
      w.byte(Op.BINBYTES);
      w.uint32LE(len);
    }
    w.bytes(val);
    maybeMemoize(w, proto);
    return;
  }

  // Array ------------------------------------------------------
  if (Array.isArray(val)) {
    w.byte(Op.EMPTY_LIST);
    maybeMemoize(w, proto);
    for (const item of val) {
      encodeValue(item, w, proto);
      w.byte(Op.APPEND);
    }
    return;
  }

  // plain object ----------------------------------------------
  if (typeof val === "object") {
    w.byte(Op.EMPTY_DICT);
    maybeMemoize(w, proto);
    for (const [k, v] of Object.entries(val)) {
      encodeValue(k, w, proto);
      encodeValue(v, w, proto);
      w.byte(Op.SETITEM);
    }
    return;
  }

  throw new PickleError(
    `The JS Modal SDK does not support encoding/pickling data of type ${typeof val}`,
  );
}

function maybeMemoize(w: Writer, proto: Protocol) {
  if (proto >= 4) {
    w.byte(Op.MEMOIZE);
  } // super-simple strategy: memo every value >=4
}

export function dumps(obj: any, protocol: Protocol = 4): Uint8Array {
  if (![3, 4, 5].includes(protocol))
    throw new PickleError(
      `The JS Modal SDK does not support pickle protocol version ${protocol}`,
    );
  const w = new Writer();
  w.byte(Op.PROTO);
  w.byte(protocol);
  if (protocol === 5) {
    // Emit a minimal zero‑length FRAME so CPython recognises proto‑5 content.
    w.byte(Op.FRAME);
    w.uint64LE(0);
  }
  encodeValue(obj, w, protocol);
  w.byte(Op.STOP);
  return w.toUint8();
}

// ─── Decoder ────────────────────────────────────────────────
export function loads(buf: Uint8Array): any {
  const r = new Reader(buf);
  const op0 = r.byte();
  if (op0 !== Op.PROTO) throw new PickleError("pickle missing PROTO header");
  const proto: Protocol = r.byte() as Protocol;
  if (![3, 4, 5].includes(proto))
    throw new PickleError(
      `The JS Modal SDK does not support pickle protocol version ${proto}`,
    );

  const stack: any[] = [];
  const memo: any[] = [];
  const tdec = new TextDecoder();

  function push(v: any) {
    stack.push(v);
  }
  function pop() {
    return stack.pop();
  }

  // If proto‑5 and next opcode is FRAME, consume size then continue.
  if (proto === 5 && buf[r["pos"]] === Op.FRAME) {
    r.byte(); // FRAME
    const size = r.uint64LE(); // we ignore the size and just stream‑read.
    void size; // silence tsclint
  }

  // Unique marker for stack operations (cannot be confused with user data)
  const MARK = Symbol("pickle-mark");

  while (!r.eof()) {
    const op = r.byte();
    switch (op) {
      case Op.STOP:
        return stack.pop();
      case Op.NONE:
        push(null);
        break;
      case Op.NEWTRUE:
        push(true);
        break;
      case Op.NEWFALSE:
        push(false);
        break;

      case Op.BININT1:
        push(r.byte());
        break;
      case Op.BININT2: {
        const lo = r.byte(),
          hi = r.byte();
        const n = (hi << 8) | lo;
        push(n & 0x8000 ? n - 0x10000 : n);
        break;
      }
      case Op.BININT4: {
        push(r.int32LE());
        break;
      }
      case Op.BINFLOAT:
        push(r.float64BE());
        break;

      case Op.SHORT_BINUNICODE: {
        const n = r.byte();
        push(tdec.decode(r.take(n)));
        break;
      }
      case Op.BINUNICODE: {
        const n = r.uint32LE();
        push(tdec.decode(r.take(n)));
        break;
      }
      case Op.BINUNICODE8: {
        const n = r.uint64LE();
        push(tdec.decode(r.take(n)));
        break;
      }

      case Op.SHORT_BINBYTES: {
        const n = r.byte();
        push(r.take(n));
        break;
      }
      case Op.BINBYTES: {
        const n = r.uint32LE();
        push(r.take(n));
        break;
      }
      case Op.BINBYTES8: {
        const n = r.uint64LE();
        push(r.take(n));
        break;
      }

      case Op.EMPTY_LIST:
        push([]);
        break;
      case Op.APPEND: {
        const v = pop();
        const lst = pop();
        lst.push(v);
        push(lst);
        break;
      }
      case Op.EMPTY_DICT:
        push({});
        break;
      case Op.SETITEM: {
        const v = pop(),
          k = pop(),
          d = pop();
        d[k] = v;
        push(d);
        break;
      }

      // Memo handling ----------------------------------------
      case Op.MEMOIZE:
        memo.push(stack[stack.length - 1]);
        break;
      case Op.BINPUT:
        memo[r.byte()] = stack[stack.length - 1];
        break;
      case Op.LONG_BINPUT:
        memo[r.uint32LE()] = stack[stack.length - 1];
        break;
      case Op.BINGET:
        push(memo[r.byte()]);
        break;
      case Op.LONG_BINGET:
        push(memo[r.uint32LE()]);
        break;

      case Op.FRAME: {
        const _size = r.uint64LE();
        /* ignore */ break;
      }

      case Op.MARK:
        push(MARK);
        break;

      case Op.APPENDS: {
        // Pops all items after the last MARK and appends them to the list below the MARK
        // Find the last MARK
        const markIndex = stack.lastIndexOf(MARK);
        if (markIndex === -1) {
          throw new PickleError("APPENDS without MARK");
        }
        const lst = stack[markIndex - 1];
        if (!Array.isArray(lst)) {
          throw new PickleError("APPENDS expects a list below MARK");
        }
        const items = stack.slice(markIndex + 1);
        lst.push(...items);
        stack.length = markIndex - 1; // Remove everything after the list
        push(lst);
        break;
      }

      case Op.SETITEMS: {
        // Sets multiple key-value pairs in a dict after the last MARK
        // Find the last MARK
        const markIndex = stack.lastIndexOf(MARK);
        if (markIndex === -1) {
          throw new PickleError("SETITEMS without MARK");
        }
        const d = stack[markIndex - 1];
        if (typeof d !== "object" || d === null || Array.isArray(d)) {
          throw new PickleError("SETITEMS expects a dict below MARK");
        }
        const items = stack.slice(markIndex + 1);
        // Set key-value pairs (items come in pairs: key, value, key, value, ...)
        for (let i = 0; i < items.length; i += 2) {
          if (i + 1 < items.length) {
            d[items[i]] = items[i + 1];
          }
        }
        stack.length = markIndex - 1; // Remove everything after the dict
        push(d);
        break;
      }

      default:
        throw new PickleError(
          `The JS Modal SDK does not support decoding/unpickling this kind of data. Error: unsupported opcode 0x${op.toString(16)}`,
        );
    }
  }
  throw new PickleError("pickle stream ended without STOP");
}



================================================
FILE: modal-js/src/proxy.ts
================================================
import { client } from "./client";
import { environmentName as configEnvironmentName } from "./config";
import { ClientError, Status } from "nice-grpc";
import { NotFoundError } from "./errors";

/** Options for `Proxy.fromName()`. */
export type ProxyFromNameOptions = {
  environment?: string;
};

/** Proxy objects give your Modal containers a static outbound IP address. */
export class Proxy {
  readonly proxyId: string;

  /** @ignore */
  constructor(proxyId: string) {
    this.proxyId = proxyId;
  }

  /** Reference a Proxy by its name. */
  static async fromName(
    name: string,
    options?: ProxyFromNameOptions,
  ): Promise<Proxy> {
    try {
      const resp = await client.proxyGet({
        name,
        environmentName: configEnvironmentName(options?.environment),
      });
      if (!resp.proxy?.proxyId) {
        throw new NotFoundError(`Proxy '${name}' not found`);
      }
      return new Proxy(resp.proxy.proxyId);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(`Proxy '${name}' not found`);
      throw err;
    }
  }
}



================================================
FILE: modal-js/src/queue.ts
================================================
// Queue object, to be used with Modal Queues.

import {
  ObjectCreationType,
  QueueNextItemsRequest,
} from "../proto/modal_proto/api";
import type { DeleteOptions, EphemeralOptions, LookupOptions } from "./app";
import { client } from "./client";
import { environmentName } from "./config";
import { InvalidError, QueueEmptyError, QueueFullError } from "./errors";
import { dumps, loads } from "./pickle";
import { ClientError, Status } from "nice-grpc";
import { EphemeralHeartbeatManager } from "./ephemeral";

const queueInitialPutBackoff = 100; // 100 milliseconds
const queueDefaultPartitionTtl = 24 * 3600 * 1000; // 24 hours

/** Options to configure a `Queue.clear()` operation. */
export type QueueClearOptions = {
  /** Partition to clear, uses default partition if not set. */
  partition?: string;

  /** Set to clear all Queue partitions. */
  all?: boolean;
};

/** Options to configure a `Queue.get()` or `Queue.getMany()` operation. */
export type QueueGetOptions = {
  /** How long to wait if the Queue is empty (default: indefinite). */
  timeout?: number;

  /** Partition to fetch values from, uses default partition if not set. */
  partition?: string;
};

/** Options to configure a `Queue.put()` or `Queue.putMany()` operation. */
export type QueuePutOptions = {
  /** How long to wait if the Queue is full (default: indefinite). */
  timeout?: number;

  /** Partition to add items to, uses default partition if not set. */
  partition?: string;

  /** TTL for the partition in seconds (default: 1 day). */
  partitionTtl?: number;
};

/** Options to configure a `Queue.len()` operation. */
export type QueueLenOptions = {
  /** Partition to compute length, uses default partition if not set. */
  partition?: string;

  /** Return the total length across all partitions. */
  total?: boolean;
};

/** Options to configure a `Queue.iterate()` operation. */
export type QueueIterateOptions = {
  /** How long to wait between successive items before exiting iteration (default: 0). */
  itemPollTimeout?: number;

  /** Partition to iterate, uses default partition if not set. */
  partition?: string;
};

/**
 * Distributed, FIFO queue for data flow in Modal Apps.
 */
export class Queue {
  readonly queueId: string;
  readonly name?: string;
  readonly #ephemeralHbManager?: EphemeralHeartbeatManager;

  /** @ignore */
  constructor(
    queueId: string,
    name?: string,
    ephemeralHbManager?: EphemeralHeartbeatManager,
  ) {
    this.queueId = queueId;
    this.name = name;
    this.#ephemeralHbManager = ephemeralHbManager;
  }

  static #validatePartitionKey(partition: string | undefined): Uint8Array {
    if (partition) {
      const partitionKey = new TextEncoder().encode(partition);
      if (partitionKey.length === 0 || partitionKey.length > 64) {
        throw new InvalidError(
          "Queue partition key must be between 1 and 64 bytes.",
        );
      }
      return partitionKey;
    }
    return new Uint8Array();
  }

  /**
   * Create a nameless, temporary Queue.
   * You will need to call `closeEphemeral()` to delete the Queue.
   */
  static async ephemeral(options: EphemeralOptions = {}): Promise<Queue> {
    const resp = await client.queueGetOrCreate({
      objectCreationType: ObjectCreationType.OBJECT_CREATION_TYPE_EPHEMERAL,
      environmentName: environmentName(options.environment),
    });

    const ephemeralHbManager = new EphemeralHeartbeatManager(() =>
      client.queueHeartbeat({ queueId: resp.queueId }),
    );

    return new Queue(resp.queueId, undefined, ephemeralHbManager);
  }

  /** Delete the ephemeral Queue. Only usable with `Queue.ephemeral()`. */
  closeEphemeral(): void {
    if (this.#ephemeralHbManager) {
      this.#ephemeralHbManager.stop();
    } else {
      throw new InvalidError("Queue is not ephemeral.");
    }
  }

  /**
   * Lookup a Queue by name.
   */
  static async lookup(
    name: string,
    options: LookupOptions = {},
  ): Promise<Queue> {
    const resp = await client.queueGetOrCreate({
      deploymentName: name,
      objectCreationType: options.createIfMissing
        ? ObjectCreationType.OBJECT_CREATION_TYPE_CREATE_IF_MISSING
        : undefined,
      environmentName: environmentName(options.environment),
    });
    return new Queue(resp.queueId, name);
  }

  /** Delete a Queue by name. */
  static async delete(
    name: string,
    options: DeleteOptions = {},
  ): Promise<void> {
    const queue = await Queue.lookup(name, options);
    await client.queueDelete({ queueId: queue.queueId });
  }

  /**
   * Remove all objects from a Queue partition.
   */
  async clear(options: QueueClearOptions = {}): Promise<void> {
    if (options.partition && options.all) {
      throw new InvalidError(
        "Partition must be null when requesting to clear all.",
      );
    }
    await client.queueClear({
      queueId: this.queueId,
      partitionKey: Queue.#validatePartitionKey(options.partition),
      allPartitions: options.all,
    });
  }

  async #get(n: number, partition?: string, timeout?: number): Promise<any[]> {
    const partitionKey = Queue.#validatePartitionKey(partition);

    const startTime = Date.now();
    let pollTimeout = 50_000;
    if (timeout !== undefined) {
      pollTimeout = Math.min(pollTimeout, timeout);
    }

    while (true) {
      const response = await client.queueGet({
        queueId: this.queueId,
        partitionKey,
        timeout: pollTimeout / 1000,
        nValues: n,
      });
      if (response.values && response.values.length > 0) {
        return response.values.map((value) => loads(value));
      }
      if (timeout !== undefined) {
        const remaining = timeout - (Date.now() - startTime);
        if (remaining <= 0) {
          const message = `Queue ${this.queueId} did not return values within ${timeout}ms.`;
          throw new QueueEmptyError(message);
        }
        pollTimeout = Math.min(pollTimeout, remaining);
      }
    }
  }

  /**
   * Remove and return the next object from the Queue.
   *
   * By default, this will wait until at least one item is present in the Queue.
   * If `timeout` is set, raises `QueueEmptyError` if no items are available
   * within that timeout in milliseconds.
   */
  async get(options: QueueGetOptions = {}): Promise<any | null> {
    const values = await this.#get(1, options.partition, options.timeout);
    return values[0]; // Must have length >= 1 if returned.
  }

  /**
   * Remove and return up to `n` objects from the Queue.
   *
   * By default, this will wait until at least one item is present in the Queue.
   * If `timeout` is set, raises `QueueEmptyError` if no items are available
   * within that timeout in milliseconds.
   */
  async getMany(n: number, options: QueueGetOptions = {}): Promise<any[]> {
    return await this.#get(n, options.partition, options.timeout);
  }

  async #put(
    values: any[],
    timeout?: number,
    partition?: string,
    partitionTtl?: number,
  ): Promise<void> {
    const valuesEncoded = values.map((v) => dumps(v));
    const partitionKey = Queue.#validatePartitionKey(partition);

    let delay = queueInitialPutBackoff;
    const deadline = timeout ? Date.now() + timeout : undefined;
    while (true) {
      try {
        await client.queuePut({
          queueId: this.queueId,
          values: valuesEncoded,
          partitionKey,
          partitionTtlSeconds:
            (partitionTtl || queueDefaultPartitionTtl) / 1000,
        });
        break;
      } catch (e) {
        if (e instanceof ClientError && e.code === Status.RESOURCE_EXHAUSTED) {
          // Queue is full, retry with exponential backoff up to the deadline.
          delay = Math.min(delay * 2, 30_000);
          if (deadline !== undefined) {
            const remaining = deadline - Date.now();
            if (remaining <= 0)
              throw new QueueFullError(`Put failed on ${this.queueId}.`);
            delay = Math.min(delay, remaining);
          }
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          throw e;
        }
      }
    }
  }

  /**
   * Add an item to the end of the Queue.
   *
   * If the Queue is full, this will retry with exponential backoff until the
   * provided `timeout` is reached, or indefinitely if `timeout` is not set.
   * Raises `QueueFullError` if the Queue is still full after the timeout.
   */
  async put(v: any, options: QueuePutOptions = {}): Promise<void> {
    await this.#put(
      [v],
      options.timeout,
      options.partition,
      options.partitionTtl,
    );
  }

  /**
   * Add several items to the end of the Queue.
   *
   * If the Queue is full, this will retry with exponential backoff until the
   * provided `timeout` is reached, or indefinitely if `timeout` is not set.
   * Raises `QueueFullError` if the Queue is still full after the timeout.
   */
  async putMany(values: any[], options: QueuePutOptions = {}): Promise<void> {
    await this.#put(
      values,
      options.timeout,
      options.partition,
      options.partitionTtl,
    );
  }

  /** Return the number of objects in the Queue. */
  async len(options: QueueLenOptions = {}): Promise<number> {
    if (options.partition && options.total) {
      throw new InvalidError(
        "Partition must be null when requesting total length.",
      );
    }
    const resp = await client.queueLen({
      queueId: this.queueId,
      partitionKey: Queue.#validatePartitionKey(options.partition),
      total: options.total,
    });
    return resp.len;
  }

  /** Iterate through items in a Queue without mutation. */
  async *iterate(
    options: QueueIterateOptions = {},
  ): AsyncGenerator<any, void, unknown> {
    const { partition, itemPollTimeout = 0 } = options;

    let lastEntryId = undefined;
    const validatedPartitionKey = Queue.#validatePartitionKey(partition);
    let fetchDeadline = Date.now() + itemPollTimeout;

    const maxPollDuration = 30_000;
    while (true) {
      const pollDuration = Math.max(
        0.0,
        Math.min(maxPollDuration, fetchDeadline - Date.now()),
      );
      const request: QueueNextItemsRequest = {
        queueId: this.queueId,
        partitionKey: validatedPartitionKey,
        itemPollTimeout: pollDuration / 1000,
        lastEntryId: lastEntryId || "",
      };

      const response = await client.queueNextItems(request);
      if (response.items && response.items.length > 0) {
        for (const item of response.items) {
          yield loads(item.value);
          lastEntryId = item.entryId;
        }
        fetchDeadline = Date.now() + itemPollTimeout;
      } else if (Date.now() > fetchDeadline) {
        break;
      }
    }
  }
}



================================================
FILE: modal-js/src/retries.ts
================================================
/** Retry policy configuration for a Modal Function/Cls. */
export class Retries {
  readonly maxRetries: number;
  readonly backoffCoefficient: number;
  readonly initialDelayMs: number;
  readonly maxDelayMs: number;

  constructor(options: {
    maxRetries: number;
    backoffCoefficient?: number;
    initialDelayMs?: number;
    maxDelayMs?: number;
  }) {
    const {
      maxRetries,
      backoffCoefficient = 2.0,
      initialDelayMs = 1000,
      maxDelayMs = 60_000,
    } = options;

    if (maxRetries < 0 || maxRetries > 10) {
      throw new Error(
        `Invalid maxRetries: ${maxRetries}. Must be between 0 and 10.`,
      );
    }

    if (backoffCoefficient < 1.0 || backoffCoefficient > 10.0) {
      throw new Error(
        `Invalid backoffCoefficient: ${backoffCoefficient}. Must be between 1.0 and 10.0`,
      );
    }

    if (initialDelayMs < 0 || initialDelayMs > 60_000) {
      throw new Error(
        `Invalid initialDelayMs: ${initialDelayMs}. Must be between 0 and 60000 ms.`,
      );
    }

    if (maxDelayMs < 1_000 || maxDelayMs > 60_000) {
      throw new Error(
        `Invalid maxDelayMs: ${maxDelayMs}. Must be between 1000 and 60000 ms.`,
      );
    }

    this.maxRetries = maxRetries;
    this.backoffCoefficient = backoffCoefficient;
    this.initialDelayMs = initialDelayMs;
    this.maxDelayMs = maxDelayMs;
  }
}

export function parseRetries(
  retries: number | Retries | undefined,
): Retries | undefined {
  if (retries === undefined) return undefined;
  if (typeof retries === "number") {
    if (!Number.isInteger(retries) || retries < 0 || retries > 10) {
      throw new Error(
        `Retries parameter must be an integer between 0 and 10. Found: ${retries}`,
      );
    }
    return new Retries({
      maxRetries: retries,
      backoffCoefficient: 1.0,
      initialDelayMs: 1000,
    });
  }
  if (retries instanceof Retries) return retries;
  throw new Error(
    `Retries parameter must be an integer or instance of Retries. Found: ${typeof retries}.`,
  );
}



================================================
FILE: modal-js/src/sandbox.ts
================================================
import { ClientError, Status } from "nice-grpc";
import {
  FileDescriptor,
  GenericResult,
  GenericResult_GenericStatus,
  PTYInfo,
  PTYInfo_PTYType,
  ContainerExecRequest,
  SandboxTagsGetResponse,
} from "../proto/modal_proto/api";
import { client, isRetryableGrpc } from "./client";
import { environmentName } from "./config";
import {
  runFilesystemExec,
  SandboxFile,
  SandboxFileMode,
} from "./sandbox_filesystem";
import {
  type ModalReadStream,
  type ModalWriteStream,
  streamConsumingIter,
  toModalReadStream,
  toModalWriteStream,
} from "./streams";
import { type Secret, mergeEnvAndSecrets } from "./secret";
import { InvalidError, NotFoundError, SandboxTimeoutError } from "./errors";
import { Image } from "./image";

/**
 * Stdin is always present, but this option allow you to drop stdout or stderr
 * if you don't need them. The default is "pipe", matching Node.js behavior.
 *
 * If behavior is set to "ignore", the output streams will be empty.
 */
export type StdioBehavior = "pipe" | "ignore";

/**
 * Specifies the type of data that will be read from the Sandbox or container
 * process. "text" means the data will be read as UTF-8 text, while "binary"
 * means the data will be read as raw bytes (Uint8Array).
 */
export type StreamMode = "text" | "binary";

/** Options for `Sandbox.list()`. */
export type SandboxListOptions = {
  /** Filter Sandboxes for a specific App. */
  appId?: string;
  /** Only return Sandboxes that include all specified tags. */
  tags?: Record<string, string>;
  /** Override environment for the request; defaults to current profile. */
  environment?: string;
};

/** Options to configure a `Sandbox.exec()` operation. */
export type ExecOptions = {
  /** Specifies text or binary encoding for input and output streams. */
  mode?: StreamMode;
  /** Whether to pipe or ignore standard output. */
  stdout?: StdioBehavior;
  /** Whether to pipe or ignore standard error. */
  stderr?: StdioBehavior;
  /** Working directory to run the command in. */
  workdir?: string;
  /** Timeout for the process in milliseconds. Defaults to 0 (no timeout). */
  timeout?: number;
  /** Environment variables to set for the command. */
  env?: Record<string, string>;
  /** Secrets to inject as environment variables for the commmand.*/
  secrets?: Secret[];
  /** Enable a PTY for the command. */
  pty?: boolean;
};

/** A port forwarded from within a running Modal Sandbox. */
export class Tunnel {
  /** @ignore */
  constructor(
    public host: string,
    public port: number,
    public unencryptedHost?: string,
    public unencryptedPort?: number,
  ) {}

  /** Get the public HTTPS URL of the forwarded port. */
  get url(): string {
    let value = `https://${this.host}`;
    if (this.port !== 443) {
      value += `:${this.port}`;
    }
    return value;
  }

  /** Get the public TLS socket as a [host, port] tuple. */
  get tlsSocket(): [string, number] {
    return [this.host, this.port];
  }

  /** Get the public TCP socket as a [host, port] tuple. */
  get tcpSocket(): [string, number] {
    if (!this.unencryptedHost || this.unencryptedPort === undefined) {
      throw new InvalidError(
        "This tunnel is not configured for unencrypted TCP.",
      );
    }
    return [this.unencryptedHost, this.unencryptedPort];
  }
}

export function defaultSandboxPTYInfo(): PTYInfo {
  return PTYInfo.create({
    enabled: true,
    winszRows: 24,
    winszCols: 80,
    envTerm: "xterm-256color",
    envColorterm: "truecolor",
    envTermProgram: "",
    ptyType: PTYInfo_PTYType.PTY_TYPE_SHELL,
    noTerminateOnIdleStdin: true,
  });
}

export async function buildContainerExecRequestProto(
  taskId: string,
  command: string[],
  options?: ExecOptions,
): Promise<ContainerExecRequest> {
  const mergedSecrets = await mergeEnvAndSecrets(
    options?.env,
    options?.secrets,
  );
  const secretIds = mergedSecrets.map((secret) => secret.secretId);

  let ptyInfo: PTYInfo | undefined;
  if (options?.pty) {
    ptyInfo = defaultSandboxPTYInfo();
  }

  return ContainerExecRequest.create({
    taskId,
    command,
    workdir: options?.workdir,
    timeoutSecs: options?.timeout ? options.timeout / 1000 : 0,
    secretIds,
    ptyInfo,
  });
}

/** Sandboxes are secure, isolated containers in Modal that boot in seconds. */
export class Sandbox {
  readonly sandboxId: string;
  stdin: ModalWriteStream<string>;
  stdout: ModalReadStream<string>;
  stderr: ModalReadStream<string>;

  #taskId: string | undefined;
  #tunnels: Record<number, Tunnel> | undefined;

  /** @ignore */
  constructor(sandboxId: string) {
    this.sandboxId = sandboxId;

    this.stdin = toModalWriteStream(inputStreamSb(sandboxId));
    this.stdout = toModalReadStream(
      streamConsumingIter(
        outputStreamSb(sandboxId, FileDescriptor.FILE_DESCRIPTOR_STDOUT),
      ).pipeThrough(new TextDecoderStream()),
    );
    this.stderr = toModalReadStream(
      streamConsumingIter(
        outputStreamSb(sandboxId, FileDescriptor.FILE_DESCRIPTOR_STDERR),
      ).pipeThrough(new TextDecoderStream()),
    );
  }

  /** Set tags (key-value pairs) on the Sandbox. Tags can be used to filter results in `Sandbox.list`. */
  async setTags(tags: Record<string, string>): Promise<void> {
    const tagsList = Object.entries(tags).map(([tagName, tagValue]) => ({
      tagName,
      tagValue,
    }));
    try {
      await client.sandboxTagsSet({
        environmentName: environmentName(),
        sandboxId: this.sandboxId,
        tags: tagsList,
      });
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.INVALID_ARGUMENT) {
        throw new InvalidError(err.details || err.message);
      }
      throw err;
    }
  }

  /** Get tags (key-value pairs) currently attached to this Sandbox from the server. */
  async getTags(): Promise<Record<string, string>> {
    let resp: SandboxTagsGetResponse;
    try {
      resp = await client.sandboxTagsGet({ sandboxId: this.sandboxId });
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.INVALID_ARGUMENT) {
        throw new InvalidError(err.details || err.message);
      }
      throw err;
    }

    const tags: Record<string, string> = {};
    for (const tag of resp.tags) {
      tags[tag.tagName] = tag.tagValue;
    }
    return tags;
  }

  /** Returns a running Sandbox object from an ID.
   *
   * @returns Sandbox with ID
   */
  static async fromId(sandboxId: string): Promise<Sandbox> {
    try {
      await client.sandboxWait({
        sandboxId,
        timeout: 0,
      });
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(`Sandbox with id: '${sandboxId}' not found`);
      throw err;
    }

    return new Sandbox(sandboxId);
  }

  /** Get a running Sandbox by name from a deployed App.
   *
   * Raises a NotFoundError if no running Sandbox is found with the given name.
   * A Sandbox's name is the `name` argument passed to `App.createSandbox`.
   *
   * @param appName - Name of the deployed App
   * @param name - Name of the Sandbox
   * @param environment - Optional override for the environment
   * @returns Promise that resolves to a Sandbox
   */
  static async fromName(
    appName: string,
    name: string,
    environment?: string,
  ): Promise<Sandbox> {
    try {
      const resp = await client.sandboxGetFromName({
        sandboxName: name,
        appName,
        environmentName: environmentName(environment),
      });
      return new Sandbox(resp.sandboxId);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(
          `Sandbox with name '${name}' not found in App '${appName}'`,
        );
      throw err;
    }
  }

  /**
   * Open a file in the Sandbox filesystem.
   * @param path - Path to the file to open
   * @param mode - File open mode (r, w, a, r+, w+, a+)
   * @returns Promise that resolves to a SandboxFile
   */
  async open(path: string, mode: SandboxFileMode = "r"): Promise<SandboxFile> {
    const taskId = await this.#getTaskId();
    const resp = await runFilesystemExec({
      fileOpenRequest: {
        path,
        mode,
      },
      taskId,
    });
    // For Open request, the file descriptor is always set
    const fileDescriptor = resp.response.fileDescriptor as string;
    return new SandboxFile(fileDescriptor, taskId);
  }

  async exec(
    command: string[],
    options?: ExecOptions & { mode?: "text" },
  ): Promise<ContainerProcess<string>>;

  async exec(
    command: string[],
    options: ExecOptions & { mode: "binary" },
  ): Promise<ContainerProcess<Uint8Array>>;

  async exec(
    command: string[],
    options?: {
      mode?: StreamMode;
      stdout?: StdioBehavior;
      stderr?: StdioBehavior;
      workdir?: string;
      timeout?: number;
      env?: Record<string, string>;
      secrets?: Secret[];
      pty?: boolean;
    },
  ): Promise<ContainerProcess> {
    const taskId = await this.#getTaskId();

    const req = await buildContainerExecRequestProto(taskId, command, options);
    const resp = await client.containerExec(req);

    return new ContainerProcess(resp.execId, options);
  }

  async #getTaskId(): Promise<string> {
    if (this.#taskId === undefined) {
      const resp = await client.sandboxGetTaskId({
        sandboxId: this.sandboxId,
      });
      if (!resp.taskId) {
        throw new Error(
          `Sandbox ${this.sandboxId} does not have a task ID. It may not be running.`,
        );
      }
      if (resp.taskResult) {
        throw new Error(
          `Sandbox ${this.sandboxId} has already completed with result: ${resp.taskResult}`,
        );
      }
      this.#taskId = resp.taskId;
    }
    return this.#taskId;
  }

  async terminate(): Promise<void> {
    await client.sandboxTerminate({ sandboxId: this.sandboxId });
    this.#taskId = undefined; // Reset task ID after termination
  }

  async wait(): Promise<number> {
    while (true) {
      const resp = await client.sandboxWait({
        sandboxId: this.sandboxId,
        timeout: 10,
      });
      if (resp.result) {
        return Sandbox.#getReturnCode(resp.result)!;
      }
    }
  }

  /** Get Tunnel metadata for the Sandbox.
   *
   * Raises `SandboxTimeoutError` if the tunnels are not available after the timeout.
   *
   * @returns A dictionary of Tunnel objects which are keyed by the container port.
   */
  async tunnels(timeout = 50000): Promise<Record<number, Tunnel>> {
    if (this.#tunnels) {
      return this.#tunnels;
    }

    const resp = await client.sandboxGetTunnels({
      sandboxId: this.sandboxId,
      timeout: timeout / 1000, // Convert to seconds
    });

    if (
      resp.result?.status === GenericResult_GenericStatus.GENERIC_STATUS_TIMEOUT
    ) {
      throw new SandboxTimeoutError();
    }

    this.#tunnels = {};
    for (const t of resp.tunnels) {
      this.#tunnels[t.containerPort] = new Tunnel(
        t.host,
        t.port,
        t.unencryptedHost,
        t.unencryptedPort,
      );
    }

    return this.#tunnels;
  }

  /**
   * Snapshot the filesystem of the Sandbox.
   *
   * Returns an `Image` object which can be used to spawn a new Sandbox with the same filesystem.
   *
   * @param timeout - Timeout for the snapshot operation in milliseconds
   * @returns Promise that resolves to an Image
   */
  async snapshotFilesystem(timeout = 55000): Promise<Image> {
    const resp = await client.sandboxSnapshotFs({
      sandboxId: this.sandboxId,
      timeout: timeout / 1000,
    });

    if (
      resp.result?.status !== GenericResult_GenericStatus.GENERIC_STATUS_SUCCESS
    ) {
      throw new Error(
        `Sandbox snapshot failed: ${resp.result?.exception || "Unknown error"}`,
      );
    }

    if (!resp.imageId) {
      throw new Error("Sandbox snapshot response missing `imageId`");
    }

    return new Image(resp.imageId, "");
  }

  /**
   * Check if the Sandbox has finished running.
   *
   * Returns `null` if the Sandbox is still running, else returns the exit code.
   */
  async poll(): Promise<number | null> {
    const resp = await client.sandboxWait({
      sandboxId: this.sandboxId,
      timeout: 0,
    });

    return Sandbox.#getReturnCode(resp.result);
  }

  /**
   * List all Sandboxes for the current Environment or App ID (if specified).
   * If tags are specified, only Sandboxes that have at least those tags are returned.
   */
  static async *list(
    options: SandboxListOptions = {},
  ): AsyncGenerator<Sandbox, void, unknown> {
    const env = environmentName(options.environment);
    const tagsList = options.tags
      ? Object.entries(options.tags).map(([tagName, tagValue]) => ({
          tagName,
          tagValue,
        }))
      : [];

    let beforeTimestamp: number | undefined = undefined;
    while (true) {
      try {
        const resp = await client.sandboxList({
          appId: options.appId,
          beforeTimestamp,
          environmentName: env,
          includeFinished: false,
          tags: tagsList,
        });
        if (!resp.sandboxes || resp.sandboxes.length === 0) {
          return;
        }
        for (const info of resp.sandboxes) {
          yield new Sandbox(info.id);
        }
        beforeTimestamp = resp.sandboxes[resp.sandboxes.length - 1].createdAt;
      } catch (err) {
        if (
          err instanceof ClientError &&
          err.code === Status.INVALID_ARGUMENT
        ) {
          throw new InvalidError(err.details || err.message);
        }
        throw err;
      }
    }
  }

  static #getReturnCode(result: GenericResult | undefined): number | null {
    if (
      result === undefined ||
      result.status === GenericResult_GenericStatus.GENERIC_STATUS_UNSPECIFIED
    ) {
      return null;
    }

    // Statuses are converted to exitcodes so we can conform to subprocess API.
    if (result.status === GenericResult_GenericStatus.GENERIC_STATUS_TIMEOUT) {
      return 124;
    } else if (
      result.status === GenericResult_GenericStatus.GENERIC_STATUS_TERMINATED
    ) {
      return 137;
    } else {
      return result.exitcode;
    }
  }
}

export class ContainerProcess<R extends string | Uint8Array = any> {
  stdin: ModalWriteStream<R>;
  stdout: ModalReadStream<R>;
  stderr: ModalReadStream<R>;
  returncode: number | null = null;

  readonly #execId: string;

  constructor(execId: string, options?: ExecOptions) {
    const mode = options?.mode ?? "text";
    const stdout = options?.stdout ?? "pipe";
    const stderr = options?.stderr ?? "pipe";

    this.#execId = execId;

    this.stdin = toModalWriteStream(inputStreamCp<R>(execId));

    let stdoutStream = streamConsumingIter(
      outputStreamCp(execId, FileDescriptor.FILE_DESCRIPTOR_STDOUT),
    );
    if (stdout === "ignore") {
      stdoutStream.cancel();
      stdoutStream = ReadableStream.from([]);
    }

    let stderrStream = streamConsumingIter(
      outputStreamCp(execId, FileDescriptor.FILE_DESCRIPTOR_STDERR),
    );
    if (stderr === "ignore") {
      stderrStream.cancel();
      stderrStream = ReadableStream.from([]);
    }

    if (mode === "text") {
      this.stdout = toModalReadStream(
        stdoutStream.pipeThrough(new TextDecoderStream()),
      ) as ModalReadStream<R>;
      this.stderr = toModalReadStream(
        stderrStream.pipeThrough(new TextDecoderStream()),
      ) as ModalReadStream<R>;
    } else {
      this.stdout = toModalReadStream(stdoutStream) as ModalReadStream<R>;
      this.stderr = toModalReadStream(stderrStream) as ModalReadStream<R>;
    }
  }

  /** Wait for process completion and return the exit code. */
  async wait(): Promise<number> {
    while (true) {
      const resp = await client.containerExecWait({
        execId: this.#execId,
        timeout: 55,
      });
      if (resp.completed) {
        return resp.exitCode ?? 0;
      }
    }
  }
}

// Like _StreamReader with object_type == "sandbox".
async function* outputStreamSb(
  sandboxId: string,
  fileDescriptor: FileDescriptor,
): AsyncIterable<Uint8Array> {
  let lastIndex = "0-0";
  let completed = false;
  let retries = 10;
  while (!completed) {
    try {
      const outputIterator = client.sandboxGetLogs({
        sandboxId,
        fileDescriptor,
        timeout: 55,
        lastEntryId: lastIndex,
      });
      for await (const batch of outputIterator) {
        lastIndex = batch.entryId;
        yield* batch.items.map((item) => new TextEncoder().encode(item.data));
        if (batch.eof) {
          completed = true;
          break;
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) retries--;
      else throw err;
    }
  }
}

// Like _StreamReader with object_type == "container_process".
async function* outputStreamCp(
  execId: string,
  fileDescriptor: FileDescriptor,
): AsyncIterable<Uint8Array> {
  let lastIndex = 0;
  let completed = false;
  let retries = 10;
  while (!completed) {
    try {
      const outputIterator = client.containerExecGetOutput({
        execId,
        fileDescriptor,
        timeout: 55,
        getRawBytes: true,
        lastBatchIndex: lastIndex,
      });
      for await (const batch of outputIterator) {
        lastIndex = batch.batchIndex;
        yield* batch.items.map((item) => item.messageBytes);
        if (batch.exitCode !== undefined) {
          // The container process exited. Python code also doesn't handle this
          // exit code, so we don't either right now.
          completed = true;
          break;
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) retries--;
      else throw err;
    }
  }
}

function inputStreamSb(sandboxId: string): WritableStream<string> {
  let index = 1;
  return new WritableStream<string>({
    async write(chunk) {
      await client.sandboxStdinWrite({
        sandboxId,
        input: encodeIfString(chunk),
        index,
      });
      index++;
    },
    async close() {
      await client.sandboxStdinWrite({
        sandboxId,
        index,
        eof: true,
      });
    },
  });
}

function inputStreamCp<R extends string | Uint8Array>(
  execId: string,
): WritableStream<R> {
  let messageIndex = 1;
  return new WritableStream<R>({
    async write(chunk) {
      await client.containerExecPutInput({
        execId,
        input: {
          message: encodeIfString(chunk),
          messageIndex,
        },
      });
      messageIndex++;
    },
    async close() {
      await client.containerExecPutInput({
        execId,
        input: {
          messageIndex,
          eof: true,
        },
      });
    },
  });
}

function encodeIfString(chunk: Uint8Array | string): Uint8Array {
  return typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
}



================================================
FILE: modal-js/src/sandbox_filesystem.ts
================================================
import {
  ContainerFilesystemExecRequest,
  DeepPartial,
  ContainerFilesystemExecResponse,
} from "../proto/modal_proto/api";
import { client, isRetryableGrpc } from "./client";
import { SandboxFilesystemError } from "./errors";

/** File open modes supported by the filesystem API. */
export type SandboxFileMode = "r" | "w" | "a" | "r+" | "w+" | "a+";

/**
 * SandboxFile represents an open file in the Sandbox filesystem.
 * Provides read/write operations similar to Node.js `fsPromises.FileHandle`.
 */
export class SandboxFile {
  readonly #fileDescriptor: string;
  readonly #taskId: string;

  /** @ignore */
  constructor(fileDescriptor: string, taskId: string) {
    this.#fileDescriptor = fileDescriptor;
    this.#taskId = taskId;
  }

  /**
   * Read data from the file.
   * @returns Promise that resolves to the read data as Uint8Array
   */
  async read(): Promise<Uint8Array> {
    const resp = await runFilesystemExec({
      fileReadRequest: {
        fileDescriptor: this.#fileDescriptor,
      },
      taskId: this.#taskId,
    });
    const chunks = resp.chunks;

    // Concatenate all chunks into a single Uint8Array
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }

    return result;
  }

  /**
   * Write data to the file.
   * @param data - Data to write (string or Uint8Array)
   */
  async write(data: Uint8Array): Promise<void> {
    await runFilesystemExec({
      fileWriteRequest: {
        fileDescriptor: this.#fileDescriptor,
        data,
      },
      taskId: this.#taskId,
    });
  }

  /**
   * Flush any buffered data to the file.
   */
  async flush(): Promise<void> {
    await runFilesystemExec({
      fileFlushRequest: {
        fileDescriptor: this.#fileDescriptor,
      },
      taskId: this.#taskId,
    });
  }

  /**
   * Close the file handle.
   */
  async close(): Promise<void> {
    await runFilesystemExec({
      fileCloseRequest: {
        fileDescriptor: this.#fileDescriptor,
      },
      taskId: this.#taskId,
    });
  }
}

export async function runFilesystemExec(
  request: DeepPartial<ContainerFilesystemExecRequest>,
): Promise<{
  chunks: Uint8Array[];
  response: ContainerFilesystemExecResponse;
}> {
  const response = await client.containerFilesystemExec(request);

  const chunks: Uint8Array[] = [];
  let retries = 10;
  let completed = false;
  while (!completed) {
    try {
      const outputIterator = client.containerFilesystemExecGetOutput({
        execId: response.execId,
        timeout: 55,
      });
      for await (const batch of outputIterator) {
        chunks.push(...batch.output);
        if (batch.eof) {
          completed = true;
          break;
        }
        if (batch.error !== undefined) {
          if (retries > 0) {
            retries--;
            break;
          }
          throw new SandboxFilesystemError(batch.error.errorMessage);
        }
      }
    } catch (err) {
      if (isRetryableGrpc(err) && retries > 0) {
        retries--;
      } else throw err;
    }
  }
  return { chunks, response };
}



================================================
FILE: modal-js/src/secret.ts
================================================
import { client } from "./client";
import { environmentName as configEnvironmentName } from "./config";
import { ClientError, Status } from "nice-grpc";
import { InvalidError, NotFoundError } from "./errors";
import { ObjectCreationType } from "../proto/modal_proto/api";

/** Options for `Secret.fromName()`. */
export type SecretFromNameOptions = {
  environment?: string;
  requiredKeys?: string[];
};

/** Secrets provide a dictionary of environment variables for Images. */
export class Secret {
  readonly secretId: string;
  readonly name?: string;

  /** @ignore */
  constructor(secretId: string, name?: string) {
    this.secretId = secretId;
    this.name = name;
  }

  /** Reference a Secret by its name. */
  static async fromName(
    name: string,
    options?: SecretFromNameOptions,
  ): Promise<Secret> {
    try {
      const resp = await client.secretGetOrCreate({
        deploymentName: name,
        environmentName: configEnvironmentName(options?.environment),
        requiredKeys: options?.requiredKeys ?? [],
      });
      return new Secret(resp.secretId, name);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(err.details);
      if (
        err instanceof ClientError &&
        err.code === Status.FAILED_PRECONDITION &&
        err.details.includes("Secret is missing key")
      )
        throw new NotFoundError(err.details);
      throw err;
    }
  }

  /** Create a Secret from a plain object of key-value pairs. */
  static async fromObject(
    entries: Record<string, string>,
    options?: { environment?: string },
  ): Promise<Secret> {
    for (const [, value] of Object.entries(entries)) {
      if (value == null || typeof value !== "string") {
        throw new InvalidError(
          "entries must be an object mapping string keys to string values, but got:\n" +
            JSON.stringify(entries),
        );
      }
    }

    try {
      const resp = await client.secretGetOrCreate({
        objectCreationType: ObjectCreationType.OBJECT_CREATION_TYPE_EPHEMERAL,
        envDict: entries as Record<string, string>,
        environmentName: configEnvironmentName(options?.environment),
      });
      return new Secret(resp.secretId);
    } catch (err) {
      if (
        err instanceof ClientError &&
        (err.code === Status.INVALID_ARGUMENT ||
          err.code === Status.FAILED_PRECONDITION)
      )
        throw new InvalidError(err.details);
      throw err;
    }
  }
}

export async function mergeEnvAndSecrets(
  env?: Record<string, string>,
  secrets?: Secret[],
): Promise<Secret[]> {
  const result = [...(secrets || [])];
  if (env && Object.keys(env).length > 0) {
    result.push(await Secret.fromObject(env));
  }
  return result;
}



================================================
FILE: modal-js/src/serialization.test.ts
================================================
// Test to make sure serialization behaviors are consistent.

import { expect, test } from "vitest";

import { ClassParameterSpec, ParameterType } from "../proto/modal_proto/api";
import { encodeParameterSet } from "./cls";

// Reproduce serialization test from the Python SDK.
// https://github.com/modal-labs/modal-client/blob/4c62d67ee2816146a2a5d42581f6fe7349fa1bf6/test/serialization_test.py
test("ParameterSerialization", () => {
  let schema: ClassParameterSpec[] = [
    ClassParameterSpec.fromPartial({
      name: "foo",
      type: ParameterType.PARAM_TYPE_STRING,
    }),
    ClassParameterSpec.fromPartial({
      name: "i",
      type: ParameterType.PARAM_TYPE_INT,
    }),
  ];
  const values = { i: 5, foo: "bar" };

  let serializedParams = encodeParameterSet(schema, values);
  let byteData = new Uint8Array([
    10, 12, 10, 3, 102, 111, 111, 16, 1, 26, 3, 98, 97, 114, 10, 7, 10, 1, 105,
    16, 2, 32, 5,
  ]);
  expect(serializedParams).toEqual(byteData);

  // Reverse the order of map keys and make sure it's deterministic.
  const reversedSchema = [schema[1], schema[0]];
  const reversedSerializedParams = encodeParameterSet(reversedSchema, values);
  expect(reversedSerializedParams).toEqual(byteData);

  // Test with a parameter that has a default value.
  schema = [
    ClassParameterSpec.create({
      name: "x",
      type: ParameterType.PARAM_TYPE_BYTES,
      hasDefault: true,
      bytesDefault: new Uint8Array([0]),
    }),
  ];
  serializedParams = encodeParameterSet(schema, {});
  byteData = new Uint8Array([10, 8, 10, 1, 120, 16, 4, 50, 1, 0]);
  expect(serializedParams).toEqual(byteData);
});



================================================
FILE: modal-js/src/streams.ts
================================================
/**
 * Wrapper around `ReadableStream` with convenience functions.
 *
 * The Stream API is a modern standard for asynchronous data streams across
 * network and process boundaries. It allows you to read data in chunks, pipe
 * and transform it, and handle backpressure.
 *
 * This wrapper adds some extra functions like `.readText()` to read the entire
 * stream as a string, or `readBytes()` to read binary data.
 *
 * Background: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API
 */
export interface ModalReadStream<R = any> extends ReadableStream<R> {
  /** Read the entire stream as a string. */
  readText(): Promise<string>;

  /** Read the entire stream as a byte array. */
  readBytes(): Promise<Uint8Array>;
}

/**
 * Wrapper around `WritableStream` with convenience functions.
 *
 * The Stream API is a modern standard for asynchronous data streams across
 * network and process boundaries. It allows you to read data in chunks, pipe
 * and transform it, and handle backpressure.
 *
 * This wrapper adds some extra functions like `.writeText()` to write a string
 * to the stream, or `writeBytes()` to write binary data.
 *
 * Background: https://developer.mozilla.org/en-US/docs/Web/API/Streams_API
 */
export interface ModalWriteStream<R = any> extends WritableStream<R> {
  /** Write a string to the stream. Only if this is a text stream. */
  writeText(text: string): Promise<void>;

  /** Write a byte array to the stream. Only if this is a byte stream. */
  writeBytes(bytes: Uint8Array): Promise<void>;
}

export function toModalReadStream<R extends string | Uint8Array = any>(
  stream: ReadableStream<R>,
): ModalReadStream<R> {
  return Object.assign(stream, readMixin);
}

export function toModalWriteStream<R extends string | Uint8Array = any>(
  stream: WritableStream<R>,
): ModalWriteStream<R> {
  return Object.assign(stream, writeMixin);
}

const readMixin = {
  async readText<R extends string | Uint8Array>(
    this: ReadableStream<R>,
  ): Promise<string> {
    const reader = this.getReader();
    try {
      const decoder = new TextDecoder("utf-8"); // used if binary
      const chunks: string[] = [];
      while (true) {
        const { value, done } = await reader.read();
        if (value) {
          if (typeof value === "string") chunks.push(value);
          else {
            chunks.push(decoder.decode(value.buffer, { stream: true }));
          }
        }
        if (done) {
          chunks.push(decoder.decode(undefined, { stream: false })); // may be empty
          break;
        }
      }
      return chunks.join("");
    } finally {
      reader.releaseLock();
    }
  },

  async readBytes<R extends string | Uint8Array>(
    this: ReadableStream<R>,
  ): Promise<Uint8Array> {
    const chunks: Uint8Array[] = [];
    const reader = this.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (value) {
          if (typeof value === "string") {
            chunks.push(new TextEncoder().encode(value));
          } else {
            chunks.push(value);
          }
        }
        if (done) break;
      }
    } finally {
      reader.releaseLock();
    }

    let totalLength = 0;
    for (const chunk of chunks) {
      totalLength += chunk.length;
    }
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      result.set(chunk, offset);
      offset += chunk.length;
    }
    return result;
  },
};

const writeMixin = {
  async writeText<R extends string | Uint8Array>(
    this: WritableStream<R>,
    text: string,
  ): Promise<void> {
    const writer = this.getWriter();
    try {
      // Cast to R so TS is happy; underlying sink must accept strings
      await writer.write(text as unknown as R);
    } finally {
      writer.releaseLock();
    }
  },

  async writeBytes<R extends string | Uint8Array>(
    this: WritableStream<R>,
    bytes: Uint8Array,
  ): Promise<void> {
    const writer = this.getWriter();
    try {
      // Cast to R so TS is happy; underlying sink must accept Uint8Array
      await writer.write(bytes as unknown as R);
    } finally {
      writer.releaseLock();
    }
  },
};

/**
 * Construct a ReadableStream from an iterator.
 * If the stream is closed, the iterator is still consumed to completion.
 */
export function streamConsumingIter(
  iterable: AsyncIterable<Uint8Array>,
): ReadableStream<Uint8Array> {
  const iter = iterable[Symbol.asyncIterator]();
  return new ReadableStream<Uint8Array>(
    {
      async pull(controller) {
        const { done, value } = await iter.next();
        if (value) {
          controller.enqueue(value);
        }
        if (done) {
          controller.close();
        }
      },
      async cancel() {
        consumeIterator(iter);
      },
    },
    new ByteLengthQueuingStrategy({
      highWaterMark: 64 * 1024, // 64 KiB
    }),
  );
}

async function consumeIterator<T>(iter: AsyncIterator<T>) {
  while (true) {
    const { done } = await iter.next();
    if (done) break;
  }
}



================================================
FILE: modal-js/src/volume.ts
================================================
import { ObjectCreationType } from "../proto/modal_proto/api";
import { client } from "./client";
import { environmentName as configEnvironmentName } from "./config";
import { ClientError, Status } from "nice-grpc";
import { NotFoundError, InvalidError } from "./errors";
import { EphemeralHeartbeatManager } from "./ephemeral";
import type { EphemeralOptions } from "./app";

/** Options for `Volume.fromName()`. */
export type VolumeFromNameOptions = {
  environment?: string;
  createIfMissing?: boolean;
};

/** Volumes provide persistent storage that can be mounted in Modal Functions. */
export class Volume {
  readonly volumeId: string;
  readonly name?: string;
  private _readOnly: boolean = false;
  readonly #ephemeralHbManager?: EphemeralHeartbeatManager;

  /** @ignore */
  constructor(
    volumeId: string,
    name?: string,
    readOnly: boolean = false,
    ephemeralHbManager?: EphemeralHeartbeatManager,
  ) {
    this.volumeId = volumeId;
    this.name = name;
    this._readOnly = readOnly;
    this.#ephemeralHbManager = ephemeralHbManager;
  }

  static async fromName(
    name: string,
    options?: VolumeFromNameOptions,
  ): Promise<Volume> {
    try {
      const resp = await client.volumeGetOrCreate({
        deploymentName: name,
        environmentName: configEnvironmentName(options?.environment),
        objectCreationType: options?.createIfMissing
          ? ObjectCreationType.OBJECT_CREATION_TYPE_CREATE_IF_MISSING
          : ObjectCreationType.OBJECT_CREATION_TYPE_UNSPECIFIED,
      });
      return new Volume(resp.volumeId, name);
    } catch (err) {
      if (err instanceof ClientError && err.code === Status.NOT_FOUND)
        throw new NotFoundError(err.details);
      throw err;
    }
  }

  /** Configure Volume to mount as read-only. */
  readOnly(): Volume {
    return new Volume(this.volumeId, this.name, true, this.#ephemeralHbManager);
  }

  get isReadOnly(): boolean {
    return this._readOnly;
  }

  /**
   * Create a nameless, temporary Volume.
   * You will need to call `closeEphemeral()` to delete the Volume.
   */
  static async ephemeral(options: EphemeralOptions = {}): Promise<Volume> {
    const resp = await client.volumeGetOrCreate({
      objectCreationType: ObjectCreationType.OBJECT_CREATION_TYPE_EPHEMERAL,
      environmentName: configEnvironmentName(options.environment),
    });

    const ephemeralHbManager = new EphemeralHeartbeatManager(() =>
      client.volumeHeartbeat({ volumeId: resp.volumeId }),
    );

    return new Volume(resp.volumeId, undefined, false, ephemeralHbManager);
  }

  /** Delete the ephemeral Volume. Only usable with `Volume.ephemeral()`. */
  closeEphemeral(): void {
    if (this.#ephemeralHbManager) {
      this.#ephemeralHbManager.stop();
    } else {
      throw new InvalidError("Volume is not ephemeral.");
    }
  }
}



================================================
FILE: modal-js/test/app.test.ts
================================================
import { expect, test } from "vitest";
import { buildSandboxCreateRequestProto } from "../src/app";
import { PTYInfo_PTYType } from "../proto/modal_proto/api";

test("buildSandboxCreateRequestProto without PTY", async () => {
  const req = await buildSandboxCreateRequestProto("app-123", "img-456");

  const definition = req.definition!;
  expect(definition.ptyInfo).toBeUndefined();
});

test("buildSandboxCreateRequestProto with PTY", async () => {
  const req = await buildSandboxCreateRequestProto("app-123", "img-456", {
    pty: true,
  });

  const definition = req.definition!;
  const ptyInfo = definition.ptyInfo!;
  expect(ptyInfo.enabled).toBe(true);
  expect(ptyInfo.winszRows).toBe(24);
  expect(ptyInfo.winszCols).toBe(80);
  expect(ptyInfo.envTerm).toBe("xterm-256color");
  expect(ptyInfo.envColorterm).toBe("truecolor");
  expect(ptyInfo.ptyType).toBe(PTYInfo_PTYType.PTY_TYPE_SHELL);
});



================================================
FILE: modal-js/test/cloud_bucket_mount.test.ts
================================================
import { CloudBucketMount, Secret } from "modal";
import {
  cloudBucketMountToProto,
  endpointUrlToBucketType,
} from "../src/cloud_bucket_mount";
import { CloudBucketMount_BucketType } from "../proto/modal_proto/api";
import { expect, test } from "vitest";

test("CloudBucketMount constructor with minimal options", () => {
  const mount = new CloudBucketMount("my-bucket");

  expect(mount.bucketName).toBe("my-bucket");
  expect(mount.readOnly).toBe(false);
  expect(mount.requesterPays).toBe(false);
  expect(mount.secret).toBeUndefined();
  expect(mount.bucketEndpointUrl).toBeUndefined();
  expect(mount.keyPrefix).toBeUndefined();
  expect(mount.oidcAuthRoleArn).toBeUndefined();

  expect(endpointUrlToBucketType(mount.bucketEndpointUrl)).toBe(
    CloudBucketMount_BucketType.S3,
  );
});

test("CloudBucketMount constructor with all options", () => {
  const mockSecret = { secretId: "sec-123" } as Secret;

  const mount = new CloudBucketMount("my-bucket", {
    secret: mockSecret,
    readOnly: true,
    requesterPays: true,
    bucketEndpointUrl: "https://my-bucket.r2.cloudflarestorage.com",
    keyPrefix: "prefix/",
    oidcAuthRoleArn: "arn:aws:iam::123456789:role/MyRole",
  });

  expect(mount.bucketName).toBe("my-bucket");
  expect(mount.readOnly).toBe(true);
  expect(mount.requesterPays).toBe(true);
  expect(mount.secret).toBe(mockSecret);
  expect(mount.bucketEndpointUrl).toBe(
    "https://my-bucket.r2.cloudflarestorage.com",
  );
  expect(mount.keyPrefix).toBe("prefix/");
  expect(mount.oidcAuthRoleArn).toBe("arn:aws:iam::123456789:role/MyRole");

  expect(endpointUrlToBucketType(mount.bucketEndpointUrl)).toBe(
    CloudBucketMount_BucketType.R2,
  );
});

test("CloudBucketMount bucket type detection from endpoint URLs", () => {
  expect(endpointUrlToBucketType("")).toBe(CloudBucketMount_BucketType.S3);

  expect(
    endpointUrlToBucketType("https://my-bucket.r2.cloudflarestorage.com"),
  ).toBe(CloudBucketMount_BucketType.R2);

  expect(
    endpointUrlToBucketType("https://storage.googleapis.com/my-bucket"),
  ).toBe(CloudBucketMount_BucketType.GCP);

  expect(
    endpointUrlToBucketType("https://unknown-endpoint.com/my-bucket"),
  ).toBe(CloudBucketMount_BucketType.S3);

  expect(() => {
    endpointUrlToBucketType("://invalid-url");
  }).toThrowError("Invalid URL");
});

test("CloudBucketMount validation: requesterPays without secret", () => {
  expect(() => {
    new CloudBucketMount("my-bucket", {
      requesterPays: true,
    });
  }).toThrowError("Credentials required in order to use Requester Pays.");
});

test("CloudBucketMount validation: keyPrefix without trailing slash", () => {
  expect(() => {
    new CloudBucketMount("my-bucket", {
      keyPrefix: "prefix",
    });
  }).toThrowError(
    "keyPrefix will be prefixed to all object paths, so it must end in a '/'",
  );
});

test("cloudBucketMountToProto with minimal options", () => {
  const mount = new CloudBucketMount("my-bucket");
  const proto = cloudBucketMountToProto(mount, "/mnt/bucket");

  expect(proto.bucketName).toBe("my-bucket");
  expect(proto.mountPath).toBe("/mnt/bucket");
  expect(proto.credentialsSecretId).toBe("");
  expect(proto.readOnly).toBe(false);
  expect(proto.bucketType).toBe(CloudBucketMount_BucketType.S3);
  expect(proto.requesterPays).toBe(false);
  expect(proto.bucketEndpointUrl).toBeUndefined();
  expect(proto.keyPrefix).toBeUndefined();
  expect(proto.oidcAuthRoleArn).toBeUndefined();
});

test("cloudBucketMountToProto with all options", () => {
  const mockSecret = { secretId: "sec-123" } as Secret;

  const mount = new CloudBucketMount("my-bucket", {
    secret: mockSecret,
    readOnly: true,
    requesterPays: true,
    bucketEndpointUrl: "https://my-bucket.r2.cloudflarestorage.com",
    keyPrefix: "prefix/",
    oidcAuthRoleArn: "arn:aws:iam::123456789:role/MyRole",
  });

  const proto = cloudBucketMountToProto(mount, "/mnt/bucket");

  expect(proto.bucketName).toBe("my-bucket");
  expect(proto.mountPath).toBe("/mnt/bucket");
  expect(proto.credentialsSecretId).toBe("sec-123");
  expect(proto.readOnly).toBe(true);
  expect(proto.bucketType).toBe(CloudBucketMount_BucketType.R2);
  expect(proto.requesterPays).toBe(true);
  expect(proto.bucketEndpointUrl).toBe(
    "https://my-bucket.r2.cloudflarestorage.com",
  );
  expect(proto.keyPrefix).toBe("prefix/");
  expect(proto.oidcAuthRoleArn).toBe("arn:aws:iam::123456789:role/MyRole");
});



================================================
FILE: modal-js/test/cls.test.ts
================================================
import { expect, test } from "vitest";

import { Cls, NotFoundError } from "modal";

test("ClsCall", async () => {
  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");
  const instance = await cls.instance();

  // Try accessing a non-existent method
  expect(() => instance.method("nonexistent")).toThrowError(NotFoundError);

  const function_ = instance.method("echo_string");
  const result = await function_.remote([], { s: "hello" });
  expect(result).toEqual("output: hello");

  const cls2 = await Cls.lookup("libmodal-test-support", "EchoClsParametrized");
  const instance2 = await cls2.instance({ name: "hello-init" });

  const function2 = instance2.method("echo_parameter");
  const result2 = await function2.remote();
  expect(result2).toEqual("output: hello-init");
});

test("ClsNotFound", async () => {
  const cls = Cls.lookup("libmodal-test-support", "NotRealClassName");
  await expect(cls).rejects.toThrowError(NotFoundError);
});

test("ClsCallInputPlane", async () => {
  const cls = await Cls.lookup("libmodal-test-support", "EchoClsInputPlane");
  const instance = await cls.instance();

  const function_ = instance.method("echo_string");
  const result = await function_.remote([], { s: "hello" });
  expect(result).toEqual("output: hello");
});



================================================
FILE: modal-js/test/cls_with_options.test.ts
================================================
import { expect, onTestFinished, test } from "vitest";
import type { Secret, Volume } from "modal";

const _mockFunctionProto = {
  functionId: "fid",
  handleMetadata: {
    methodHandleMetadata: { echo_string: {} },
    classParameterInfo: { schema: [] },
  },
};

test("Cls.withOptions stacking", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");

  mock.handleUnary("FunctionBindParams", (req: any) => {
    expect(req).toMatchObject({ functionId: "fid" });
    const fo = req.functionOptions;
    expect(fo).toBeDefined();
    expect(fo.timeoutSecs).toBe(60);
    expect(fo.resources).toBeDefined();
    expect(fo.resources.milliCpu).toBe(250);
    expect(fo.resources.memoryMb).toBe(256);
    expect(fo.resources.gpuConfig).toBeDefined();
    expect(fo.secretIds).toEqual(["sec-1"]);
    expect(fo.replaceSecretIds).toBe(true);
    expect(fo.replaceVolumeMounts).toBe(true);
    expect(fo.volumeMounts).toEqual([
      {
        mountPath: "/mnt/test",
        volumeId: "vol-1",
        allowBackgroundCommits: true,
        readOnly: false,
      },
    ]);
    return { boundFunctionId: "fid-1", handleMetadata: {} };
  });

  const secret = { secretId: "sec-1" } as Secret;
  const volume = { volumeId: "vol-1" } as Volume;

  const optioned = cls
    .withOptions({ timeout: 45_000, cpu: 0.25 })
    .withOptions({ timeout: 60_000, memory: 256, gpu: "T4" })
    .withOptions({ secrets: [secret], volumes: { "/mnt/test": volume } });

  const instance = await optioned.instance();
  expect(instance).toBeTruthy();
});

test("Cls.withConcurrency/withConcurrency/withBatching chaining", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");

  mock.handleUnary("FunctionBindParams", (req: any) => {
    expect(req).toMatchObject({ functionId: "fid" });
    const fo = req.functionOptions;
    expect(fo).toBeDefined();
    expect(fo.timeoutSecs).toBe(60);
    expect(fo.maxConcurrentInputs).toBe(10);
    expect(fo.batchMaxSize).toBe(11);
    expect(fo.batchLingerMs).toBe(12);
    return { boundFunctionId: "fid-1", handleMetadata: {} };
  });

  const chained = cls
    .withOptions({ timeout: 60_000 })
    .withConcurrency({ maxInputs: 10 })
    .withBatching({ maxBatchSize: 11, waitMs: 12 });

  const instance = await chained.instance();
  expect(instance).toBeTruthy();
});

test("Cls.withOptions retries", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls, Retries } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");

  mock.handleUnary("FunctionBindParams", (req: any) => {
    const fo = req.functionOptions;
    expect(fo).toBeDefined();
    expect(fo.retryPolicy).toMatchObject({
      retries: 3,
      backoffCoefficient: 1.0,
      initialDelayMs: 1000,
      maxDelayMs: 60000,
    });
    return { boundFunctionId: "fid-1", handleMetadata: {} };
  });

  await cls.withOptions({ retries: 3 }).instance();

  mock.handleUnary("FunctionBindParams", (req: any) => {
    const fo = req.functionOptions;
    expect(fo).toBeDefined();
    expect(fo.retryPolicy).toMatchObject({
      retries: 2,
      backoffCoefficient: 2.0,
      initialDelayMs: 2000,
      maxDelayMs: 5000,
    });
    return { boundFunctionId: "fid-2", handleMetadata: {} };
  });

  const retries = new Retries({
    maxRetries: 2,
    backoffCoefficient: 2.0,
    initialDelayMs: 2000,
    maxDelayMs: 5000,
  });
  await cls.withOptions({ retries }).instance();
});

test("Cls.withOptions invalid values", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");
  await expect(cls.withOptions({ timeout: 1500 }).instance()).rejects.toThrow(
    /timeout must be a multiple of 1000ms/,
  );

  await expect(
    cls.withOptions({ scaledownWindow: 2500 }).instance(),
  ).rejects.toThrow(/scaledownWindow must be a multiple of 1000ms/);
});

test("withOptions({ secrets: [] }) binds and does not replace secrets", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  mock.handleUnary("FunctionBindParams", (req: any) => {
    expect(req).toMatchObject({ functionId: "fid" });
    const fo = req.functionOptions;
    expect(Array.isArray(fo.secretIds)).toBe(true);
    expect(fo.secretIds.length).toBe(0);
    expect(fo.replaceSecretIds).toBe(false);

    return { boundFunctionId: "fid-1", handleMetadata: {} };
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");
  const instance = await cls.withOptions({ secrets: [] }).instance();
  expect(instance).toBeTruthy();
});

test("withOptions({ volumes: {} }) binds and does not replace volumes", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Cls } = await import("modal");

  mock.handleUnary("FunctionGet", (_: any) => {
    return _mockFunctionProto;
  });

  mock.handleUnary("FunctionBindParams", (req: any) => {
    expect(req).toMatchObject({ functionId: "fid" });
    const fo = req.functionOptions;
    expect(Array.isArray(fo.volumeMounts)).toBe(true);
    expect(fo.volumeMounts.length).toBe(0);
    expect(fo.replaceVolumeMounts).toBe(false);

    return { boundFunctionId: "fid-1", handleMetadata: {} };
  });

  const cls = await Cls.lookup("libmodal-test-support", "EchoCls");
  const instance = await cls.withOptions({ volumes: {} }).instance();
  expect(instance).toBeTruthy();
});



================================================
FILE: modal-js/test/function.test.ts
================================================
import { Function_, NotFoundError } from "modal";
import { expect, onTestFinished, test } from "vitest";

test("FunctionCall", async () => {
  const function_ = await Function_.lookup(
    "libmodal-test-support",
    "echo_string",
  );

  // Represent Python kwargs.
  const resultKwargs = await function_.remote([], { s: "hello" });
  expect(resultKwargs).toBe("output: hello");

  // Try the same, but with args.
  const resultArgs = await function_.remote(["hello"]);
  expect(resultArgs).toBe("output: hello");
});

test("FunctionCallLargeInput", async () => {
  const function_ = await Function_.lookup(
    "libmodal-test-support",
    "bytelength",
  );
  const len = 3 * 1000 * 1000; // More than 2 MiB, offload to blob storage
  const input = new Uint8Array(len);
  const result = await function_.remote([input]);
  expect(result).toBe(len);
});

test("FunctionNotFound", async () => {
  const promise = Function_.lookup(
    "libmodal-test-support",
    "not_a_real_function",
  );
  await expect(promise).rejects.toThrowError(NotFoundError);
});

test("FunctionCallInputPlane", async () => {
  const function_ = await Function_.lookup(
    "libmodal-test-support",
    "input_plane",
  );
  const result = await function_.remote(["hello"]);
  expect(result).toBe("output: hello");
});

test("FunctionGetCurrentStats", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });

  mock.handleUnary("/FunctionGetCurrentStats", (req) => {
    expect(req).toMatchObject({ functionId: "fid-stats" });
    return { backlog: 3, numTotalTasks: 7 };
  });

  const { Function_ } = await import("modal");
  const function_ = new Function_("fid-stats");
  const stats = await function_.getCurrentStats();
  expect(stats).toEqual({ backlog: 3, numTotalRunners: 7 });
});

test("FunctionUpdateAutoscaler", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });

  mock.handleUnary("/FunctionUpdateSchedulingParams", (req) => {
    expect(req).toMatchObject({
      functionId: "fid-auto",
      settings: {
        minContainers: 1,
        maxContainers: 10,
        bufferContainers: 2,
        scaledownWindow: 300,
      },
    });
    return {};
  });

  const { Function_ } = await import("modal");
  const function_ = new Function_("fid-auto");
  await function_.updateAutoscaler({
    minContainers: 1,
    maxContainers: 10,
    bufferContainers: 2,
    scaledownWindow: 300,
  });

  mock.handleUnary("/FunctionUpdateSchedulingParams", (req) => {
    expect(req).toMatchObject({
      functionId: "fid-auto",
      settings: { minContainers: 2 },
    });
    return {};
  });

  await function_.updateAutoscaler({ minContainers: 2 });
});

test("FunctionGetWebUrl", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });

  mock.handleUnary("FunctionGet", (req) => {
    expect(req).toMatchObject({
      appName: "libmodal-test-support",
      objectTag: "web_endpoint",
    });
    return {
      functionId: "fid-web",
      handleMetadata: { webUrl: "https://endpoint.internal" },
    };
  });

  const { Function_ } = await import("modal");
  const web_endpoint = await Function_.lookup(
    "libmodal-test-support",
    "web_endpoint",
  );
  expect(await web_endpoint.getWebUrl()).toBe("https://endpoint.internal");
});

test("FunctionGetWebUrlOnNonWebFunction", async () => {
  const function_ = await Function_.lookup(
    "libmodal-test-support",
    "echo_string",
  );
  expect(await function_.getWebUrl()).toBeUndefined();
});



================================================
FILE: modal-js/test/function_call.test.ts
================================================
import { Function_, FunctionTimeoutError } from "modal";
import { expect, test } from "vitest";

test("FunctionSpawn", async () => {
  const function_ = await Function_.lookup(
    "libmodal-test-support",
    "echo_string",
  );

  // Spawn function with kwargs.
  let functionCall = await function_.spawn([], { s: "hello" });
  expect(functionCall.functionCallId).toBeDefined();

  // Get results after spawn.
  let resultKwargs = await functionCall.get();
  expect(resultKwargs).toBe("output: hello");

  // Try the same again; same results should still be available.
  resultKwargs = await functionCall.get();
  expect(resultKwargs).toBe("output: hello");

  // Lookup function that takes a long time to complete.
  const sleep = await Function_.lookup("libmodal-test-support", "sleep");

  // Spawn with long running input.
  functionCall = await sleep.spawn([], { t: 5 });
  expect(functionCall.functionCallId).toBeDefined();

  // Getting outputs with timeout raises error.
  const promise = functionCall.get({ timeout: 1000 }); // 1000ms
  await expect(promise).rejects.toThrowError(FunctionTimeoutError);
});

test("FunctionCallGet0", async () => {
  const sleep = await Function_.lookup("libmodal-test-support", "sleep");

  const call = await sleep.spawn([0.5]);
  // Polling for output with timeout 0 should raise an error, since the
  // function call has not finished yet.
  await expect(call.get({ timeout: 0 })).rejects.toThrowError(
    FunctionTimeoutError,
  );

  expect(await call.get()).toBe(null); // Wait for the function call to finish.
  expect(await call.get({ timeout: 0 })).toBe(null); // Now we can get the result.
});



================================================
FILE: modal-js/test/image.test.ts
================================================
import { App, Secret, Image } from "modal";
import { expect, onTestFinished, test } from "vitest";

test("ImageFromId", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await Image.fromRegistry("alpine:3.21").build(app);
  expect(image.imageId).toBeTruthy();

  const imageFromId = await Image.fromId(image.imageId);
  expect(imageFromId.imageId).toBe(image.imageId);

  await expect(Image.fromId("im-nonexistent")).rejects.toThrow();
});

test("ImageFromRegistry", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await app.imageFromRegistry("alpine:3.21");
  expect(image.imageId).toBeTruthy();
  expect(image.imageId).toMatch(/^im-/);
});

test("ImageFromRegistryWithSecret", async () => {
  // GCP Artifact Registry also supports auth using username and password, if the username is "_json_key"
  // and the password is the service account JSON blob. See:
  // https://cloud.google.com/artifact-registry/docs/docker/authentication#json-key
  // So we use GCP Artifact Registry to test this too.

  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await app.imageFromRegistry(
    "us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image",
    await Secret.fromName("libmodal-gcp-artifact-registry-test", {
      requiredKeys: ["REGISTRY_USERNAME", "REGISTRY_PASSWORD"],
    }),
  );
  expect(image.imageId).toBeTruthy();
  expect(image.imageId).toMatch(/^im-/);
});

test("ImageFromAwsEcr", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await app.imageFromAwsEcr(
    "459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python",
    await Secret.fromName("libmodal-aws-ecr-test", {
      requiredKeys: ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"],
    }),
  );
  expect(image.imageId).toBeTruthy();
  expect(image.imageId).toMatch(/^im-/);
});

test("ImageFromGcpArtifactRegistry", { timeout: 30_000 }, async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await app.imageFromGcpArtifactRegistry(
    "us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image",
    await Secret.fromName("libmodal-gcp-artifact-registry-test", {
      requiredKeys: ["SERVICE_ACCOUNT_JSON"],
    }),
  );
  expect(image.imageId).toBeTruthy();
  expect(image.imageId).toMatch(/^im-/);
});

test("CreateOneSandboxTopLevelImageAPI", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = Image.fromRegistry("alpine:3.21");
  expect(image.imageId).toBeFalsy();

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();
  await sb.terminate();

  expect(image.imageId).toMatch(/^im-/);
});

test("CreateOneSandboxTopLevelImageAPISecret", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await Image.fromRegistry(
    "us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image",
    await Secret.fromName("libmodal-gcp-artifact-registry-test", {
      requiredKeys: ["REGISTRY_USERNAME", "REGISTRY_PASSWORD"],
    }),
  );
  expect(image.imageId).toBeFalsy();

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();
  await sb.terminate();

  expect(image.imageId).toMatch(/^im-/);
});

test("ImageFromAwsEcrTopLevel", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await Image.fromAwsEcr(
    "459781239556.dkr.ecr.us-east-1.amazonaws.com/ecr-private-registry-test-7522615:python",
    await Secret.fromName("libmodal-aws-ecr-test", {
      requiredKeys: ["AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY"],
    }),
  );
  expect(image.imageId).toBeFalsy();

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();
  await sb.terminate();

  expect(image.imageId).toMatch(/^im-/);
});

test("ImageFromGcpEcrTopLevel", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await Image.fromGcpArtifactRegistry(
    "us-east1-docker.pkg.dev/modal-prod-367916/private-repo-test/my-image",
    await Secret.fromName("libmodal-gcp-artifact-registry-test", {
      requiredKeys: ["SERVICE_ACCOUNT_JSON"],
    }),
  );
  expect(image.imageId).toBeFalsy();

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();
  await sb.terminate();

  expect(image.imageId).toMatch(/^im-/);
});

test("ImageDelete", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();

  const image = await Image.fromRegistry("alpine:3.13").build(app);
  expect(image.imageId).toBeTruthy();
  expect(image.imageId).toMatch(/^im-/);

  const imageFromId = await Image.fromId(image.imageId);
  expect(imageFromId.imageId).toBe(image.imageId);

  await Image.delete(image.imageId);

  await expect(Image.fromId(image.imageId)).rejects.toThrow(
    "Could not find image with ID",
  );

  const newImage = await Image.fromRegistry("alpine:3.13").build(app);
  expect(newImage.imageId).toBeTruthy();
  expect(newImage.imageId).not.toBe(image.imageId);

  await expect(Image.delete("im-nonexistent")).rejects.toThrow(
    "No Image with ID",
  );
});

test("DockerfileCommands", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });

  const image = Image.fromRegistry("alpine:3.21").dockerfileCommands([
    "RUN echo hey > /root/hello.txt",
  ]);

  const sb = await app.createSandbox(image, {
    command: ["cat", "/root/hello.txt"],
  });

  const stdout = await sb.stdout.readText();
  expect(stdout).toBe("hey\n");

  await sb.terminate();
});

test("DockerfileCommandsEmptyArrayNoOp", () => {
  const image1 = Image.fromRegistry("alpine:3.21");
  const image2 = image1.dockerfileCommands([]);
  expect(image2).toBe(image1);
});

test("DockerfileCommandsChaining", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });

  const image = Image.fromRegistry("alpine:3.21")
    .dockerfileCommands(["RUN echo ${SECRET:-unset} > /root/layer1.txt"])
    .dockerfileCommands(["RUN echo ${SECRET:-unset} > /root/layer2.txt"], {
      secrets: [await Secret.fromObject({ SECRET: "hello" })],
    })
    .dockerfileCommands(["RUN echo ${SECRET:-unset} > /root/layer3.txt"]);

  const sb = await app.createSandbox(image, {
    command: [
      "cat",
      "/root/layer1.txt",
      "/root/layer2.txt",
      "/root/layer3.txt",
    ],
  });

  const stdout = await sb.stdout.readText();
  expect(stdout).toBe("unset\nhello\nunset\n");

  await sb.terminate();
});

test("DockerfileCommandsCopyCommandValidation", () => {
  expect(() => {
    Image.fromRegistry("alpine:3.21").dockerfileCommands([
      "COPY --from=alpine:latest /etc/os-release /tmp/os-release",
    ]);
  }).not.toThrow();

  expect(() => {
    Image.fromRegistry("alpine:3.21").dockerfileCommands([
      "COPY ./file.txt /root/",
    ]);
  }).toThrow(
    "COPY commands that copy from local context are not yet supported",
  );

  expect(() => {
    Image.fromRegistry("alpine:3.21").dockerfileCommands([
      "RUN echo 'COPY ./file.txt /root/'",
    ]);
  }).not.toThrow();

  expect(() => {
    Image.fromRegistry("alpine:3.21").dockerfileCommands([
      "RUN echo hey",
      "copy ./file.txt /root/",
      "RUN echo hey",
    ]);
  }).toThrow(
    "COPY commands that copy from local context are not yet supported",
  );
});

test("DockerfileCommandsWithOptions", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });
  const { Image } = await import("modal");

  mock.handleUnary("/ImageGetOrCreate", (req: any) => {
    expect(req).toMatchObject({
      appId: "ap-test",
      image: {
        dockerfileCommands: ["FROM alpine:3.21"],
        secretIds: [],
        baseImages: [],
        gpuConfig: undefined,
      },
      forceBuild: false,
    });
    return { imageId: "im-base", result: { status: 1 } };
  });

  mock.handleUnary("/ImageGetOrCreate", (req: any) => {
    expect(req).toMatchObject({
      appId: "ap-test",
      image: {
        dockerfileCommands: ["FROM base", "RUN echo layer1"],
        secretIds: [],
        baseImages: [{ dockerTag: "base", imageId: "im-base" }],
        gpuConfig: undefined,
      },
      forceBuild: false,
    });
    return { imageId: "im-layer1", result: { status: 1 } };
  });

  mock.handleUnary("/ImageGetOrCreate", (req: any) => {
    expect(req).toMatchObject({
      appId: "ap-test",
      image: {
        dockerfileCommands: ["FROM base", "RUN echo layer2"],
        secretIds: ["sc-test"],
        baseImages: [{ dockerTag: "base", imageId: "im-layer1" }],
        gpuConfig: {
          type: 0,
          count: 1,
          gpuType: "A100",
        },
      },
      forceBuild: true,
    });
    return { imageId: "im-layer2", result: { status: 1 } };
  });

  mock.handleUnary("/ImageGetOrCreate", (req: any) => {
    expect(req).toMatchObject({
      appId: "ap-test",
      image: {
        dockerfileCommands: ["FROM base", "RUN echo layer3"],
        secretIds: [],
        baseImages: [{ dockerTag: "base", imageId: "im-layer2" }],
        gpuConfig: undefined,
      },
      forceBuild: true,
    });
    return { imageId: "im-layer3", result: { status: 1 } };
  });

  const image = await Image.fromRegistry("alpine:3.21")
    .dockerfileCommands(["RUN echo layer1"])
    .dockerfileCommands(["RUN echo layer2"], {
      secrets: [new Secret("sc-test", "test_secret")],
      gpu: "A100",
      forceBuild: true,
    })
    .dockerfileCommands(["RUN echo layer3"], {
      forceBuild: true,
    })
    .build(new App("ap-test", "libmodal-test"));

  expect(image.imageId).toBe("im-layer3");
});



================================================
FILE: modal-js/test/proxy.test.ts
================================================
import { App, Proxy } from "modal";
import { expect, test } from "vitest";

test("CreateSandboxWithProxy", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const proxy = await Proxy.fromName("libmodal-test-proxy");
  expect(proxy.proxyId).toBeTruthy();
  expect(proxy.proxyId).toMatch(/^pr-/);

  const sb = await app.createSandbox(image, {
    proxy,
    command: ["echo", "hello, sandbox with proxy"],
  });
  expect(sb.sandboxId).toBeTruthy();

  await sb.terminate();
  expect(await sb.wait()).toBe(137);
});

test("ProxyNotFound", async () => {
  await expect(Proxy.fromName("non-existent-proxy-name")).rejects.toThrow(
    "Proxy 'non-existent-proxy-name' not found",
  );
});



================================================
FILE: modal-js/test/queue.test.ts
================================================
import { Queue, QueueEmptyError } from "modal";
import { expect, onTestFinished, test, vi } from "vitest";
import { ephemeralObjectHeartbeatSleep } from "../src/ephemeral";

test("QueueInvalidName", async () => {
  for (const name of ["has space", "has/slash", "a".repeat(65)]) {
    await expect(Queue.lookup(name)).rejects.toThrow();
  }
});

test("QueueEphemeral", async () => {
  const queue = await Queue.ephemeral();
  expect(queue.name).toBeUndefined();
  await queue.put(123);
  expect(await queue.len()).toBe(1);
  expect(await queue.get()).toBe(123);
  queue.closeEphemeral();
});

test("QueueSuite1", async () => {
  const queue = await Queue.ephemeral();
  expect(await queue.len()).toBe(0);

  await queue.put(123);
  expect(await queue.len()).toBe(1);
  expect(await queue.get()).toBe(123);

  await queue.put(432);
  expect(await queue.get({ timeout: 0 })).toBe(432);

  await expect(queue.get({ timeout: 0 })).rejects.toThrow(QueueEmptyError);
  expect(await queue.len()).toBe(0);

  await queue.putMany([1, 2, 3]);
  const results: number[] = [];
  for await (const item of queue.iterate()) {
    results.push(item);
  }
  expect(results).toEqual([1, 2, 3]);
  queue.closeEphemeral();
});

test("QueueSuite2", async () => {
  const results: number[] = [];
  const producer = async (queue: Queue) => {
    for (let i = 0; i < 10; i++) {
      await queue.put(i);
    }
  };

  const consumer = async (queue: Queue) => {
    for await (const item of queue.iterate({ itemPollTimeout: 1000 })) {
      results.push(item);
    }
  };

  const queue = await Queue.ephemeral();
  await Promise.all([producer(queue), consumer(queue)]);
  expect(results).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
  queue.closeEphemeral();
});

test("QueuePutAndGetMany", async () => {
  const queue = await Queue.ephemeral();
  await queue.putMany([1, 2, 3]);
  expect(await queue.len()).toBe(3);
  expect(await queue.getMany(3)).toEqual([1, 2, 3]);
  queue.closeEphemeral();
});

test("QueueNonBlocking", async () => {
  // Assuming the queue is available, these operations
  // Should succeed immediately.
  const queue = await Queue.ephemeral();
  await queue.put(123, { timeout: 0 });
  expect(await queue.len()).toBe(1);
  expect(await queue.get({ timeout: 0 })).toBe(123);
  queue.closeEphemeral();
});

test("QueueNonEphemeral", async () => {
  const queueName = `test-queue-${Date.now()}`;

  const queue1 = await Queue.lookup(queueName, { createIfMissing: true });
  expect(queue1.name).toBe(queueName);

  onTestFinished(async () => {
    await Queue.delete(queueName);
    await expect(Queue.lookup(queueName)).rejects.toThrow(); // confirm deletion
  });

  await queue1.put("data");

  const queue2 = await Queue.lookup(queueName);
  expect(await queue2.get()).toBe("data");
});

test("QueueEphemeralHeartbeatStopsAfterClose", async () => {
  const { MockGrpc } = await import("../test-support/grpc_mock");
  const mock = await MockGrpc.install();
  onTestFinished(async () => {
    await mock.uninstall();
  });

  vi.useFakeTimers();
  onTestFinished(() => {
    vi.useRealTimers();
  });

  let heartbeatCount = 0;

  mock.handleUnary("/QueueGetOrCreate", () => ({
    queueId: "test-queue-id",
  }));

  mock.handleUnary("/QueueHeartbeat", (_req) => {
    heartbeatCount++;
    return {};
  });

  const { Queue } = await import("../src/queue");
  const queue = await Queue.ephemeral();

  expect(heartbeatCount).toBe(1); // initial heartbeat
  queue.closeEphemeral();

  await vi.advanceTimersByTimeAsync(ephemeralObjectHeartbeatSleep * 3);
  expect(heartbeatCount).toBe(1);
});



================================================
FILE: modal-js/test/retries.test.ts
================================================
import { expect, test } from "vitest";
import { Retries } from "modal";
import { parseRetries } from "../src/retries";

test("parseRetries", async () => {
  const r = parseRetries(3)!;
  expect(r).toBeDefined();
  expect(r.maxRetries).toBe(3);
  expect(r.backoffCoefficient).toBe(1.0);
  expect(r.initialDelayMs).toBe(1000);
});

test("Retries constructor", async () => {
  const r = new Retries({
    maxRetries: 2,
    backoffCoefficient: 2.0,
    initialDelayMs: 2000,
    maxDelayMs: 5000,
  });
  expect(r.maxRetries).toBe(2);
  expect(r.backoffCoefficient).toBe(2.0);
  expect(r.initialDelayMs).toBe(2000);
  expect(r.maxDelayMs).toBe(5000);

  expect(() => new Retries({ maxRetries: -1 })).toThrow(/maxRetries/);
  expect(() => new Retries({ maxRetries: 0, backoffCoefficient: 0.9 })).toThrow(
    /backoffCoefficient/,
  );
  expect(() => new Retries({ maxRetries: 0, initialDelayMs: 61_000 })).toThrow(
    /initialDelayMs/,
  );
  expect(() => new Retries({ maxRetries: 0, maxDelayMs: 500 })).toThrow(
    /maxDelayMs/,
  );
});



================================================
FILE: modal-js/test/sandbox.test.ts
================================================
import { App, Volume, Sandbox, Secret, Image } from "modal";
import { parseGpuConfig, buildSandboxCreateRequestProto } from "../src/app";
import { expect, test, onTestFinished } from "vitest";
import { buildContainerExecRequestProto } from "../src/sandbox";
import { PTYInfo_PTYType } from "../proto/modal_proto/api";

test("CreateOneSandbox", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  expect(app.appId).toBeTruthy();
  expect(app.name).toBe("libmodal-test");

  const image = await app.imageFromRegistry("alpine:3.21");
  expect(image.imageId).toBeTruthy();

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();
  await sb.terminate();
  expect(await sb.wait()).toBe(137);
});

test("PassCatToStdin", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  // Spawn a sandbox running the "cat" command.
  const sb = await app.createSandbox(image, { command: ["cat"] });

  // Write to the sandbox's stdin and read from its stdout.
  await sb.stdin.writeText("this is input that should be mirrored by cat");
  await sb.stdin.close();
  expect(await sb.stdout.readText()).toBe(
    "this is input that should be mirrored by cat",
  );

  // Terminate the sandbox.
  await sb.terminate();
});

test("IgnoreLargeStdout", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("python:3.13-alpine");

  const sb = await app.createSandbox(image);
  try {
    const p = await sb.exec(["python", "-c", `print("a" * 1_000_000)`], {
      stdout: "ignore",
    });
    expect(await p.stdout.readText()).toBe(""); // Stdout is ignored
    // Stdout should be consumed after cancel, without blocking the process.
    expect(await p.wait()).toBe(0);
  } finally {
    await sb.terminate();
  }
});

test("SandboxCreateOptions", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sandbox = await app.createSandbox(image, {
    command: ["echo", "hello, params"],
    cloud: "aws",
    regions: ["us-east-1", "us-west-2"],
    verbose: true,
  });

  onTestFinished(async () => {
    await sandbox.terminate();
  });

  expect(sandbox).toBeDefined();
  expect(sandbox.sandboxId).toMatch(/^sb-/);

  const exitCode = await sandbox.wait();
  expect(exitCode).toBe(0);

  await expect(
    app.createSandbox(image, {
      cloud: "invalid-cloud",
    }),
  ).rejects.toThrow("INVALID_ARGUMENT");

  await expect(
    app.createSandbox(image, {
      regions: ["invalid-region"],
    }),
  ).rejects.toThrow("INVALID_ARGUMENT");
});

test("SandboxExecOptions", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  try {
    // Test with a custom working directory and timeout.
    const p = await sb.exec(["pwd"], {
      workdir: "/tmp",
      timeout: 5000,
    });

    expect(await p.stdout.readText()).toBe("/tmp\n");
    expect(await p.wait()).toBe(0);
  } finally {
    await sb.terminate();
  }
});

test("parseGpuConfig", () => {
  expect(parseGpuConfig(undefined)).toBeUndefined();
  expect(parseGpuConfig("T4")).toEqual({
    type: 0,
    count: 1,
    gpuType: "T4",
  });
  expect(parseGpuConfig("A10G")).toEqual({
    type: 0,
    count: 1,
    gpuType: "A10G",
  });
  expect(parseGpuConfig("A100-80GB")).toEqual({
    type: 0,
    count: 1,
    gpuType: "A100-80GB",
  });
  expect(parseGpuConfig("A100-80GB:3")).toEqual({
    type: 0,
    count: 3,
    gpuType: "A100-80GB",
  });
  expect(parseGpuConfig("T4:2")).toEqual({
    type: 0,
    count: 2,
    gpuType: "T4",
  });
  expect(parseGpuConfig("a100:4")).toEqual({
    type: 0,
    count: 4,
    gpuType: "A100",
  });

  expect(() => parseGpuConfig("T4:invalid")).toThrow(
    "Invalid GPU count: invalid. Value must be a positive integer.",
  );
  expect(() => parseGpuConfig("T4:")).toThrow(
    "Invalid GPU count: . Value must be a positive integer.",
  );
  expect(() => parseGpuConfig("T4:0")).toThrow(
    "Invalid GPU count: 0. Value must be a positive integer.",
  );
  expect(() => parseGpuConfig("T4:-1")).toThrow(
    "Invalid GPU count: -1. Value must be a positive integer.",
  );
});

test("SandboxWithVolume", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const volume = await Volume.fromName("libmodal-test-sandbox-volume", {
    createIfMissing: true,
  });

  const sandbox = await app.createSandbox(image, {
    command: ["echo", "volume test"],
    volumes: { "/mnt/test": volume },
  });

  expect(sandbox).toBeDefined();
  expect(sandbox.sandboxId).toMatch(/^sb-/);

  const exitCode = await sandbox.wait();
  expect(exitCode).toBe(0);
});

test("SandboxWithReadOnlyVolume", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await Image.fromRegistry("alpine:3.21");

  const volume = await Volume.fromName("libmodal-test-sandbox-volume", {
    createIfMissing: true,
  });

  const readOnlyVolume = volume.readOnly();
  expect(readOnlyVolume.isReadOnly).toBe(true);

  const sb = await app.createSandbox(image, {
    command: ["sh", "-c", "echo 'test' > /mnt/test/test.txt"],
    volumes: { "/mnt/test": readOnlyVolume },
  });

  expect(await sb.wait()).toBe(1);
  expect(await sb.stderr.readText()).toContain("Read-only file system");

  await sb.terminate();
});

test("SandboxWithTunnels", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sandbox = await app.createSandbox(image, {
    command: ["cat"],
    encryptedPorts: [8443],
    unencryptedPorts: [8080],
  });

  expect(sandbox).toBeDefined();
  expect(sandbox.sandboxId).toMatch(/^sb-/);

  const tunnels = await sandbox.tunnels();
  expect(Object.keys(tunnels)).toHaveLength(2);

  // Test encrypted tunnel (port 8443)
  const encryptedTunnel = tunnels[8443];
  expect(encryptedTunnel.host).toMatch(/\.modal\.host$/);
  expect(encryptedTunnel.port).toBe(443);
  expect(encryptedTunnel.url).toMatch(/^https:\/\//);
  expect(encryptedTunnel.tlsSocket).toEqual([
    encryptedTunnel.host,
    encryptedTunnel.port,
  ]);

  // Test unencrypted tunnel (port 8080)
  const unencryptedTunnel = tunnels[8080];
  expect(unencryptedTunnel.unencryptedHost).toMatch(/\.modal\.host$/);
  expect(typeof unencryptedTunnel.unencryptedPort).toBe("number");
  expect(unencryptedTunnel.tcpSocket).toEqual([
    unencryptedTunnel.unencryptedHost,
    unencryptedTunnel.unencryptedPort,
  ]);

  await sandbox.terminate();
});

test("CreateSandboxWithSecrets", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const secret = await Secret.fromName("libmodal-test-secret", {
    requiredKeys: ["c"],
  });
  expect(secret).toBeDefined();

  const sandbox = await app.createSandbox(image, {
    command: ["printenv", "c"],
    secrets: [secret],
  });
  expect(sandbox).toBeDefined();

  const result = await sandbox.stdout.readText();
  expect(result).toBe("hello world\n");
});

test("CreateSandboxWithNetworkAccessParams", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image, {
    command: ["echo", "hello, network access"],
    blockNetwork: false,
    cidrAllowlist: ["10.0.0.0/8", "192.168.0.0/16"],
  });

  onTestFinished(async () => {
    await sb.terminate();
  });

  expect(sb).toBeDefined();
  expect(sb.sandboxId).toMatch(/^sb-/);

  const exitCode = await sb.wait();
  expect(exitCode).toBe(0);

  await expect(
    app.createSandbox(image, {
      blockNetwork: false,
      cidrAllowlist: ["not-an-ip/8"],
    }),
  ).rejects.toThrow("Invalid CIDR: not-an-ip/8");

  await expect(
    app.createSandbox(image, {
      blockNetwork: true,
      cidrAllowlist: ["10.0.0.0/8"],
    }),
  ).rejects.toThrow(
    "cidrAllowlist cannot be used when blockNetwork is enabled",
  );
});

test("SandboxPollAndReturnCode", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sandbox = await app.createSandbox(image, { command: ["cat"] });

  expect(await sandbox.poll()).toBeNull();

  // Send input to make the cat command complete
  await sandbox.stdin.writeText("hello, sandbox");
  await sandbox.stdin.close();

  expect(await sandbox.wait()).toBe(0);
  expect(await sandbox.poll()).toBe(0);
});

test("SandboxPollAfterFailure", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sandbox = await app.createSandbox(image, {
    command: ["sh", "-c", "exit 42"],
  });

  expect(await sandbox.wait()).toBe(42);
  expect(await sandbox.poll()).toBe(42);
});

test("SandboxExecSecret", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  expect(sb.sandboxId).toBeTruthy();

  onTestFinished(async () => {
    await sb.terminate();
  });

  const secret = await Secret.fromName("libmodal-test-secret", {
    requiredKeys: ["c"],
  });
  const secret2 = await Secret.fromObject({ d: "3" });
  const printSecret = await sb.exec(["printenv", "c", "d"], {
    stdout: "pipe",
    secrets: [secret, secret2],
  });
  const secretText = await printSecret.stdout.readText();
  expect(secretText).toBe("hello world\n3\n");
});

test("SandboxFromId", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });
  const sbFromId = await Sandbox.fromId(sb.sandboxId);
  expect(sbFromId.sandboxId).toBe(sb.sandboxId);
});

test("SandboxWithWorkdir", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image, {
    command: ["pwd"],
    workdir: "/tmp",
  });

  onTestFinished(async () => {
    await sb.terminate();
  });

  expect(await sb.stdout.readText()).toBe("/tmp\n");
});

test("SandboxWithWorkdirValidation", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  await expect(
    app.createSandbox(image, {
      workdir: "relative/path",
    }),
  ).rejects.toThrow("workdir must be an absolute path, got: relative/path");
});

test("SandboxSetTagsAndList", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  const unique = `${Math.random()}`;

  const foundBefore: string[] = [];
  for await (const s of Sandbox.list({ tags: { "test-key": unique } })) {
    foundBefore.push(s.sandboxId);
  }
  expect(foundBefore.length).toBe(0);

  await sb.setTags({ "test-key": unique });

  const foundAfter: string[] = [];
  for await (const s of Sandbox.list({ tags: { "test-key": unique } })) {
    foundAfter.push(s.sandboxId);
  }
  expect(foundAfter).toEqual([sb.sandboxId]);
});

test("SandboxSetMultipleTagsAndList", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  const tagA = `A-${Math.random()}`;
  const tagB = `B-${Math.random()}`;
  const tagC = `C-${Math.random()}`;

  expect(await sb.getTags()).toEqual({});

  await sb.setTags({ "key-a": tagA, "key-b": tagB, "key-c": tagC });

  expect(await sb.getTags()).toEqual({
    "key-a": tagA,
    "key-b": tagB,
    "key-c": tagC,
  });

  let ids: string[] = [];
  for await (const s of Sandbox.list({ tags: { "key-a": tagA } })) {
    ids.push(s.sandboxId);
  }
  expect(ids).toEqual([sb.sandboxId]);

  ids = [];
  for await (const s of Sandbox.list({
    tags: { "key-a": tagA, "key-b": tagB },
  })) {
    ids.push(s.sandboxId);
  }
  expect(ids).toEqual([sb.sandboxId]);

  ids = [];
  for await (const s of Sandbox.list({
    tags: { "key-a": tagA, "key-b": tagB, "key-d": "not-set" },
  })) {
    ids.push(s.sandboxId);
  }
  expect(ids.length).toBe(0);
});

test("SandboxListByAppId", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  let count = 0;
  for await (const s of Sandbox.list({ appId: app.appId })) {
    expect(s.sandboxId).toMatch(/^sb-/);
    count++;
    if (count > 0) break;
  }
  expect(count).toBeGreaterThan(0);
});

test("NamedSandbox", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sandboxName = `test-sandbox-${Math.random().toString().substring(2, 10)}`;

  const sb = await app.createSandbox(image, {
    name: sandboxName,
    command: ["sleep", "60"],
  });

  onTestFinished(async () => {
    await sb.terminate();
  });

  const sb1FromName = await Sandbox.fromName("libmodal-test", sandboxName);
  expect(sb1FromName.sandboxId).toBe(sb.sandboxId);
  const sb2FromName = await Sandbox.fromName("libmodal-test", sandboxName);
  expect(sb2FromName.sandboxId).toBe(sb1FromName.sandboxId);

  await expect(
    app.createSandbox(image, {
      name: sandboxName,
      command: ["sleep", "60"],
    }),
  ).rejects.toThrow("already exists");
});

test("NamedSandboxNotFound", async () => {
  await expect(
    Sandbox.fromName("libmodal-test", "non-existent-sandbox"),
  ).rejects.toThrow("not found");
});

test("buildContainerExecRequestProto without PTY", async () => {
  const req = await buildContainerExecRequestProto("task-123", ["bash"]);

  expect(req.ptyInfo).toBeUndefined();
});

test("buildContainerExecRequestProto with PTY", async () => {
  const req = await buildContainerExecRequestProto("task-123", ["bash"], {
    pty: true,
  });

  const ptyInfo = req.ptyInfo!;
  expect(ptyInfo).toBeDefined();
  expect(ptyInfo.enabled).toBe(true);
  expect(ptyInfo.winszRows).toBe(24);
  expect(ptyInfo.winszCols).toBe(80);
  expect(ptyInfo.envTerm).toBe("xterm-256color");
  expect(ptyInfo.envColorterm).toBe("truecolor");
  expect(ptyInfo.ptyType).toBe(PTYInfo_PTYType.PTY_TYPE_SHELL);
  expect(ptyInfo.noTerminateOnIdleStdin).toBe(true);
});

test("buildSandboxCreateRequestProto merges env and secrets", async () => {
  const secret = await Secret.fromObject({ A: "1" });

  const req = await buildSandboxCreateRequestProto("ap", "im", {
    env: { B: "2" },
    secrets: [secret],
  });

  expect(req.definition!.secretIds).toHaveLength(2);
  expect(req.definition!.secretIds).toContain(secret.secretId);
});

test("buildSandboxCreateRequestProto with only env parameter", async () => {
  const req = await buildSandboxCreateRequestProto("ap", "im", {
    env: { B: "2", C: "3" },
  });

  expect(req.definition!.secretIds).toHaveLength(1);
});

test("buildSandboxCreateRequestProto with empty env object does not create secret", async () => {
  const req = await buildSandboxCreateRequestProto("ap", "im", {
    env: {},
  });

  expect(req.definition!.secretIds).toHaveLength(0);
});

test("buildContainerExecRequestProto merges env and secrets", async () => {
  const secret = await Secret.fromObject({ A: "1" });

  const req = await buildContainerExecRequestProto("ta", ["echo", "hello"], {
    env: { B: "2" },
    secrets: [secret],
  });

  expect(req.secretIds).toHaveLength(2);
  expect(req.secretIds).toContain(secret.secretId);
});

test("buildContainerExecRequestProto with only env parameter", async () => {
  const req = await buildContainerExecRequestProto("ta", ["echo", "hello"], {
    env: { B: "2" },
  });

  expect(req.secretIds).toHaveLength(1);
});

test("buildContainerExecRequestProto with empty env object does not create secret", async () => {
  const req = await buildContainerExecRequestProto("ta", ["echo", "hello"], {
    env: {},
  });

  expect(req.secretIds).toHaveLength(0);
});



================================================
FILE: modal-js/test/sandbox_filesystem.test.ts
================================================
import { App } from "modal";
import { expect, test, onTestFinished } from "vitest";

test("WriteAndReadBinaryFile", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  // Write binary data
  const writeHandle = await sb.open("/tmp/test.bin", "w");
  await writeHandle.write(testData);
  await writeHandle.close();

  // Read binary data
  const readHandle = await sb.open("/tmp/test.bin", "r");
  const readData = await readHandle.read();
  expect(readData).toEqual(testData);
  await readHandle.close();
});

test("AppendToFileBinary", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
  // Write initial content
  const writeHandle = await sb.open("/tmp/append.txt", "w");
  await writeHandle.write(testData);
  await writeHandle.close();

  // Append more content
  const moreTestData = new Uint8Array([7, 8, 9, 10]);
  const appendHandle = await sb.open("/tmp/append.txt", "a");
  await appendHandle.write(moreTestData);
  await appendHandle.close();

  // Read the entire file
  const readHandle = await sb.open("/tmp/append.txt", "r");
  const content = await readHandle.read();
  const expectedData = new Uint8Array([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 7, 8, 9, 10,
  ]);
  expect(content).toEqual(expectedData);
  await readHandle.close();
});

test("FileHandleFlush", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  const encodedData = new TextEncoder().encode("Test data");

  const handle = await sb.open("/tmp/flush.txt", "w");
  await handle.write(encodedData);
  await handle.flush(); // Ensure data is written to disk
  await handle.close();

  // Verify the data was written
  const readHandle = await sb.open("/tmp/flush.txt", "r");
  const content = await readHandle.read();
  expect(content).toEqual(encodedData);
  await readHandle.close();
});

test("MultipleFileOperations", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  // Create multiple files
  const encoder = new TextEncoder();
  const content1 = encoder.encode("File 1 content");
  const handle1 = await sb.open("/tmp/file1.txt", "w");
  await handle1.write(content1);
  await handle1.close();

  const handle2 = await sb.open("/tmp/file2.txt", "w");
  const content2 = encoder.encode("File 2 content");
  await handle2.write(content2);
  await handle2.close();

  // Read both files
  const read1 = await sb.open("/tmp/file1.txt", "r");
  const readContent1 = await read1.read();
  await read1.close();

  const read2 = await sb.open("/tmp/file2.txt", "r");
  const readContent2 = await read2.read();
  await read2.close();

  expect(readContent1).toEqual(content1);
  expect(readContent2).toEqual(content2);
});

test("FileOpenModes", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  // Test write mode (truncates)
  const encoder = new TextEncoder();
  const content1 = encoder.encode("Initial content");
  const writeHandle = await sb.open("/tmp/modes.txt", "w");
  await writeHandle.write(content1);
  await writeHandle.close();

  // Test read mode
  const readHandle = await sb.open("/tmp/modes.txt", "r");
  const readContent1 = await readHandle.read();
  expect(readContent1).toEqual(content1);
  await readHandle.close();

  // Test append mode
  const appendContent = encoder.encode(" appended");
  const appendHandle = await sb.open("/tmp/modes.txt", "a");
  await appendHandle.write(appendContent);
  await appendHandle.close();

  // Verify append worked
  const expectedContent = encoder.encode("Initial content appended");
  const finalRead = await sb.open("/tmp/modes.txt", "r");
  const finalContent = await finalRead.read();
  expect(finalContent).toEqual(expectedContent);
  await finalRead.close();
});

test("LargeFileOperations", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");
  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  // Create a larger file
  const encoder = new TextEncoder();
  const largeData = encoder.encode("x".repeat(1000));

  const writeHandle = await sb.open("/tmp/large.txt", "w");
  await writeHandle.write(largeData);
  await writeHandle.close();

  // Read it back
  const readHandle = await sb.open("/tmp/large.txt", "r");
  const content = await readHandle.read();
  expect(content).toEqual(largeData);
  expect(content.length).toBe(1000);
  await readHandle.close();
});



================================================
FILE: modal-js/test/sandbox_filesystem_snapshot.test.ts
================================================
import { App } from "modal";
import { expect, test, onTestFinished } from "vitest";

test("snapshotFilesystem", async () => {
  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await app.imageFromRegistry("alpine:3.21");

  const sb = await app.createSandbox(image);
  onTestFinished(async () => {
    await sb.terminate();
  });

  await sb.exec(["sh", "-c", "echo -n 'test content' > /tmp/test.txt"]);
  await sb.exec(["mkdir", "-p", "/tmp/testdir"]);

  const snapshotImage = await sb.snapshotFilesystem();
  expect(snapshotImage).toBeDefined();
  expect(snapshotImage.imageId).toMatch(/^im-/);

  await sb.terminate();

  // Create new sandbox from snapshot
  const sb2 = await app.createSandbox(snapshotImage);
  onTestFinished(async () => {
    await sb2.terminate();
  });

  // Verify file exists in snapshot
  const proc = await sb2.exec(["cat", "/tmp/test.txt"]);
  const output = await proc.stdout.readText();
  expect(output).toBe("test content");

  // Verify directory exists in snapshot
  const dirCheck = await sb2.exec(["test", "-d", "/tmp/testdir"]);
  expect(await dirCheck.wait()).toBe(0);
});



================================================
FILE: modal-js/test/secret.test.ts
================================================
import { App, Image, Secret } from "modal";
import { expect, test } from "vitest";

test("SecretFromName", async () => {
  const secret = await Secret.fromName("libmodal-test-secret");
  expect(secret).toBeDefined();
  expect(secret.secretId).toBeDefined();
  expect(secret.secretId).toMatch(/^st-/);
  expect(secret.name).toBe("libmodal-test-secret");

  const promise = Secret.fromName("missing-secret");
  await expect(promise).rejects.toThrowError(
    /Secret 'missing-secret' not found/,
  );
});

test("SecretFromNameWithRequiredKeys", async () => {
  const secret = await Secret.fromName("libmodal-test-secret", {
    requiredKeys: ["a", "b", "c"],
  });
  expect(secret).toBeDefined();

  const promise = Secret.fromName("libmodal-test-secret", {
    requiredKeys: ["a", "b", "c", "missing-key"],
  });
  await expect(promise).rejects.toThrowError(
    /Secret is missing key\(s\): missing-key/,
  );
});

test("SecretFromObject", async () => {
  const secret = await Secret.fromObject({ key: "value" });
  expect(secret).toBeDefined();

  const app = await App.lookup("libmodal-test", { createIfMissing: true });
  const image = await Image.fromRegistry("alpine:3.21");

  const sandbox = await app.createSandbox(image, {
    command: ["printenv", "key"],
    secrets: [secret],
  });

  const output = await sandbox.stdout.readText();
  expect(output).toBe("value\n");
});

test("SecretFromObjectInvalid", async () => {
  // @ts-expect-error testing runtime validation
  await expect(Secret.fromObject({ key: 123 })).rejects.toThrowError(
    /entries must be an object mapping string keys to string values/,
  );
});



================================================
FILE: modal-js/test/volume.test.ts
================================================
import { Volume } from "modal";
import { expect, test } from "vitest";

test("Volume.fromName", async () => {
  const volume = await Volume.fromName("libmodal-test-volume", {
    createIfMissing: true,
  });
  expect(volume).toBeDefined();
  expect(volume.volumeId).toBeDefined();
  expect(volume.volumeId).toMatch(/^vo-/);
  expect(volume.name).toBe("libmodal-test-volume");

  const promise = Volume.fromName("missing-volume");
  await expect(promise).rejects.toThrowError(
    /Volume 'missing-volume' not found/,
  );
});

test("Volume.readOnly", async () => {
  const volume = await Volume.fromName("libmodal-test-volume", {
    createIfMissing: true,
  });

  expect(volume.isReadOnly).toBe(false);

  const readOnlyVolume = volume.readOnly();
  expect(readOnlyVolume.isReadOnly).toBe(true);
  expect(readOnlyVolume.volumeId).toBe(volume.volumeId);
  expect(readOnlyVolume.name).toBe(volume.name);

  expect(volume.isReadOnly).toBe(false);
});

test("VolumeEphemeral", async () => {
  const volume = await Volume.ephemeral();
  expect(volume.name).toBeUndefined();
  expect(volume.volumeId).toMatch(/^vo-/);
  expect(volume.isReadOnly).toBe(false);
  expect(volume.readOnly().isReadOnly).toBe(true);
  volume.closeEphemeral();
});



================================================
FILE: modal-js/test-support/grpc_mock.ts
================================================
import { vi } from "vitest";

export class MockGrpc {
  // Map of short RPC name -> FIFO queue of handlers
  private readonly methodHandlerQueues: Map<
    string,
    Array<(req: unknown) => unknown | Promise<unknown>>
  > = new Map();

  static async install(): Promise<MockGrpc> {
    const instance = new MockGrpc();
    vi.resetModules();

    const mockClient: Record<string, (req: unknown) => Promise<unknown>> =
      new Proxy(
        {},
        {
          get(_target, propKey) {
            if (typeof propKey !== "string") return undefined;
            return (req: unknown) => instance.dispatch(propKey, req);
          },
        },
      );

    vi.doMock("../src/client", async () => {
      const actual = (await vi.importActual<any>("../src/client")) as Record<
        string,
        unknown
      >;
      return {
        ...actual,
        client: mockClient,
      };
    });

    return instance;
  }

  async uninstall(): Promise<void> {
    this.assertExhausted();
    vi.unmock("../src/client");
    vi.resetModules();
    this.methodHandlerQueues.clear();
  }

  private readonly dispatch = async (
    methodKey: string,
    actualRequest: unknown,
  ): Promise<unknown> => {
    const queue = this.methodHandlerQueues.get(methodKey) ?? [];
    if (queue.length === 0) {
      throw new Error(
        `Unexpected gRPC call: ${methodKey} with request ${formatValue(actualRequest)}`,
      );
    }
    const handler = queue.shift()!;
    const response = await handler(actualRequest);
    return structuredClone(response);
  };

  handleUnary(
    rpcName: string,
    handler: (req: unknown) => unknown | Promise<unknown>,
  ) {
    const methodKey = rpcToClientMethodName(shortName(rpcName));
    const queue = this.methodHandlerQueues.get(methodKey) ?? [];
    queue.push(handler);
    this.methodHandlerQueues.set(methodKey, queue);
  }

  assertExhausted() {
    const outstanding = Array.from(this.methodHandlerQueues.entries()).filter(
      ([, q]) => q.length > 0,
    );
    if (outstanding.length > 0) {
      const details = outstanding
        .map(([k, q]) => `- ${k}: ${q.length} expectation(s) remaining`)
        .join("\n");
      throw new Error(`Not all expected gRPC calls were made:\n${details}`);
    }
  }
}

function rpcToClientMethodName(name: string): string {
  return name.length ? name[0].toLowerCase() + name.slice(1) : name;
}

function shortName(method: string): string {
  if (method.startsWith("/")) {
    const idx = method.lastIndexOf("/");
    if (idx >= 0 && idx + 1 < method.length) {
      return method.slice(idx + 1);
    }
  }
  return method;
}

function formatValue(v: unknown): string {
  try {
    return JSON.stringify(v, undefined, 2);
  } catch {
    return String(v);
  }
}



================================================
FILE: test-support/README.md
================================================
# Test support for libmodal

Sign in to Modal, which you'll use for running the test programs.

Then deploy the apps and secrets in this folder using the Python client. This
requires being signed in to AWS (Modal Labs account):

```bash
test-support/setup.sh
```

Now you can run tests in each language.

```bash
# JavaScript
cd modal-js && npm run build && npm test

# Go
cd modal-go && go test -v -count=1 -parallel=10 . ./test
```



================================================
FILE: test-support/libmodal_test_support.py
================================================
import os
import time

import modal

app = modal.App("libmodal-test-support")


@app.function(min_containers=1)
def echo_string(s: str) -> str:
    return "output: " + s


@app.function(min_containers=1)
def sleep(t: int) -> None:
    time.sleep(t)


@app.function(min_containers=1)
def bytelength(buf: bytes) -> int:
    return len(buf)


@app.function(min_containers=1, experimental_options={"input_plane_region": "us-west"})
def input_plane(s: str) -> str:
    return "output: " + s


@app.cls(min_containers=1)
class EchoCls:
    @modal.method()
    def echo_string(self, s: str) -> str:
        return "output: " + s


@app.cls(min_containers=1, experimental_options={"input_plane_region": "us-west"})
class EchoClsInputPlane:
    @modal.method()
    def echo_string(self, s: str) -> str:
        return "output: " + s


@app.cls()
class EchoClsParametrized:
    name: str = modal.parameter(default="test")

    @modal.method()
    def echo_parameter(self) -> str:
        return "output: " + self.name

    @modal.method()
    def echo_env_var(self, var_name: str) -> str:
        return f"output: {var_name}='{os.getenv(var_name, '[not set]')}'"



================================================
FILE: test-support/setup.sh
================================================
#!/bin/bash

set -euo pipefail

cd "$(dirname "$0")"

echo "Deploying 'libmodal_test_support.py'..."
modal deploy libmodal_test_support.py

echo "Deploying Secret 'libmodal-test-secret'..."
modal secret create --force libmodal-test-secret \
  a=1 b=2 c="hello world" >/dev/null

# Must be signed into AWS CLI for Modal Labs
echo "Deploying Secret 'libmodal-aws-ecr-test'..."
ecr_test_secret=$(aws secretsmanager get-secret-value \
  --secret-id test/libmodal/AwsEcrTest --query 'SecretString' --output text)
modal secret create --force libmodal-aws-ecr-test \
  AWS_ACCESS_KEY_ID="$(echo "$ecr_test_secret" | jq -r '.AWS_ACCESS_KEY_ID')" \
  AWS_SECRET_ACCESS_KEY="$(echo "$ecr_test_secret" | jq -r '.AWS_SECRET_ACCESS_KEY')" \
  AWS_REGION=us-east-1 \
  >/dev/null

echo "Deploying Secret 'libmodal-gcp-artifact-registry-test'..."
gcp_test_secret=$(aws secretsmanager get-secret-value \
  --secret-id test/libmodal/GcpArtifactRegistryTest --query 'SecretString' --output text)
modal secret create --force libmodal-gcp-artifact-registry-test \
  SERVICE_ACCOUNT_JSON="$(echo "$gcp_test_secret" | jq -r '.SERVICE_ACCOUNT_JSON')" \
  REGISTRY_USERNAME="_json_key" \
  REGISTRY_PASSWORD="$(echo "$gcp_test_secret" | jq -r '.SERVICE_ACCOUNT_JSON')" \
  >/dev/null

echo "Deploying Secret 'libmodal-anthropic-secret'..."
anthropic_api_key_secret=$(aws secretsmanager get-secret-value \
    --secret-id dev/libmodal/AnthropicApiKey --query 'SecretString' --output text | jq -r '.ANTHROPIC_API_KEY')
modal secret create --force libmodal-anthropic-secret \
  ANTHROPIC_API_KEY="$anthropic_api_key_secret" \
  >/dev/null

echo
echo "NOTE! The tests also require a Proxy named 'libmodal-test-proxy', which cannot be created programmatically and must be created using the dashboard: https://modal.com/settings/modal-labs/proxy"



================================================
FILE: .github/workflows/ci.yaml
================================================
name: CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  test-support:
    name: Lint and set up test-support
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          submodules: true

      - name: Install uv
        uses: astral-sh/setup-uv@22695119d769bdb6f7032ad67b9bca0ef8c4a174 # v5
        with:
          python-version: "3.13"

      - run: |
          uv python install
          uv pip install modal ruff

      - run: |
          ruff check test-support/
          ruff format --check test-support/

      - run: test-support/setup.sh
        env:
          MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
          MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
          MODAL_ENVIRONMENT: libmodal
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1


  js:
    name: modal-js build, lint, and test
    runs-on: ubuntu-latest
    needs: test-support

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          submodules: true

      - uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4
        with:
          node-version: "22"

      - run: npm ci
        working-directory: ./modal-js

      - run: npm run format:check
        working-directory: ./modal-js

      - run: npm run check
        working-directory: ./modal-js

      - run: npm run lint
        working-directory: ./modal-js

      - run: npm run build
        working-directory: ./modal-js

      - run: npm test
        working-directory: ./modal-js
        env:
          MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
          MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
          MODAL_ENVIRONMENT: libmodal

  go:
    name: modal-go build, lint, and test
    runs-on: ubuntu-latest
    needs: test-support

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          submodules: true

      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: "1.24"
          cache-dependency-path: modal-go/go.sum

      - name: golangci-lint
        uses: golangci/golangci-lint-action@1481404843c368bc19ca9406f87d6e0fc97bdcfd # v7.0.0
        with:
          version: v2.1.5
          working-directory: ./modal-go

      - run: go test -v -count=1 -parallel=10 ./...
        working-directory: ./modal-go
        env:
          MODAL_TOKEN_ID: ${{ secrets.MODAL_TOKEN_ID }}
          MODAL_TOKEN_SECRET: ${{ secrets.MODAL_TOKEN_SECRET }}
          MODAL_ENVIRONMENT: libmodal



================================================
FILE: .github/workflows/docs.yaml
================================================
name: Docs

on:
  push:
    branches:
      - main
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}

permissions: # required for GitHub Pages
  contents: read
  pages: write
  id-token: write

jobs:
  js:
    name: TypeDoc for modal-js
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          submodules: true

      - uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4
        with:
          node-version: "22"

      - run: npm ci
        working-directory: ./modal-js

      - run: npm run docs
        working-directory: ./modal-js

      - name: Upload docs artifact
        if: ${{ github.ref == 'refs/heads/main' }}
        uses: actions/upload-pages-artifact@7b1f4a764d45c48632c6b24a0339c27f5614fb0b # v4.0.0
        with:
          path: ./modal-js/docs

  deploy:
    name: Deploy to GitHub Pages
    needs: js
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    environment:
      name: github-pages # creates/updates the Pages env
      url: ${{ steps.deploy.outputs.page_url }}

    steps:
      - id: deploy
        uses: actions/deploy-pages@d6db90164ac5ed86f2b6aed7e0febac5b3c0c03e # v4.0.5



================================================
FILE: .github/workflows/publish.yaml
================================================
name: Publish Release

on:
  push:
    branches:
      - main

jobs:
  publish:
    runs-on: ubuntu-24.04
    if: startsWith(github.event.head_commit.message, '[RELEASE] Prepare release for')
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        submodules: true

    - uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
      with:
        python-version: '3.13'

    - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
      with:
        node-version: "20.x"
        cache: 'npm'
        registry-url: 'https://registry.npmjs.org'
        cache-dependency-path: modal-js/package-lock.json

    - name: Install npm packages
      run: npm install
      working-directory: ./modal-js

    - name: Config git user
      run: |
        git config user.name "${GITHUB_ACTOR}"
        git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

    - name: Publish and push tags
      run: |
        python ci/release.py publish
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}



================================================
FILE: .github/workflows/release.yaml
================================================
name: Open PR for release

on:
  workflow_dispatch:
    inputs:
      update:
        required: true
        type: choice
        options:
        - patch
        - minor
        - major

jobs:
  open-pr-for-release:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      pull-requests: write

    steps:
    - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        submodules: true

    - uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
      with:
        python-version: '3.13'

    - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
      with:
        node-version: 20
        cache: 'npm'
        cache-dependency-path: modal-js/package-lock.json

    - name: Install npm packages
      run: npm install
      working-directory: ./modal-js

    - name: Generate a token
      id: generate-token
      uses: actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b # v2.1.1
      with:
        app-id: ${{ vars.RELEASE_APP_ID }}
        private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

    - name: Config git user
      run: |
        git config user.name "${GITHUB_ACTOR}"
        git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

    - name: Switch to ci-release and make release commits
      run: |
        git switch -c ci-release
        python ci/release.py version ${{ inputs.update }}
        git push origin ci-release --force

    - name: Create Pull Request
      run: |
        PR_TITLE="$(git log -1 --pretty=%B)"
        gh pr create --title "$PR_TITLE" --body "$PR_TITLE" --base main --head ci-release
      env:
        GH_TOKEN: ${{ steps.generate-token.outputs.token }}



